<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png"><link rel="icon" href="/img/avatar.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="Zeyu Dong"><meta name="keywords" content=""><meta name="description" content="这是 HITsz 数据库系统笔记，欢迎到我的 GitHub 上查看，有笔记说明和源码，作业和实验报告，希望对你有帮助 因为写笔记的软件为 Typora，对 markdown 的支持较为完善，转移到博客平台可能存在数学公式错误  数据库基本概念数据抽象 通过抽象来对用户屏蔽复杂性，以简化用户与系统的交互。   物理层（或内部层）： ​    最低层次的抽象，描述数据实际上是怎样存储的和复杂的底层数"><meta property="og:type" content="article"><meta property="og:title" content="数据库系统笔记"><meta property="og:url" content="https://ailanxier.top/Database_System"><meta property="og:site_name" content="Ailanxier"><meta property="og:description" content="这是 HITsz 数据库系统笔记，欢迎到我的 GitHub 上查看，有笔记说明和源码，作业和实验报告，希望对你有帮助 因为写笔记的软件为 Typora，对 markdown 的支持较为完善，转移到博客平台可能存在数学公式错误  数据库基本概念数据抽象 通过抽象来对用户屏蔽复杂性，以简化用户与系统的交互。   物理层（或内部层）： ​    最低层次的抽象，描述数据实际上是怎样存储的和复杂的底层数"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://ailanxier.top/img/home/DS.png"><meta property="article:published_time" content="2022-01-17T09:37:02.660Z"><meta property="article:modified_time" content="2022-05-19T13:03:36.000Z"><meta property="article:author" content="Zeyu Dong"><meta property="article:tag" content="Hitsz"><meta property="article:tag" content="数据库"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://ailanxier.top/img/home/DS.png"><title>数据库系统笔记 - Ailanxier</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/mac.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"ailanxier.top",root:"/",version:"1.9.0",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"§"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!1,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"Vnw3P6XfzGV1nFXBCmueJQuN-gzGzoHsz",app_key:"ximSsc1aMmHfi7SNO8jMNm9F",server_url:"https://vnw3p6xf.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml"};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.0.0"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Ailanxier</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/bg/post.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="数据库系统笔记"></span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> Zeyu Dong </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-01-17 17:37" pubdate>2022年1月17日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 39k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i>326 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar category-bar" style="margin-right:-1rem"><div class="category-list"><div class="category row nomargin-x"><a class="category-item list-group-item category-item-action col-10 col-md-11 col-xm-11" title="课程笔记" id="heading-311a46cfdaa3afda544e9285644f70d7" role="tab" data-toggle="collapse" href="#collapse-311a46cfdaa3afda544e9285644f70d7" aria-expanded="true">课程笔记 <span class="list-group-count">(2)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-311a46cfdaa3afda544e9285644f70d7" role="tabpanel" aria-labelledby="heading-311a46cfdaa3afda544e9285644f70d7"><div class="category-post-list"><a href="/Operating_System" title="操作系统笔记" class="list-group-item list-group-item-action"><span class="category-post">操作系统笔记</span> </a><a href="/Database_System" title="数据库系统笔记" class="list-group-item list-group-item-action active"><span class="category-post">数据库系统笔记</span></a></div></div></div></div></aside></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">数据库系统笔记</h1><p class="note note-info">本文最后更新于：2022年5月19日 晚上</p><div class="markdown-body"><blockquote><p>这是 HITsz 数据库系统笔记，<a target="_blank" rel="noopener" href="https://github.com/ailanxier/Database-System-Note">欢迎到我的 GitHub 上查看，有笔记说明和源码，作业和实验报告</a>，希望对你有帮助</p><p><del>因为写笔记的软件为 Typora，对 markdown 的支持较为完善，转移到博客平台可能存在数学公式错误</del></p></blockquote><h2 id="数据库基本概念"><a href="#数据库基本概念" class="headerlink" title="数据库基本概念"></a>数据库基本概念</h2><h3 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h3><blockquote><p>通过抽象来对用户屏蔽复杂性，以简化用户与系统的交互。</p></blockquote><ul><li><p>物理层（或内部层）：</p><p>​ <strong>最低层次</strong>的抽象，描述数据实际上是<strong>怎样存储的</strong>和复杂的底层数据结构（存储路径、存储方式、索引方式）。</p></li><li><p>逻辑层（或概念层）：</p><p>​ 比物理层层次稍高的抽象，描述数据库中<strong>存储什么数据</strong>及这些<strong>数据间关系</strong>。</p></li><li><p>视图层（或外部层）：</p><p>​ 最高层次的抽象，只描述整个数据库的<strong>某个部分</strong>。用于并不需要关心所有的信息，而只需要访问数据库的一部分的用户。同一数据库有<strong>多个视图</strong>。</p></li><li><p>实例：</p><p>​ 特定时刻存储在数据库中的信息的集合称作数据库的一个<strong>实例</strong>。</p></li><li><p>模式：</p><p>​ 数据库的总体设计称作数据库<strong>模式</strong>（schema），是对数据库中<strong>数据</strong>所进行的一种<strong>结构性的描述</strong>。</p><blockquote><p>数据库<strong>模式</strong>对应于程序设计语言中的<strong>变量声明</strong>（以及与之关联的类型的定义）。</p><p>每个变量在特定的时刻会有特定的值，程序中变量在<strong>某一时刻的值</strong>对应于数据库模式的一个<strong>实例</strong>。</p></blockquote></li><li><p>在不同抽象层次描述数据库，就可定义出<strong>物理模式，逻辑模式和视图模式</strong>。</p><blockquote><p>相同模式有不同名称：</p><p>| 视图英文 | | 三级模式两层映像结构中的名字 | | | |<br>| :————————-: | :———: | :—————————————: | :———: | :———————: | :——: |<br>| External Schema | 外模式 | 局部模式🗡 | 视图模式 | 用户模式 | 子模式 |<br>| (Conceptual) Schema | 概念模式 | 全局模式 | 逻辑模式 | 也可简称「模式」 | |<br>| Internal Schema | 内模式 | 物理模式 | 存储模式 | | |</p></blockquote></li><li><p>两层映像：</p><ul><li><p>E-C Mapping（External Schema-Conceptual Schema Mapping）：</p><p>​ 将<strong>外模式</strong>映射为<strong>概念模式</strong>，从而支持实现数据概念视图向外部视图的转换，便于用户观察和使用。</p><blockquote><p>逻辑数据独立性🗡</p><p>​ 当概念模式变化时，可以不改变外部模式（只需改变 E-C Mapping），从而无需改变应用程序。</p></blockquote></li><li><p>C-I Mapping（Conceptual Schema-Internal Schema Mapping）：</p><p>​ 将<strong>概念模式</strong>映射为<strong>内模式</strong>，从而支持实现数据概念视图向内部视图的转换，便于计算机进行存储和处理。</p><blockquote><p>物理数据独立性：</p><p>​ 当内部模式（物理模式）变化时，可以不改变概念模式（只需改变 C-I Mapping），从而不改变外部模式。</p></blockquote></li></ul></li></ul><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><blockquote><p>数据库结构的基础是数据模型。</p></blockquote><ul><li><p>PPT 中的分类（往年考过三个模型的优缺点🗡）：</p><ul><li><p>层次模型按树的形式组织数据：</p><p><img src="/img/blog/ds-note-images/image-20211118124141153.png" srcset="/img/loading.gif" lazyload style="zoom:67%"></p><ul><li>优点：<ul><li>数据<strong>结构简单清晰</strong>。</li><li><strong>查询效率高</strong>。记录之间的联系用有向边表示，这种联系在 DBMS 中通常使用指针实现。</li><li><strong>性能</strong>优于关系数据库，不低于网状数据库。</li><li>提供了良好的<strong>完整性支持</strong>。</li></ul></li><li>缺点：<ul><li>对于<strong>非层次</strong>的联系（如多对多的联系）不适用。</li><li>一个子节点可能有<strong>多个父节点导致冗余</strong>，操作复杂。</li><li>必须通过父节点才能查找子节点。</li></ul></li></ul></li><li><p>网状模型按图的形式组织数据：</p><p><img src="/img/blog/ds-note-images/image-20211118124756242.png" srcset="/img/loading.gif" lazyload style="zoom:67%"></p><ul><li><p>优点：</p><p>​ 能够更为直接地表示现实世界，具有良好的性能，<strong>存取效率高</strong>。</p></li><li><p>缺点：</p><ul><li><strong>结构复杂</strong>。</li><li>网状模型的数据定义语言和数据管理<strong>语言复杂</strong>。</li><li>应用<strong>程序编写困难</strong>。</li></ul></li></ul><blockquote><p>层次结构和网状结构共有的缺点：</p><ul><li>数据之间的关联关系由复杂的<strong>指针系统</strong>来维系，结构描述复杂</li><li>数据检索操作依赖于由指针系统指示的<strong>路径</strong></li><li>不能有效支持<strong>记录集合的操作</strong></li></ul></blockquote></li><li><p>关系模型按表的形式组织数据：</p><p>​ 优点：</p><ul><li>数据检索操作<strong>不依赖于路径信息</strong>或过程信息，支持<strong>非过程化的数据操作</strong></li><li>有效支持<strong>记录集合</strong>的操作</li><li>较为完善的理论基础</li></ul></li></ul></li><li><p>书上的分类：</p><ul><li><p>关系模型：</p><p>​ 用<strong>表</strong>的集合来表示<strong>数据和数据间的联系</strong>。</p></li><li><p>实体 - 联系（E-R，entity-relationship）模型：</p><ul><li>基于对现实世界的认识。</li><li>现实世界由一组称作<strong>实体的基本对象</strong>以及这些<strong>对象间的联系</strong>构成。</li><li><strong>实体</strong>是现实世界中可<strong>区别于其他对象</strong>的一件「事情」或一个「物体」</li></ul><blockquote><p>关系模型是数据模型，而 E-R 模型是概念模型。</p></blockquote></li><li><p>基于对象的数据模型（应该不怎么学）</p></li></ul></li></ul><h3 id="数据库系统和语言"><a href="#数据库系统和语言" class="headerlink" title="数据库系统和语言"></a>数据库系统和语言</h3><ul><li><p>数据库系统：</p><ul><li>数据库（DB，Database）</li><li><strong>数据库管理系统</strong>（DBMS，Database Management System）</li><li>数据库应用（DBAP，DataBaseApplication）</li><li>数据库管理员（DBA，DataBaseAdministrator）</li></ul></li><li><p>数据库语言（DBMS 提供的）：</p><ul><li><p>数据定义语言（DDL，Data Definition Language）：</p><p>​ 定义表名，表标题，列名及其结构形式。</p><blockquote><p>新数据插入时（更新数据库时）要检查<strong>完整性约束</strong>，防止不符合规范的数据进入数据库：</p><ul><li><p>域约束：</p><p>​ 每个属性都必须对应于一个<strong>所有可能的取值构成的域</strong>（例如，整数型、字符型、日期/时间型）。域约束是完整性约束的最基本形式。</p></li><li><p>参照（引用）完整性：</p><p>​ 一个关系中给定属性集上的取值也在另一关系的某一属性集的取值中出现。</p></li><li><p>断言：</p><p>​ 一个断言就是数据库需要<strong>始终满足的某一条件</strong>（域约束和参照完整性约束是断言的特殊形式），例如：「每一学期每一个系必须至少开设 $5$ 门课程」只能表达成一个断言。如果断言有效，则以后只有不破坏断言的数据库更新才被允许。</p></li></ul></blockquote></li><li><p>数据操纵语言（DML，Data Manipulation Language）：</p><p>​ 对数据库进行<strong>增、删、改、查</strong>等操作。</p></li><li><p>数据控制语言（DCL，Data Control Language）：</p><p>​ 对不同操作和用户的约束。</p></li></ul></li></ul><h2 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li><p>表的列，也叫字段/属性/数据项，包括列名和列值。</p></li><li><p>表的行，也叫元组（$n$ 元组就是一个有 $n$ 个值的元组）/记录。</p></li><li><p>域：</p><p>​ 对于关系的每个<strong>属性</strong>，都存在一个允许取值的集合（即<strong>域</strong>），这组值具有相同的数据类型。</p><blockquote><p>集合中元素的个数称为域的<strong>基数</strong>。</p></blockquote></li><li><p>域的笛卡尔积：</p><p>​ 一组域 $D_1,D_2,\cdots,D_n$ 的笛卡尔积为：$D_1×D_2×\cdots×D_n = \{ (d_1 , d_2 , … , d_n) | d_i∈D_i , i=1,\cdots,n\}$，笛卡尔积每个元素 $(d_1 , d_2 , … , d_n)$ 称作一个 $n$ - 元组。</p></li><li><p>关系：</p><p>​ 一组域 $D_1,D_2,\cdots,D_n$ 的笛卡尔积的<strong>子集</strong>。</p></li><li><p><strong>关系模式或表标题</strong>：</p><p>​ 用 $R(A_1: D_1, A_2: D_2, \ldots, A_n: D_n)$ 表示，可简记为 $R(A_1, A_2, \ldots,A_n)$ 来描述关系：</p><ul><li>$R$ 是关系的名字。</li><li>$A_i$ 是<strong>属性</strong>。</li><li>$D_i$ 是属性所对应的<strong>域</strong>（属性的类型、长度）。</li><li>$n$ 是关系的<strong>度或目</strong>，即有多少列。</li><li>关系模式中 $A_i (i = 1,\cdots,n)$ 必须是不同的, 而 $D_i(i = 1,\cdots,n)$ 是可以相同的。</li></ul></li></ul><h3 id="关系的特性"><a href="#关系的特性" class="headerlink" title="关系的特性"></a>关系的特性</h3><ul><li><p>列是同质：</p><p>​ 每一列中的列值来自同一域，是同一类型的数据。</p></li><li><p>不同的列可来自同一个域</p></li><li><p>列位置互换性：</p><p>​ 区分哪一列是靠列名，与列的顺序无关。</p></li><li><p>行位置互换性：</p><p>​ 区分哪一行是靠某一或某几列的值（关键字/键字/码字）。</p></li><li><p>任意两个元组不能完全相同</p></li><li><p>属性不可再分特性（关系第一范式）</p></li></ul><h3 id="码（键）"><a href="#码（键）" class="headerlink" title="码（键）"></a>码（键）</h3><ul><li><p>超码（superkey）：</p><p>​ <strong>超码</strong>是一个或多个属性的集合，这些属性的组合可以使我们在一个关系中<strong>唯一地标识一个元组</strong>。</p><blockquote><p>两个不同元组的超码属性的取值不会完全相同。</p></blockquote></li><li><p>候选码：</p><p>​ 如果一个超码的任意真子集都不能成为超码，这样的最小超码称为<strong>候选码</strong>。</p></li><li><p>主码：</p><p>​ 当有多个候选码时，可以选定一个作为<strong>主码</strong>。</p></li><li><p>主属性与非主属性：</p><p>​ 包含在<strong>任何一个候选码</strong>中的属性被称作<strong>主属性</strong>，其他属性被称作<strong>非主属性</strong>。</p><blockquote><p>如果关系的所有属性组是这个关系的候选码，称为<strong>全码</strong>。</p></blockquote></li><li><p>外码：</p><p>​ 关系 $R$ 中的一个属性组，它不是 $R$ 的候选码，但它与另一个关系候选码（主码）相对应，则称这个属性组为 $R$ 的<strong>外码</strong>。</p></li></ul><h3 id="关系模型中的完整性"><a href="#关系模型中的完整性" class="headerlink" title="关系模型中的完整性"></a>关系模型中的完整性</h3><ul><li><p><strong>实体完整性</strong>：</p><p>​ 关系的<strong>主码</strong>中的属性值不能为<strong>空值</strong>。</p></li><li><p><strong>参照完整性</strong>：</p><p>​ 如果关系 $R_1$ 的<strong>外码</strong> $a$ 与关系 $R_2$ 的<strong>主码</strong> $a$ 相对应，则 $R_1$ 中的<strong>每一个元组</strong>的 $a$ 值或者等于 $R_2$ 中<strong>某个元组</strong>的 $a$ 值，或者为<strong>空值</strong>。</p></li><li><p>用户自定义完整性：</p><p>​ 用户针对具体的应用环境定义的完整性约束条件。</p></li></ul><blockquote><p>这一章缺少了很关键的关系代数。</p></blockquote><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><h3 id="实体-联系（E-R）模型"><a href="#实体-联系（E-R）模型" class="headerlink" title="实体-联系（E-R）模型"></a>实体-联系（E-R）模型</h3><ul><li><p>E-R 模型的基本观点：</p><p>​ 世界是由一组称作<strong>实体的基本对象和这些对象之间的联系</strong>构成的。</p></li><li><p>实体：</p><p>​ <strong>实体</strong>是现实世界中可区别于所有其他对象的一个「事物」或「对象」。每个实体有一组性质（属性），其中一些性质的值可以唯一地标识一个实体。</p></li><li><p>实体集：</p><p>​ <strong>实体集</strong>是相同类型即具有相同性质（或属性）的一个实体集合。</p><blockquote><p>注意：以上是书中的定义，PPT 中的「实体」= 书中的「实体集」，PPT 的「实例」= 书中的「实体」。</p><p>以下采用书本的定义描述。</p></blockquote></li><li><p>联系集：</p><ul><li><p><strong>联系</strong>是指<strong>多个实体间</strong>的相互关联。</p></li><li><p><strong>联系集</strong>是相同类型联系的集合。正规地说，联系集是 $n \geqslant 2$ 个（可能相同的）实体集上的数学关系。如果 $E_1, E_2, \cdots, E_{n}$ 为实体集，那么联系集 $R$ 是</p><script type="math/tex;mode=display">\{(e_1, e_2, \cdots, e_{n}) \mid e_1 \in E_1, e_2 \in E_2, \cdots, e_{n} \in E_{n}\}</script><p>的一个<strong>子集</strong>（相当于实体集笛卡尔积的一个子集），而 $(e_1, e_2, \cdots, e_{n})$ 是一个<strong>联系</strong>，$e_i$ 是 $E_i$ 的属性集合的子集。</p><blockquote><p>实体集之间的联系称为<strong>参与</strong>。实体集 $E_1, E_2, \cdots, E_{n}$ 参与联系集 $R$。</p><p>举例：实体集 $Student,Course$ 参与联系集 $SC$。</p></blockquote></li><li><p>参与联系集的<strong>实体集的数目</strong>称为联系集的<strong>度</strong>。</p></li><li><p>实体在联系中扮演的功能称为实体的<strong>角色</strong>。</p></li></ul></li><li><p>属性：</p><ul><li><p>每个属性都有一个可取值的集合，称为该属性的<strong>域或者值集</strong>。</p></li><li><p>属性的分类：</p><ul><li><p>简单（单一）属性：</p><p>​ 它们不能划分为更小的部分。</p></li><li><p>复合属性：</p><p>​ 将属性再划分为更小的部分（即其他属性）。</p><blockquote><p>地址细分（省市）</p></blockquote></li><li><p>单值属性：</p><p>​ 对一个特定实体，一个属性都只有<strong>单独的一个值</strong>。</p></li><li><p>多值属性：</p><p>​ 对某个特定实体而言，一个属性可能对应于<strong>一组值</strong>（即一个属性可以取多个值）。</p><blockquote><p>一个人有多个电话号码</p></blockquote></li></ul></li></ul></li><li><p>联系集的类型：</p><ul><li><p>一对一：</p><p>​ $A$ 中的一个实体<strong>至多</strong>与 $B$ 中的一个实体相关联，并且 $B$ 中的一个实体也至多与 $A$ 中的一个实体相关联。</p></li><li><p>一对多：</p><p>​ $A$ 中的一个实体可以与 $B$ 中的任意数目（零个或多个）实体相关联，而 $B$ 中的一个实体至多与 $A$ 中的一个实体相关联。</p></li><li><p>多对一：</p><p>​ $A$ 中的一个实体至多与 $B$ 中的一个实体相关联，而 $B$ 中的一个实体可以与 $A$ 中任意数目（零个或多个）实体相关联。</p></li><li><p>多对多：</p><p>​ $A$ 中的一个实体可以与 $B$ 中任意数目（零个或多个）实体相关联，而且 $B$ 中的一个实体也可以与 $A$ 中任意数目（零个或多个）实体相关联。</p></li></ul></li><li><p>映射基数（联系的基数🗡）：</p><p>​ 实体之间的联系的数量，即<strong>一个实体</strong>通过一个<strong>联系</strong>能与<strong>另一实体集相关联的实体的数目</strong>。</p></li><li><p>实体集和二元联系集之间的一条边，可以有一个关联的<strong>最大和最小的映射基数</strong>。</p><blockquote><p>例如：</p><div align="center"><img src="/img/blog/ds-note-images/image-20211004133238514.png" srcset="/img/loading.gif" lazyload></div><p>一个 instructor 可以对应 <strong>$0$ 个或多个</strong> student，但一个 student <strong>有且仅有一个</strong> instructor，注意 advisor 是从 instructor 到 student的<strong>一对多</strong>联系。</p><p>笔者注：</p><p>​ PPT 上的基数很多地方是反了，应该是自己的基数写在自己旁边（不知道祖传错误是否已被更正）</p></blockquote></li><li><p>参与约束：</p><ul><li><p>完全参与联系：</p><p>​ 如果实体集 $E$ 中的<strong>每个实体</strong>都参与到联系集 $R$ 的<strong>至少一个</strong>联系中，此时最小基数为 $1$。</p></li><li><p>部分参与联系：</p><p>​ 如果 $E$ 中只有<strong>部分实体</strong>参与到 $R$ 的联系中，此时最小基数为 $0$。</p></li></ul></li><li><p>弱实体集和强实体集：</p><ul><li>没有<strong>足够的属性以形成主码</strong>的实体集称作<strong>弱实体集</strong>（从属实体集）。</li><li>有<strong>主码</strong>的实体集称作<strong>强实体集</strong>（独立实体集）。</li></ul></li></ul><h3 id="数据库设计-1"><a href="#数据库设计-1" class="headerlink" title="数据库设计"></a>数据库设计</h3><ul><li><p>需求分析：</p><p>​ 形成数据库设计的「源」清单和「属性」清单。</p></li><li><p>概念数据库设计：</p><ul><li><p>用统一的表达方法，如 E-R 模型给出描述：</p><ul><li><p>各种实体的发现、划分和定义</p></li><li><p>各种实体属性的发现、分析和定义</p></li><li>各种实体联系的发现、分析和定义</li><li>外部视图（模式）和概念视图（模式）的定义</li></ul></li><li><p>消除冲突：</p><ul><li>属性冲突：<ul><li>属性域的冲突（属性的类型、取值范围不同）</li><li>属性取值单位冲突</li></ul></li><li>结构冲突：<ul><li>同一对象在不同应用中的抽象不同（职工在某应用中是实体，在另一应用中则抽象为属性）</li><li>同一实体在不同 E-R 图中属性组成不同</li><li>实体之间的联系在不同 E-R 图中呈现不同的类型</li></ul></li><li>命名冲突（同名异义，异名同义）</li></ul></li></ul></li><li><p>逻辑数据库设计：</p><ul><li><p>E-R 图转换为关系模式：</p><ul><li><p>复合属性转化：</p><ul><li>拆成多列单一属性。</li><li>或者作为一个新的关系，每个分量为新关系的属性。</li></ul></li><li><p>多值属性转化：</p><ul><li>将<strong>多值属性</strong>与所在实体的<strong>关键字</strong>一起组成一个新的关系。</li><li>也可以像复合属性一样拆成多列。</li></ul></li><li><p>一对一联系：</p><ul><li>若联系双方<strong>均部分参与</strong>，则将<strong>联系</strong>定义为一个<strong>新的关系</strong>，属性为参与双方的关键字（主码）属性。</li><li>若联系<strong>一方全部参与</strong>，则将<strong>另一方关键字</strong>作为<strong>全部参与方</strong>的<strong>属性</strong>（即多一个属性），不需要联系集（感觉是 PPT 说反了）。</li></ul></li><li><p>一对多联系：</p><p>​ 将<strong>单方</strong>（如教师和学生关系中的教师）参与实体的关键字，作为<strong>多方</strong>（学生）参与实体对应关系的属性。</p></li><li><p>多对多联系：</p><p>​ 将联系定义为<strong>新的关系</strong>，属性为参与<strong>双方实体的关键字</strong>。</p></li></ul></li><li><p>冗余（没懂）：</p><ul><li><p>受控冗余：</p><p>​ 有时为了效率和便利，会特意设计冗余数据。</p></li><li><p>非受控冗余：</p><p>​ 存在传递函数依赖。</p></li></ul></li></ul></li></ul><h3 id="函数依赖🗡"><a href="#函数依赖🗡" class="headerlink" title="函数依赖🗡"></a>函数依赖🗡</h3><ul><li><p>函数依赖定义：</p><ul><li><p>设 $ R$ 是属性集合 $U=\{A_1, A_2, \ldots, A_{n}\}$ 上的一个关系模式，$X, Y$ 是<strong>属性集</strong> $U$ 上的两个<strong>子集</strong>。</p></li><li><p>若对 $R$ 的任意关系 $r$，$ r$ 中<strong>不可能有两个元组</strong>满足在 $X$ 中的属性值相等而在 $Y$ 中的属性值不等，则称「$X$ 函数决定 $Y$」或「$Y$ 函数依赖于 $X$」，记作 $X \rightarrow Y$，称 $X$ 为决定因素，$Y$ 为依赖因素。</p><blockquote><p>关系模式是在属性集合上的结构化描述，关系是表状结构的。</p><p>函数依赖，顾名思义，$X$ 映射到 $Y$，同一个 $x$ 不会映射到两个 $y$。</p></blockquote></li></ul></li><li><p>函数依赖的特性：</p><ul><li><p>如果 $Y \subset X$，则有 $X\to Y$，这是平凡的函数依赖。</p></li><li><p>对 $ X \rightarrow Y$，但 $ Y \not \subset X$，则称 $X\rightarrow Y$ 为<strong>非平凡的函数依赖</strong>。</p></li><li>若 $X \rightarrow Y, Y \rightarrow X$，则记作 $X \leftrightarrow Y$。</li><li>若 $Y$ 不函数依赖于 $X$. 则记作 $X \not\rightarrow Y$。</li><li>$ X \rightarrow Y$，若是基于模式 $R$ 的，则对任意的关系 $r$ 成立；若仅基于具体关系 $r$ 的，则可能只对该关系 $r$ 成立。</li><li>如一关系 $r$ 的某属性集 $X$，$r$ 中<strong>没有 $X$ 上相等的两个元组</strong>，则 $ X \rightarrow Y$ 恒成立。</li></ul></li><li><p>完全函数依赖和部分函数依赖：</p><p>​ 在 $R$ 中，若 $X \rightarrow Y$ 并且对于 $X$ 的任何真子集 $X’$ 都有 $X’\not\rightarrow Y$，则称 $Y$ <strong>完全（full）函数依赖</strong>于 $X$，记为$X\stackrel{f}\rightarrow Y$，否则称 $Y$ <strong>部分（partial）函数依赖</strong>于 $X$，记为 $X \stackrel{p}\to Y$。</p><blockquote><p>$R$ 是属性集合 $U$ 上的一个关系模式，若 $X \subset U$ 且 $X\stackrel{f}\rightarrow U$，则称 $X$ 为 $R$ 的<strong>候选键</strong>（候选码）。</p></blockquote></li><li><p>传递函数依赖：</p><p>​ 在 $R$ 中，若 $X\to Y,Y \to Z$，其中 <strong>$Y\not\subset X,Z\not\subset Y,Z\not\subset X,Y\not\to X$</strong>（说明都是<strong>非平凡依赖</strong>），则称 $Z$ <strong>传递函数依赖</strong>于 $X$。</p><blockquote><p>传递依赖的判定很严格，仅满足 $X\to Y,Y \to Z$ 是不够的，要特别注意。</p></blockquote></li><li><p>逻辑蕴涵：</p><p>​ 设 $F$ 是关系模式 $R$ 的一个<strong>函数依赖集合</strong>，$X,Y$ 是 $R$ 的属性子集，若从 $F$ 的函数依赖能够推导出 $X \rightarrow Y$，则称 $F$ 逻辑蕴涵 $X \rightarrow Y$，记作 $F \models X \rightarrow Y$。</p></li><li><p>闭包：</p><p>​ 令 $F$ 为一个函数依赖集，$F$ 的<strong>闭包</strong>是被 $F$ <strong>逻辑蕴涵的所有函数依赖</strong>的集合, 记作 $F^{+}$。若 $F^+=F$，则 $F$ 是一个<strong>全函数依赖族（函数依赖完备集）</strong>。</p><blockquote><p>在下面的规则中去寻找逻辑蕴涵的函数依赖，通过反复应用这些规则，可以找到给定 $F$ 的全部 $F^{+}$。</p><p>用希腊字母 $(\alpha, \beta, \gamma, \cdots)$ 表示属性集，用 $\alpha \beta$ 表示 $\alpha \cup \beta_{\circ}$</p><p>这组规则称为 Armstrong 公理（据说不怎么会考）：</p><ul><li><p>自反律：</p><p>​ 若 $\alpha$ 为一属性集且 $\beta \subseteq \alpha$，则 $\alpha \rightarrow \beta$ 成立。</p></li><li><p>增补律：</p><p>​ 若 $\alpha \rightarrow \beta$ 成立且 $\gamma$ 为一属性集，则 $\gamma \alpha \rightarrow \gamma \beta$ 和 $\gamma \alpha \rightarrow \beta$ 成立。</p></li><li><p>传递律：</p><p>​ $\alpha \rightarrow \beta$ 和 $\beta \rightarrow \gamma$ 成立，则 $\alpha \rightarrow \gamma$ 成立。</p></li></ul><p>公理可导出的比较好用的引理：</p><ul><li><p><strong>合并律</strong>：</p><p>​ 若 $\alpha \rightarrow \beta$ 和 $\alpha \rightarrow \gamma$ 成立, 则 $\alpha \rightarrow \beta \gamma$ 成立。</p></li><li><p><strong>分解律</strong>：</p><p>​ 若 $\alpha \rightarrow \beta \gamma$ 成立, 则 $\alpha \rightarrow \beta$ 和 $\alpha \rightarrow \gamma$ 成立。</p></li><li><p>伪传递律：</p><p>​ 若 $\alpha \rightarrow \beta$ 和 $\gamma \beta \rightarrow \delta$ 成立, 则 $\alpha \gamma \rightarrow \delta$ 成立（由 $\alpha \rightarrow \beta$ 得到 $\gamma\alpha \rightarrow \gamma\beta$，再由传递律得到结论）。</p></li></ul></blockquote></li><li><p>属性集闭包 🗡</p><p>​ 对 $R(U, F), X \subseteq U, U=\{ A_1, A_2, \ldots, A_n\}$，令 $X^+_F=\{ A_i\quad \mid \quad用 \quad \text{Armstrong} \quad 公理可从 \quad F \quad 导出\quad X \rightarrow A_i\} $，称 $ X^+_F$ 为 $X$ 于 $F$ 的<strong>属性集闭包</strong>。<br>显然 $X \subseteq X^+_F$。</p><blockquote><p>引理：</p><p>​ $ X \rightarrow Y$, 当且仅当 $ Y \subseteq X^+_F$。</p></blockquote></li><li><p>求 $X$ 的属性集闭包的算法🗡：</p><ol><li><p>令 $X_0=X$</p></li><li><p>$B=\{A\mid(\exists V)(\exists W)(V\to W)\in F \quad \mathbf{and}\quad V\subseteq X_i\quad \mathbf{and} \quad A\subseteq W\}$（对 $F$ 中的任意元素 $V\to W$ 检查，如果 $V$ 已在 $X_i$ 中，则把 $W$ 的属性加入到 $X_{i+1}$ 中）</p></li><li><p>$X_{i+1}=B\cup X_i$</p></li><li><p>$\mathbf{if~} X_{i+1}\ne X_i \mathbf{~then}$:</p><p>​ $i=i+1$</p><p>​ $\bf goto~ 2$（如果这轮检查仍有新的元素加入，则下一次迭代也可能有未被检查过的元素加入，否则算法结束）</p></li><li><p>$X^+_F=X_i$</p></li></ol></li><li><p>覆盖：</p><p>​ 对 $R(U)$ 上的两个函数依赖集合 $F,G$，如果 $F^+= G^+$，则称 $F$ 和 $G$ 是<strong>等价</strong>的，也称 $F$ <strong>覆盖</strong> $G$ 或者 $G$ 覆盖 $F$。</p></li><li><p>最小覆盖：</p><p>​ 若 $F$ 满足以下条件，则称 $F$ 为<strong>最小覆盖（最小依赖集，最小等价依赖集）</strong>：</p><ul><li>$F$ 中<strong>每个函数依赖的右部是单个属性</strong>。</li><li>对任何 $\{X\to A\}\in F$，有 $F- \{ X\to A \}$ 不等价于 $F$。</li><li>对任何 $\{X\to A\} \in F$，$Z\subset X$，$(F- \{ X\to A \})\cup\{Z\to A\}$ 不等价于 $F$。</li></ul></li><li><p>求最小覆盖的算法：</p><ol><li><p>通过分解律「若 $\alpha \rightarrow \beta \gamma$ 成立, 则 $\alpha \rightarrow \beta$ 和 $\alpha \rightarrow \gamma$ 成立」，将原函数依赖集抄一遍，右部分解为单属性。</p></li><li><p>对任意 $X\to Y$，求 $X$ 对于 $F$ 剩余部分的属性闭包，若不包含 $Y$，则 $X\to Y$ 是必需的，否则删除。</p><blockquote><p>Tips：</p><p>​ 对于<strong>仅在右部中出现一次的属性</strong>的那个依赖一定不会在这一步被删除，因为不可能有其他依赖能推出它了。</p></blockquote></li><li><p>对于任意 $XY\to Z$，考虑能否替换为 $X\to Z$。求 $X$ 在替换前依赖集的属性闭包，如果不包含 $Z$，则替换是不可行的。如果也不能替换成 $Y\to Z$，则$XY\to Z$ 是必需的。</p><blockquote><p>若 $X$ 在替换前依赖集的属性闭包包含 $Z$，说明本来就有依赖 $X\to Z$，又因为 $XY\to X$，所以又可以推出 $XY\to Z$，即 $XY\to Z$ 是多余的，可以用 $X\to Z$ 替换。</p></blockquote></li></ol></li></ul><h3 id="关系模式范式🗡"><a href="#关系模式范式🗡" class="headerlink" title="关系模式范式🗡"></a>关系模式范式🗡</h3><ul><li><p>第一范式：</p><p>​ 如果关系模式 $R$ 所有属性的域都是原子，则称 $R$ 属于第一范式（$1NF$）, 记作 $R \in 1NF$。</p><blockquote><p>$1NF $ 要求关系中不能有复合属性、多值属性及其组合。</p><p>多值属性解决方案：</p><div align="center"><img src="/img/blog/ds-note-images/1.png" srcset="/img/loading.gif" lazyload></div><ul><li>拆成两个表，原表去掉多值列，然后把多值属性和主码作为一个新的表。</li><li>拆成多行</li><li>拆成多列</li></ul></blockquote></li><li><p>第二范式：</p><p>​ 若 $R(U)\in 1NF$ 且 $U$ 中的每一<strong>非主属性完全函数依赖</strong>于<strong>候选键</strong>，则称 $R(U)$ 属于第二范式，记为：$R(U)\in 2NF$。</p><blockquote><p>第二范式消除非主属性对候选键的<strong>部分依赖</strong>。</p><p>将候选键拆成多个表，每个表的<strong>非主属性</strong>完全函数依赖于候选键。</p><p>第二范式只有历史意义，已经不在实际中使用了。</p></blockquote></li><li><p>第三范式：</p><p>​ 若 $R(U,F)\in 2NF$, 在 $R$ 中若不存在<strong>候选键</strong> $X$，<strong>属性集</strong> $Y$（不可以是候选键），和<strong>非主属性</strong> $Z$，使得 $X\to Y,Y \to Z$ 成立，其中 $Y\not\subset X,Z\not\subset Y,Z\not\subset X,Y\not\to X$，则称 $R$ 属于第三范式，记为：$R\in 3NF$。</p><blockquote><p>第 $3$ 范式消除了<strong>非主属性对侯选键的传递依赖</strong>。</p><p>如满足第 $3$ 范式，则一定能满足第 $2$ 范式。</p></blockquote></li><li><p>Boyce-Codd 范式：</p><p>​ 若 $R(U,F)\in 1NF$, 若对于任何 $X\to Y\in F$（或 $X\to A\in F$），当 $Y\not\subset X$（或 $A\in X$）时，$X$ 必含有<strong>候选键</strong>（即超码），则称 $R(U)$ 属于 Boyce-Codd 范式，记为：$R(U)\in BCNF$。</p><blockquote><p>如满足 Boyce-Codd 范式，则一定能满足第 $3$ 范式。</p></blockquote></li><li><p>多值依赖：</p><p>​ 对 $R(U)$，设 $X,Y\subset U$，若对于 $R(U)$ 的任一关系 $r$，若元组 $t\in r, s\in r,t[ X]= s[ X]$，则必有 $ u \in r, u \in r$ 使得：</p><ul><li><p>$u[X]=v[X]=t[X]=s[X]$</p></li><li><p>$ u[ Y]= t[ Y]$ 且 $u[ U- X- Y]= s[ U- X- Y]$</p></li><li><p>$ u[ Y]= s[ Y]$ 且 $v[U- X- Y]= t[ U- X- Y]$</p><p>| $X$ | $Y$ | $U-X-Y$ |<br>| :—: | :—-: | :——-: |<br>| $x$ | $y_1$ | $z_1$ |<br>| $x$ | $y_2$ | $z_2$ |<br>| $x$ | $y_2$ | $z_1$ |<br>| $x$ | $y_1$ | $z_2$ |</p></li></ul><p>均成立，则称 $Y$ <strong>多值依赖于</strong> $X$，或说 $X$ <strong>多值决定</strong> $ Y$，记作 $ X \rightarrow \rightarrow Y$，同时 $X \to\to U-X-Y$。</p><blockquote><p>若 $U=X\cup Y$，则一定有 $X\to\to Y$。</p><p>直观地，若 $ X \rightarrow \rightarrow Y$，对于 $X$ 给定值，$Y$ 有一组值与之对应（$0$ 或 $n$ 个）且这组 $Y$ 值不以任何方式与 $U-X-Y$ 中属性值相联系。</p></blockquote></li><li><p>第四范式（基于多值依赖的 BCNF 范式，不考）：</p><p>​ 函数依赖和多值依赖集为 $F$ 的关系模式 $R(U)$ 属于第四范式 $(4 {NF})$ 的条件是，对 $F^{+}$中所有形如 $\alpha \rightarrow \beta$ 的多值依赖（其中 $\alpha \subseteq U$ 且 $\beta \subseteq U$），至少有以下之一成立：</p><ul><li>$\alpha \rightarrow \beta$ 是一个平凡的多值依赖。</li><li>$\alpha$ 是 $R$ 的一个超码。</li></ul></li></ul><h3 id="模式分解"><a href="#模式分解" class="headerlink" title="模式分解"></a>模式分解</h3><ul><li><p>模式分解定义：</p><p>​ 关系模式 $R(U)$ 的分解是指用 $R$ 的一组子集 $\rho=\{R_1, \ldots, R_k\}$ 来代替它。其中 $ U= U_1 \cup U_2 \cup \ldots \cup U_k,U_i \notin U_j( i \neq j)$。对于关系模式 $R$ 的任一关系 $r$，它向 $\rho$ 的投影连接记为 $ m_\rho(R)$ :</p><script type="math/tex;mode=display">m_\rho(R)=\pi_{R_1} (R) \bowtie \ldots \bowtie \pi_{R_k} (R)=\bowtie_{(i=1, \ldots,  k)} \pi_{R_i}(R)</script><p>这里 : $\pi_{R_i}(R)=\{ t[R_i] \mid t \in r, i=1, \ldots, k\}$。</p><blockquote><p>若对关系模式 $R$ 的任一关系 $r$ 都有 $r = m_\rho(R)$ 成立，则称 $\rho$ 是 $R$ 相对于 $F$ 的一个<strong>无损连接分解</strong>。</p></blockquote></li><li><p>无损连接分解检验算法：</p><ul><li><p>构造一 $k$ 行 $n$ 列的表（$k$ 是分解的集合数，$n$ 是 $R(U)$ 属性数），可称为 $R_\rho$ 表。</p></li><li><p>其中第 $j$ 列对应于 $ A_j$，第 $i$ 行对应于 $ R_i$。</p></li><li><p>若 $ A_j\in R_i$，则 $R_\rho$ 表中第 $i$ 行第 $j$ 列位置填写符号 $ a_j$，否则填写 $ b_{ij}$。</p></li><li><p>根据 $\forall(X \rightarrow Y) \in F$，对 $R_\rho$ 表进行修改：</p><p>给定 $ X \rightarrow Y$，寻找 <strong>与 $X$ 属性取值相同</strong>的行，用其值重置 $Y$ 属性值。</p></li><li><p>修改后，如果有一行变成 $ a_1, a_2, \ldots, a_n$，则 $\rho$ 是无损连接分解，否则为有损连接分解。</p></li></ul><blockquote><p>笔者认为这个算法应该循环，直到不能再修改为止，但是老师说原论文也没有提到做多几次的事情，只需要做一遍就行，遂躺平做一遍就好。</p><p>对于分解成两个子集的情况，可以快速判断的方法：</p><ul><li><p>设 $F$ 是关系模式 $R$ 上的一个函数依赖集合，$\rho=\{ R_1, R_2\}$ 是 $R$ 的一个分解。</p></li><li><p>则当且仅当 $R_1 \cap R_2 \rightarrow R_1- R_2$ 或者 $ R_1 \cap R_2 \rightarrow R_2- R_1$ 属于 $F^+$ 时，$\rho$ 是关于$F$ 无损连接的。</p></li><li><p>因为 $R_1=(R_1\cap R_2) \cup(R_1-R_2),R_2=(R_1\cap R_2) \cup(R_2-R_1)$，所以有</p><p>| | $R_1\cap R_2$ | $R_1- R_2$ | $R_2- R_1$ |<br>| :—-: | :—————-: | :————: | :————: |<br>| $R_1$ | $a_1$ | $a_2$ | $b_{13}$ |<br>| $R_2$ | $a_1$ | $b_{22}$ | $a_3$ |</p></li><li><p>此时只要 $ R_1 \cap R_2 \rightarrow R_1- R_2$ 或者 $ R_1 \cap R_2 \rightarrow R_2- R_1$ 属于 $F^+$ 的一个成立，就能实现有一行变成 $ a_1, a_2,a_3$。</p></li></ul></blockquote></li><li><p>保持依赖分解的分解🗡：</p><ul><li>对于关系模式 $R( U, F)$，$U$ 是属性全集，$F$ 是函数依赖集合，$\rho=\{ R_1, \ldots, R_k\}$ 是 $R$ 的一个分解。</li><li>如在 $\pi_{R_i}( F)$ 中的所有依赖之并集 $( i=1, \ldots, k)$，<strong>逻辑蕴涵 $F$ 的每个依赖</strong>，则称分解 $\rho$ 保持依赖集 $F$。</li><li>其中 $\pi_{R_i}( F)$ 是 $F$ 在 $ R_i$ 上的投影，即 $F$ 中的任一投影 $ X \rightarrow Y$，如果 $X,Y\in R_i$，则 $ X \rightarrow Y \in \pi_{R_i}( F)$。</li></ul></li><li><p>保持依赖分解检测算法：</p><blockquote><p>对 $F$ 中的每一个 $\alpha \rightarrow \beta$，<br><br>$\quad \quad result \leftarrow \alpha$<br><br>$\bf while$<br><br>$\quad \quad\bf foreach$ 分解后包含有 $\alpha$ 的 $R_i:$<br><br>$\quad \quad \quad \quad t\leftarrow ( result \cap R_i)^{+} \cap R_i$<br><br>$\quad \quad \quad \quad result\leftarrow result \cup t$<br><br>$\mathbf{until}$ $(result$ 没有变化 $)$</p><p>如果 $result$ 含 $\beta$ 中的所有属性，则函数依赖 $\alpha\to \beta$ 保持。</p></blockquote></li><li><p>BCNF 分解 + 无损连接分解：</p><blockquote><p>BCNF 范式要求每个函数依赖的左侧都要是关系模式的<strong>超码</strong>（含有候选键）。</p></blockquote><ul><li><p>仅 BCNF 分解：</p><p>​ 将左侧<strong>不含候选键</strong>的函数依赖<strong>单独组成一个关系</strong>，将包含候选键的组成一关系。</p></li><li><p>无损连接分解成 BCNF：</p><blockquote><p>计算 $F^{+}$<br><br>$\mathbf{while} \quad result \not\in BCNF \quad \mathbf{do}$:<br><br>$\quad \quad\mathbf{if}\quad result$ 中存在模式 $R_i$ 不属于 $BCNF\quad \mathbf{then}$：<br><br>$\quad \quad \quad \quad$ 对于 $R_i$ 上所有非平凡函数依赖 $\alpha \rightarrow \beta$ （满足 $\alpha \rightarrow R_i$ 不属于 $F^{+}$，即 $\alpha$ 不是 $R_i$ 的超码）<br><br>$\quad \quad \quad \quad \quad \quad result=(result-R_i) \cup(R_i-\beta ) \cup (\alpha, \beta)$</p><p>// 即用两个模式 $(R_i-\beta) \cup(\alpha, \beta)$ 取代原来的 $R_i$，由之前的快速判断的方法可知分解无损</p></blockquote></li></ul></li><li><p>$3NF$ 分解 + 保持依赖分解（+ 无损连接分解）：</p><ul><li><p>仅 $3NF$ 分解：</p><p>​ 将每一个函数依赖单独组成一个关系。</p></li><li><p>保持依赖分解成 $3NF$：</p><ul><li><p>关系模式 $R(U, F)$，$F$ 是函数依赖集<strong>最小覆盖</strong>，求保持依赖的 $3NF$ 分解 $\rho$。</p></li><li><p>若有 $ X \rightarrow A_1, X \rightarrow A_2, \ldots, X \rightarrow A_{ m}\in F$，则以 $XA_1 A_2 \ldots A_m$ 组成一模式 $R_i$，$\rho=\rho\cup R_i$</p><blockquote><p>这样保证 $R_i$ 是 $3NF$ 分解：</p><p>​ 因为 $F$ 是最小覆盖，要求对任何 $\{X\to A\}\in F$，有 $F- \{ X\to A \}$ 不等价于 $F$。</p><p>所以一定不会存在 $A_i\to A_j\in F(i\not=j)$ 的情况，否则 $F-\{X\to A_j\}$ 仍等价于 $F$。</p></blockquote></li><li><p>上一步处理完后，把 $R$ 中<strong>不出现在 $F$ 中的属性</strong>去掉并单独组成一模式 $R_{no}$，令 $\rho=\rho\cup R_{no}$。</p><blockquote><p>若要达到无损连接分解：</p><ul><li><p>如果 $R_{no}$ 存在，将在 $R_{no}$ 加入候选键属性，则能使该分解达到无损。</p></li><li><p>如果不存在，则判断所得 $\rho$ 集合中的是否存在一个 $R_i$ 包含了候选键属性集：</p><ul><li><p>存在，算法结束。</p></li><li><p>不存在，$\rho=\rho~\cup$ 候选键属性集。</p></li></ul></li></ul></blockquote></li></ul></li></ul></li></ul><h2 id="数据存储和查询"><a href="#数据存储和查询" class="headerlink" title="数据存储和查询"></a>数据存储和查询</h2><h3 id="存储和文件结构"><a href="#存储和文件结构" class="headerlink" title="存储和文件结构"></a>存储和文件结构</h3><ul><li><p>存储体系：</p><ul><li>将不同性价比的存储器组织在一起，满足高速度、大容量、低价格需求。</li><li>CPU 与内存直接交换信息，按存储单元（存储字）进行访问。</li><li>外存按<strong>存储块</strong>进行访问，其信息需先装入<strong>内存</strong>，才能被 CPU 处理。</li></ul></li><li><p>操作系统对数据的组织：</p><ul><li><p>FAT（文件分配表 - File Allocation Table）- 目录（文件夹）- 磁盘块/簇</p><p><img src="/img/blog/ds-note-images/image-20211012225110095.png" srcset="/img/loading.gif" lazyload style="zoom:67%"></p></li><li><p>对于一个文件，用 FAT 找到它在磁盘中的位置。</p></li></ul></li><li><p>内存管理：</p><p>​ 一条记录的地址 = 存储单元的地址 = 内存地址 = 页面 ：页内偏移量</p></li><li><p>磁盘结构：</p><p><img src="/img/blog/ds-note-images/image-20211012161544352.png" srcset="/img/loading.gif" lazyload style="zoom:67%"></p><ul><li><strong>盘片</strong>的表面从逻辑上划分为<strong>磁道</strong>（同心圆），磁道又划分为<strong>扇区</strong>。</li><li>扇区是从磁盘读出和写入信息的<strong>最小单位</strong>，系统数据传输的基本单位是磁盘块（几个连续的扇区）。</li><li>一个磁盘的基本信息（假设）：<ul><li>$8$ 个圆盘，$16$ 个盘面</li><li>每个盘面有 $2^{16}$ 或 $65536$ 个磁道</li><li>每个磁道（平均）有 $2^8=256$ 个扇区</li><li>每个扇区有 $2^{12}=4096$ 个字节</li><li>磁盘的容量为 $2^4\times 2^{16} \times 2^8 \times 2^{ 12} = 2^{ 40}$ 字节</li></ul></li></ul></li><li><p>磁盘数据读写时间🗡：</p><ul><li><p>包括寻道时间（约在 $1-20ms$），旋转时间（约 $0-10ms$）和传输时间。</p></li><li><p>磁盘以 $7200$ 转/$min$ 旋转，即 $8.33ms$ 内旋转一周</p></li><li><p>柱面之间移动磁头组合从启动到停止花费 $1 ms$。</p></li><li><p>每移动 $4000$ 个柱面另加 $1ms$，即磁头在 $0.00025 ms$ 内移动一个磁道，从最内圈移动到最外圈，移动 $65536$ 个磁道大约用 $0.00025\times 65536 + 1=17.38ms$。</p></li><li><p>一个磁道中扇区间的空隙大约占 $10 \%$ 的空间</p></li><li><p>一个磁盘块 $=4$ 个扇区 $=16384$ 个字节</p></li><li><p>最短时间 $=$ 传输时间大约是 $0.13ms$</p></li><li><p>最长时间 $=$ 寻道时间+旋转时间+传输时间 $=17.38+8.33+0.13=25.84 m s$</p></li><li><p>平均时间 $=6.46(16.38/3+1)+4.17(8.33/2)+0.13=10.76 ms$ （括号表示这个数是怎么得到的）</p><blockquote><p>概率论忘掉了，这里可能有算错的地方（这是不会考的，不重要）<span>🤐</span></p><p>平均寻道时间要除以 $3$ 是求了一个盘片内径向任意两点之间移动时间的期望（前提假定为平均分布）。</p><p>设盘片半径为 $r$。令 $f(y)=|x-y|$，即表示径向从 $y$ 点到 $x$ 点之间距离。</p><p>当 $x$ 为 $[0,r]$ 上的固定值时，求出 $[0,r]$ 上所有点到 $x$ 的期望距离：</p><script type="math/tex;mode=display">\mathbb{E}f(y)=\int^r_0 |x-y|\frac{1}{r}dy=\frac{x^2}{r}-x+\frac{r}{2}</script><p>对于所有 $x\in[0,r]$，计算期望距离的期望：</p><script type="math/tex;mode=display">\mathbb{E}\mathbb{E}f(y)=\int^r_0 \frac{1}{r}(\frac{x^2}{r}-x+\frac{r}{2})dx=\frac{r}{3}</script><p>即磁头平均会移动 $\begin{aligned}\frac{r}{3}\end{aligned}$。</p></blockquote></li><li><p>物理存取算法考虑的关键：</p><ul><li>降低 I/O 次数。</li><li>降低排队等待时间。</li><li>降低<strong>寻道/旋转</strong>延迟时间：<ul><li>同一<strong>磁道</strong>连续块存储</li><li><strong>同一柱面</strong>不同磁道<strong>并行</strong>块存储</li><li>多个<strong>磁盘</strong>并行块存储</li></ul></li></ul></li></ul></li><li><p>独立磁盘冗余阵列（Redundant Array of Independent Disk，RAID 技术）（理解）：</p><ul><li><p>块级拆分：</p><p>​ 一个文件由多个块组成，不同<strong>块</strong>存储于不同磁盘。</p></li><li><p>比特级拆分：</p><p>​ 一个字节被拆分成 $8$ 个比特位, 不同<strong>比特位</strong>存储于不同磁盘。</p></li><li><p>RAID $0$ 级：</p><p>​ 块级拆分但<strong>没有任何冗余</strong>（例如镜像或奇偶校验位）的磁盘阵列。</p></li><li><p>RAID $1$ 级：</p><p>​ 使用块级拆分的磁盘<strong>镜像</strong>，每一个磁盘有一个镜像磁盘。</p></li><li><p>RAID $2$ 级：</p><p>​ <strong>位交叉</strong>纠错处理，$4$ 个磁盘存储 $4$ 位 $+~3$ 个校验盘存储 $3$ 校验位（汉明码）。</p></li><li><p>RAID $3$ 级：</p><p>​ RAID $2$ 级的改进，只用一个校验盘，比 RAID $2$ 级常用。</p></li><li><p>RAID $4$ 级：</p><p>​ <strong>块交叉</strong>的奇偶校验组织结构。它像 RAID $0$ 级一样使用块级拆分，此外在一张<strong>独立的磁盘</strong>上为其他 $N$ 张磁盘上对应的块保留一个<strong>奇偶校验块</strong>。</p></li><li><p>RAID $5$ 级：</p><p>​ 块交叉的<strong>分布奇偶校验位</strong>的组织结构，是 RAID $4$ 级的改进，将数据和奇偶校验位都分布到所有的 $N + 1$ 张磁盘中。</p><p><img src="/img/blog/ds-note-images/image-20211013151334886.png" srcset="/img/loading.gif" lazyload style="zoom:67%"></p></li></ul></li><li><p>数据存储的映射：</p><p><img src="/img/blog/ds-note-images/image-20211013152301903.png" srcset="/img/loading.gif" lazyload style="zoom:80%"></p></li><li><p>数据库记录在磁盘上的存储：</p><ul><li><p>定长记录（根据偏移量区分记录）：</p><p>​ 所有字段固定位数（黑色是空着的）。</p><div align="center"><img src="/img/blog/ds-note-images/image-20211013185732990.png" srcset="/img/loading.gif" lazyload></div></li><li><p>变长记录（靠分隔符区分开始与结束）：</p><div align="center"><img src="/img/blog/ds-note-images/1.png" srcset="/img/loading.gif" lazyload></div><ul><li><p>块头包括：</p><ul><li>块头中记录条目的个数。</li><li>块中<strong>空闲空间</strong>的末尾处。</li><li>一个由包含记录<strong>位置和大小</strong>的记录条目组成的数组。</li></ul></li><li><p>实际记录从块的<strong>尾部</strong>开始连续排列。</p></li><li><p>块中<strong>空闲空间是连续</strong>的，无论是插入操作还是删除操作都不能改变这一点。</p></li><li><p>如果插入一条记录，在<strong>空闲空间的尾部</strong>给这条记录分配空间，并且将包含这条记录大小和位置的条目添加到块头中。</p></li><li><p>如果一条记录被删除：</p><ul><li>它所占用的空间被释放，并且它的条目被设置成被<strong>删除状态</strong>。</li><li>块中在被删除记录之后的记录将被移动，使得由删除而产生的空闲空间被重用，并且所有空闲空间仍然保持<strong>连续</strong>。</li><li>块头中的空闲空间末尾指针要做适当修改。</li></ul><blockquote><p>移动记录的代价并不高，因为块的大小是有限制的，典型的值为 $4-8$KB。</p></blockquote></li></ul></li></ul></li></ul><ul><li><p>数据库 - 表所占磁盘块的分配方法：</p><ul><li><p>连续分配:</p><p>​ 数据块被分配到连续的磁盘块上（会存在<strong>扩展困难</strong>问题）。</p></li><li><p>链接分配:</p><p>​ 数据块中包含指向下一数据块的指针（<strong>访问速度</strong>问题），不连续，有空位就放。</p></li><li><p>按簇分配:</p><p>​ 按簇分配，簇内连续分配，簇之间靠指针连接，簇有时也称<strong>片段</strong>，结合前面两者优点。</p></li><li><p>索引分配:</p><p>​ 索引块中存放指向实际<strong>数据块的指针</strong>（可以不用 FAT）。</p><p><img src="/img/blog/ds-note-images/image-20211013191826059.png" srcset="/img/loading.gif" lazyload style="zoom:80%"></p></li></ul></li><li><p><strong>文件组织方法</strong>🗡：</p><blockquote><p>考试重点，注意区分🧐，回答合理即可。</p></blockquote><ul><li><p>无序文件组织：</p><ul><li><p>无序记录文件（堆文件 heap 或 pile file）</p></li><li><p>记录可存储于任意有空间的位置，磁盘上存储的记录是无序的。<strong>更新效率高</strong>，但<strong>检索效率可能低</strong>。</p></li><li><p>一开始新记录总插入到文件尾部。删除记录时，可以直接删除该记录所在位置的内容，也可以在该记录前标记「<strong>删除标记</strong>」，新增记录可以利用那些标记为「删除标记」的记录空间</p></li><li><p>频繁删增记录时会造成空间浪费，所以需要周期性<strong>重新组织数据库</strong>。</p><blockquote><p>数据库重组是通过移走被删除的记录使<strong>有效记录连续存放</strong>，从而回收那些由删除记录而产生的未利用空间（外部碎片）。</p></blockquote></li></ul></li><li><p>有序文件组织</p><ul><li><p>有序记录文件（排序文件 Sequential）</p></li><li><p>记录按某属性或属性组值的顺序插入，磁盘上存储的记录是有序的。<strong>检索效率可能高</strong>，但更新效率低。</p><blockquote><p>当按排序字段进行检索时，速度得到很大提高。但当按非排序字段检索时，速度可能不会提高很多。</p></blockquote></li><li><p>用于存储排序的属性通常称为<strong>排序字段</strong>，可以是关系中的<strong>主码</strong>，所以又称<strong>排序码</strong>。</p></li><li><p>改进办法（使用溢出）：</p><ul><li><p>为将来可能插入元组预留空间（这可能造成空间浪费），或使用一个<strong>临时的无序文件</strong>（被称为<strong>溢出文件</strong>）保留新增的记录。</p></li><li><p>当采取溢出文件措施时，检索操作既要操作主文件，又要<strong>操作溢出文件</strong>。</p></li><li><p>需要周期性<strong>重新组织数据库</strong>，将溢出文件<strong>合并</strong>到主文件，并恢复主文件中的记录顺序。</p></li></ul></li></ul></li><li><p>散列文件组织：</p><ul><li>散列文件（Hash file）</li><li>可以把记录按某属性或属性组的值，依据一个<strong>散列函数</strong>来计算其应存放的<strong>位置（桶号）</strong>，检索效率和更新效率都有一定程度的提高。</li><li>用于进行散列函数计算的属性通常称为<strong>散列字段</strong>，散列字段通常也采用关系中的<strong>主码</strong>，所以又称<strong>散列码</strong>。</li><li>不同记录可能被 hash 成同一桶号，此时需在桶内顺序检索出某一记录。</li><li>答题万金油，读写性能都不错。</li></ul></li><li><p>聚簇文件组织：</p><ul><li><p>聚簇文件（Clustering file）</p></li><li><p><strong>聚簇</strong>：</p><p>​ 将具有<strong>相同或相似属性值</strong>的记录存放于<strong>连续</strong>的磁盘簇块中，优化连接代价，在<strong>不用索引</strong>的时候使用。</p></li><li><p>多表聚簇：</p><p>​ 将若干个<strong>相互关联</strong>的表存储于一个文件中，可提高多表情况下的查询速度。</p></li><li><p>何时使用多表聚簇依赖于数据库设计者所认为的<strong>最频繁的查询类型</strong>。</p></li></ul></li></ul></li></ul><h3 id="索引概念和分类🗡"><a href="#索引概念和分类🗡" class="headerlink" title="索引概念和分类🗡"></a>索引概念和分类🗡</h3><ul><li><p>索引定义：</p><ul><li><p>定义在存储表基础上，无需检查所有记录，快速定位所需记录的一种辅助存储结构，由<strong>一系列</strong>存储在<strong>磁盘</strong>上的<strong>索引项</strong>组成，每一索引项又由两部分构成:</p><ul><li><p><strong>索引字段</strong>：</p><p>​ 由表中<strong>某些列</strong>中的值串接而成，类似于词典中的词条。索引中<strong>通常</strong>存储了索引字段的每一个值。</p></li><li><p>行指针：</p><p>​ 指向表中包含索引字段值的记录在磁盘上的<strong>存储位置</strong>，类似于词条在书籍、词典中出现的页码。</p></li></ul></li><li><p>有索引时，更新操作必须<strong>同步更新</strong>索引文件和主文件。</p></li><li><p>对经常出现在<strong>检索条件、连接条件和分组</strong>计算条件中的属性可建立索引。</p></li></ul><blockquote><p>存储<strong>索引项</strong>的文件为<strong>索引文件</strong>，存储表称为<strong>主文件</strong>。</p></blockquote></li><li><p>索引文件组织方式有两种🗡：</p><ul><li><p><strong>排序索引文件</strong>：</p><p>​ 按<strong>索引字段值</strong>的某一种<strong>顺序</strong>组织存储。</p></li><li><p><strong>散列索引文件</strong>：</p><p>​ 依据<strong>索引字段值</strong>使用<strong>散列函数</strong>分配散列桶的方式存储。</p></li></ul><blockquote><p><strong>主文件组织</strong>有堆文件、排序文件、散列文件、 聚簇文件等多种方式，和<strong>索引文件组织方式</strong>区分。</p></blockquote></li><li><p>索引应用的评价：</p><ul><li><p>访问时间：</p><p>​ 在查询中使用该技术找到一个特定数据项或数据项集所需的时间</p></li><li><p>插入时间：</p><p>​ 插入一个新数据项所需的时间。该值包括<strong>找到</strong>插入这个新数据项的正确位置所需的时间，以及<strong>更新</strong>索引结构所需的时间。</p></li><li><p>删除时间：</p><p>​ 删除一个数据项所需的时间。该值包括找到待删除项所需的时间，以及更新索引结构所需的时间。</p></li><li><p>空间开销：</p><p>​ 索引结构所占用的额外存储空间。倘若存储索引结构的额外空间大小适度，通常牺牲一定的空间代价来换取性能的提高是值得的。</p></li></ul></li><li><p>码的区分（😢不太能区分）：</p><ul><li><p>排序码：</p><p>​ 对主文件进行排序存储的那些属性或属性组。</p></li><li><p>索引码：</p><p>​ 即索引字段，<strong>不一定具有唯一性</strong>。</p></li><li><p>搜索码：</p><p>​ 在文件中查找记录的属性或属性集称为<strong>搜索码</strong>。</p></li></ul></li><li><p>稠密索引：</p><ul><li><p>主文件中每一个<strong>搜索码值</strong>（索引字段值）都有一个索引项和它对应。</p></li><li><p>对<strong>候选键</strong>建稠密索引：</p><p>​ 主文件不用排序，直接可以定位。</p></li><li><p><strong>非候选键</strong>建稠密索引：</p><ul><li><p><strong>索引文件</strong>中索引字段值是<strong>不重复的</strong>，<strong>主文件</strong>按索引字段<strong>排序</strong>。</p><p><img src="/img/blog/ds-note-images/image-20211119134744510.png" srcset="/img/loading.gif" lazyload style="zoom:60%"></p></li><li><p><strong>索引文件</strong>中索引字段值是有<strong>重复</strong>的，主文件<strong>不排序</strong>。</p><div align="center"><img src="/img/blog/ds-note-images/6fda6106a92bb6123bb84b5bf951d39e.jpg" srcset="/img/loading.gif" lazyload></div></li><li><p>引入<strong>指针桶</strong>处理非候选键索引的多记录情况，<strong>索引文件</strong>中索引字段值是<strong>不重复的</strong>，主文件<strong>不排序</strong>。</p><p><img src="/img/blog/ds-note-images/eec1c49cea791f862e00000e00158704.jpg" srcset="/img/loading.gif" lazyload style="zoom:100%"></p><blockquote><p>索引文件通常要排序。</p></blockquote></li></ul></li></ul></li></ul><ul><li><p>稀疏索引：</p><p>​ 稀疏索引只为主文件<strong>部分搜索码值</strong>（索引字段值）建立索引记录，<strong>主文件</strong>按索引字段<strong>排序</strong>。</p></li><li><p>主索引：</p><ul><li>如果包含记录的文件按照某个<strong>搜索码</strong>指定的顺序<strong>排序</strong>，那么该搜索码对应的索引称为<strong>聚集索引</strong>，也称为<strong>主索引</strong>。</li><li>主索引对每一<strong>存储块</strong>有一个<strong>索引项</strong>，索引项的总数和<strong>存储表所占的存储块数目</strong>相同。</li><li>存储表的每一存储块的第一条记录，又称为<strong>锚记录</strong>，或简称为块锚。</li><li>主索引的索引字段值为块锚的索引字段值（通常为<strong>主码值或排序码值</strong>），而指针指向其所在的存储块。</li><li>主索引（可以）是<strong>稀疏索引</strong>。</li></ul></li><li><p>辅助索引：</p><ul><li>辅助索引定义在<strong>主文件</strong>的任一或多个<strong>非排序字段</strong>上的辅助存储结构。</li><li>辅助索引一定是稠密索引。</li></ul><blockquote><p>主索引和辅助索引的区别：</p><ul><li>一个主文件仅可以有一个<strong>主索引</strong>（只按主索引的搜索码排序），但可以有多个辅助索引。</li><li>主索引通常建立于主码/排序码上面，辅助索引建立于其他属性上面。</li><li>可以利用主索引重新组织主文件数据，辅助索引不能改变主文件数据。</li><li>主索引是稀疏索引，辅助索引是稠密索引</li></ul></blockquote></li><li><p>聚簇索引：</p><ul><li><p>聚簇<strong>索引</strong>定义：</p><p>​ 聚簇索引是指<strong>索引中邻近</strong>的记录在<strong>主文件</strong>中也是临近存储的。</p></li><li><p>聚簇<strong>字段</strong>定义：</p><p>​ 如果主文件的某一<strong>排序</strong>字段<strong>不是主码</strong>，则该字段上每个记录取值便不唯一，此时该字段被称为<strong>聚簇字段</strong>。聚簇索引通常是定义在聚簇字段上。</p><p><img src="/img/blog/ds-note-images/image-20211119141551035.png" srcset="/img/loading.gif" lazyload style="zoom:80%"></p></li></ul></li><li><p>非聚簇索引：</p><p>​ 指索引中邻近的记录在主文件中不一定是邻近存储的。</p><blockquote><p>聚簇索引和非聚簇索引的区别：</p><ul><li>一个主文件只能有一个聚簇索引文件，但可以有多个非聚簇索引文件。</li><li>主索引通常是聚簇索引（但其<strong>索引项</strong>总数<strong>不一定</strong>和主文件中<strong>聚簇字段</strong>上不同值的数目相同，其和<strong>主文件存储块数目</strong>相同）。</li><li>辅助索引通常是非聚簇索引。</li><li>主索引/聚簇索引是能够<strong>决定记录存储位置</strong>的索引，而辅助索引/非聚簇索引则只能用于<strong>查询</strong>，指出已存储记录的位置。</li></ul></blockquote></li></ul><h3 id="多级索引（B-树）🗡"><a href="#多级索引（B-树）🗡" class="headerlink" title="多级索引（B+ 树）🗡"></a>多级索引（B+ 树）🗡</h3><blockquote><p>必考内容<span>🌲</span></p><p>当索引项比较多时，可以对索引再建立索引，依此类推，形成多级索引。</p></blockquote><ul><li><p>B+ 树节点：</p><div align="center"><img src="/img/blog/ds-note-images/image-20211014210434101.png" srcset="/img/loading.gif" lazyload></div><ul><li><p>$K_i$：</p><p>​ 索引字段值</p></li><li><p>$P_i$​：</p><ul><li>是指向 <strong>索引块</strong>或<strong>数据块</strong>或数据块中记录 的指针：<ul><li>非叶结点指针指向<strong>索引块</strong>。</li><li>叶结点指针指向主文件的数据块（稀疏索引）或数据记录（稠密索引）。</li></ul></li><li>每个索引块的<strong>指针利用率</strong>（书上是说索引字段值的利用率🥲）都在 <strong>$50\%-100\%$</strong> 之间（根节点可以不满足）。</li><li>索引字段值 $x$ 在 $K_{i-1}\le x&lt;K_i$ 的由 $P_i$ 指向（设 $K_0=0$），而 $K_i\le x&lt;K_{i+1}$ 的由 $P_{i+1}$ 指向。</li><li>叶节点的 $P_n$ 指向下一个叶节点。</li></ul></li><li><p>共有 $n-1$ 个索引字段值和 $n$ 个指针。</p></li></ul></li><li><p>B 树和 B+ 树比较：</p><ul><li>B 树索引字段值<strong>仅出现一次</strong>，可以在叶结点或者在非叶结点；B+ 树有<strong>重复</strong>索引字段值。</li><li>B 树指向主文件的<strong>指针</strong>出现于<strong>叶结点或非叶结点</strong>，另一个指针指向结点；B+ 树只有叶子结点有指向主文件的指针。</li><li>B 树<strong>所有结点才能覆盖</strong>所有键值的<strong>索引</strong>；B+ 树叶子结点就能覆盖。</li><li>B 书叶节点和 B+ 数叶节点结构相同。</li></ul></li><li><p>B+ 树插入：</p><ul><li><p>在原树的叶子节点中找到应该插入的位置：</p><ul><li><p>当索引块满时，需要分裂，分裂后也要保证指针利用率不低于一半（平均分）。</p><blockquote><p>将这 $n$ 个搜索码值（叶结点中原有的 $n-1$ 个值再加上新插入的值）分为两组，前 $\lceil n/2\rceil$ 个放在原来的结点中，剩下的放在一个新结点中。</p></blockquote></li><li><p>否则直接插入，如果插入位置在叶子索引块最左边（即小于该块的其他索引块，要修改父节点的值）。</p></li></ul></li><li><p>分裂可能引发连锁反应，由<strong>叶结点直至根结点</strong>判断。</p></li><li><p>分裂后需要仔细调整索引<strong>键值及指针</strong>。</p></li><li><p>注意<strong>叶子结点之间</strong>链接关系的调整。</p></li></ul></li><li><p>B+ 树删除：</p><ul><li>当删除后指针利用率低于一半，先考虑从<strong>相邻叶子结点借索引项</strong>，如果不能借就合并。</li><li>合并可能引发连锁反应，由叶结点直至根结点（父节点索引值少了一个）。</li><li>合并后需要仔细调整索引键值及指针。</li><li>注意叶子结点之间链接关系的调整。</li></ul></li></ul><h3 id="散列索引"><a href="#散列索引" class="headerlink" title="散列索引"></a>散列索引</h3><ul><li><p>桶：</p><p>​ 表示能存储一条或多条记录的一个存储单位，一个桶可以是一个或者若干个连续的存储块。</p></li><li><p>散列函数：</p><p>​ $K$ 表示所有搜索码值的集合，$B$ 表示所有桶地址的集合，散列函数 $h$ 是一个从 $K\to B$ 的函数。</p><blockquote><p>散列函数要满足分布是<strong>均匀的</strong>和随机的。</p></blockquote></li><li><p>溢出桶：</p><p>​ 如果一条记录必须插入桶 $b$ 中，而桶 $b$ 已满，系统会为桶 $b$ 提供一个<strong>溢出桶</strong>，并将此记录插入到这个溢出桶中。</p></li><li><p>静态散列索引的缺点：</p><p>​ 如果桶的数目 $M$ 不变，过大则<strong>浪费</strong>，过小则将产生更多的<strong>溢出桶</strong>，增加散列索引检索的时间。</p><blockquote><p>以下为两种动态散列索引🗡，考选择题，注意区别和名字。</p></blockquote></li><li><p><strong>可扩展散列索引</strong>：</p><ul><li><p>有一个附加的间接层（<strong>指针数组</strong>），系统在访问桶本身之前必须先访问指针数组表。</p></li><li><p>指针数组能增长，其长度总是 $2$ 的幂。因而数组每增长一次，桶的数目就翻倍。</p></li><li><p>多个桶可能共享一个数据块（即多个指针数组指向同一个数据库）。</p><div align="center"><img src="/img/blog/ds-note-images/image-20211119162510134.png" srcset="/img/loading.gif" lazyload></div></li><li><p>参数 $k$ 表示散列函数所可能使用的<strong>最多位数</strong>。</p></li><li><p>散列函数：</p><p>​ 散列函数 $h$ 为每个键计算出一个 <strong>$k$ 位二进制序列</strong>（散列函数值）。</p></li><li><p>$i$ 为散列函数当前已经使用到的最多位数。取散列函数值的前 $i$ 位（散列前缀）为作为要插入桶的编号。</p></li><li><p>插入某个桶时发现已满，则需要扩展散列桶，进行分裂：</p><ul><li><p>$i$ 增 $1$，重新散列该块的数据到<strong>两个块</strong>中。</p></li><li><p>其他的桶按照散列前缀重新指向对应数据块，会出现多个桶共享一个块的情况（因为在后面加 $0/1$ 指向不变）。</p><div align="center"><img src="/img/blog/ds-note-images/image-20211119162911341.png" srcset="/img/loading.gif" lazyload></div></li></ul></li></ul><blockquote><p>缺点：</p><ul><li>翻倍要处理的工作量很大。</li><li>桶数翻倍后，主存可能装不下。</li><li>可能产生大量空间浪费，因为一个数据块满了得翻倍，其他块可能都没有存多少数据。</li></ul></blockquote></li><li><p><strong>线性散列索引</strong>：</p><ul><li><p>桶数的选择：</p><p>​ 保持与存储块所能容纳的记录总数成一个<strong>固定的比例</strong>，例如 $80\%$。超过此比例，则桶数<strong>仅增长 $1$ 块</strong>。不超过这个比例时允许有溢出桶。</p></li><li><p>假定散列函数值的 $i$ 位为桶数组项编号。现在要插入一个键值为 $K$ 的记录：</p><ul><li><p>通过散列函数得知要插入编号为 $a_1 a_2 \ldots a_i$ 的桶中，即 $a_1 a_2 \ldots a_i$ 是 $h(K) $ 的后 $i$ 位。设 $m=a_1 a_2 \ldots a_i$，$n$ 为当前的桶数。</p></li><li><p>如果 $m&lt;n$，则编号为 $m$ 的桶存在，并把记录存入该桶中。</p></li><li><p>如果 $n \leq m&lt;2^i$，那么桶还不存在，因此我们把记录存入桶 $m-2^{i-1}$，也就是当我们<strong>把 $a_1$（它现在是 $1$)改为 $0$ 时对应的桶</strong>。</p></li><li><p>如果插入后不满足比例时，要分裂一个桶成两个，这个要分裂的桶的编号是这样确定的：</p><p>​ 设当前 $n$ 已增一，则分裂与 $n$ <strong>低位相同</strong>而<strong>最高位不同</strong>的那一个桶，即假设当前为 $n=1a_2a_3\cdots a_i$，则就从 $0a_2a_3\cdots a_i$ 对应的桶分裂而来。</p><blockquote><p>因为当时有些记录是强行插入桶中的（上面 $n \leq m&lt;2^i$ 的情况，那时还没有 $1a_2a_3\cdots a_i$ 这个桶，也得硬插），插入的桶号就是 $0a_2a_3\cdots a_i$，现在分裂了，就可以插入对应正确的桶中了。</p></blockquote></li><li><p>分裂只会影响分裂之后的两个桶的记录，其他保持不变。</p></li><li><p>当桶数超过 $2^i$ 个桶时，则使 $i$ 增 $1$。</p></li></ul></li></ul></li></ul><h2 id="数据库查询实现算法"><a href="#数据库查询实现算法" class="headerlink" title="数据库查询实现算法"></a>数据库查询实现算法</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><p>查询优化：</p><p>​ 构造具有最小查询执行代价的查询执行计划应当是系统的责任，这项工作叫作查询优化：</p><ul><li>利用模型的语义及完整性规则，优化查询。</li><li>去掉无关的表</li><li>去掉无关的属性</li><li>改写成等价的效果更好的语句</li></ul></li><li><p>逻辑层优化：</p><p>​ 优化关系代数操作执行次序，<a href="#语法优化技术">后面会详细讲</a>。</p></li><li><p>物理层优化：</p><p>​ 优化关系代数操作实现算法，存取路径与执行次序。</p><blockquote><p>为每一个关系代数操作选择优化的执行<strong>例行程序</strong>，形成<strong>物理查询计划</strong>。</p></blockquote></li><li><p>物理层优化的查询实现：</p><ul><li>DBA 获取数据库的相关信息（<strong>定期统计</strong>）。</li><li>选择相应操作的例行程序</li><li>依据相关信息进行<strong>代价估算</strong>，并选择代价最少的例行程序及确定相应的参数。</li><li>形成查询计划，以基本的例行程序为基本步骤，确定这些例行程序的执行顺序。</li></ul></li><li><p>一次单一元组的一元操作（选择和投影）：</p><ul><li>选择 $\sigma_F(R)$</li><li>投影 $\pi_{\alpha}(R)$</li></ul></li><li><p>整个关系的一元操作：</p><ul><li>去重 $\delta(R),\rm DISTINCT$</li><li>聚集 $\gamma(R),\rm GROUP BY$</li><li>排序 $\tau(R),\rm SORTING$</li></ul></li><li><p>整个关系的二元操作：</p><ul><li><p>集合上的操作:</p><p>​ $\cup_S, \cap_S,-S$</p></li><li><p>包（允许重复的集合）上的操作：</p><p>​ $\cup_B, \cap_B,-B$</p></li><li><p>笛卡尔积，连接：</p><p>​ $\rm PRODUCT,JOIN$</p></li></ul></li></ul><h3 id="连接操作的实现算法"><a href="#连接操作的实现算法" class="headerlink" title="连接操作的实现算法"></a>连接操作的实现算法</h3><ul><li><p>关系的物理存储相关的参数：</p><blockquote><p>关系是存储在<strong>磁盘</strong>上的，磁盘是以<strong>磁盘块为操作单位</strong>，首先要被装载进<strong>内存</strong>（I/O 操作），然后再进行元组的处理。</p></blockquote><ul><li><p>$T_R$：</p><p>​ 关系 R 的<strong>元组数目</strong>。</p></li><li><p>$B_R$：</p><p>​ 关系 R 的<strong>磁盘块</strong>数目。</p></li><li><p>$ M$：</p><p>​ <strong>主存</strong>缓冲区的页数（主存每页容量等于一个磁盘块的容量）。</p></li><li><p>$I_R$：</p><p>​ 关系 R 的每个<strong>元组的字节数</strong>。</p></li><li><p>$b$：</p><p>​ 每个<strong>磁盘块的字节数</strong>。</p><script type="math/tex;mode=display">B_{R\times S}=T_R T_S(I_R+I_S) / b</script></li></ul><blockquote><p>下面讨论各种连接操作的实现算法🗡：</p><ul><li>因为 I/O 操作所需时间远大于内存操作，下面仅考虑 I/O 用时（次数）。</li><li>忽略写回结果所需时间（也就是说只考虑 I(input) 没有 O(output)），因为很难估计。</li></ul></blockquote></li><li><p>连接操作算法 $P_1$（主存利用率低）：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* I/O 操作 */</span><br>For i = <span class="hljs-number">1</span> to BR<br>	read i-th block of R       <span class="hljs-comment">// 执行 BR 次</span><br>	For j = <span class="hljs-number">1</span> to BS<br>		read j-th block of S   <span class="hljs-comment">// 执行 BR * BS 次</span><br>    <br>    	<span class="hljs-comment">/* 内存操作 */</span><br>		For p = <span class="hljs-number">1</span> to b/IR      <span class="hljs-comment">// 取元组，b/IR 表示一个磁盘块有多少个关系 R 的元组</span><br>			read p-th record of R<br>			For q = <span class="hljs-number">1</span> to b/IS<br>				read q-th record of S<br>                <span class="hljs-keyword">if</span> R.A 关系 S.B then<br>                    串接 p-th record of R和q-th record of S;<br>                    存入结果关系;<br></code></pre></td></tr></tbody></table></figure><p>I/O 次数估计为 $B_R + B_R\times B_S$</p></li><li><p>连接操作的全主存实现算法 $P_2$：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* 算法假定内存大小 M &gt;= BR + BS，即只需要读一遍关系 R 和 S 的磁盘块 */</span><br>For i = <span class="hljs-number">1</span> to BR <br>	read i-th block of R<br>For j = <span class="hljs-number">1</span> to BS <br>	read j-th block of S<br>	<span class="hljs-comment">/* 内存操作稍有不同，不是重点 */</span><br></code></pre></td></tr></tbody></table></figure><p>I/O 次数估计为 $B_R + B_S$</p></li><li><p>连接操作的半主存实现算法 $P_3$：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 算法假定内存大小min(BR,BS) &lt; M &lt; BR + BS，这里假设较小的是 BR，读一次 R 的磁盘块放内存，S 的每次读就处理，不用全部放入内存再处理 */</span><br>For i = <span class="hljs-number">1</span> to BR <br>	read i-th block of R<br>For j = <span class="hljs-number">1</span> to BS <span class="hljs-comment">//一次读入一块关系 S 的磁盘块</span><br>	read j-th block of S<br>	<span class="hljs-comment">/* 内存操作稍有不同，不是重点 */</span><br></code></pre></td></tr></tbody></table></figure><p>I/O 次数估计为 $B_R + B_S$</p></li><li><p>连接操作的大关系实现算法 $P_4$（将主存充分利用）：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 把关系 R 划分为 BR/(M-2) 个子集合，每个子集合具有 M-2 块。令 MR 为 M-2 块容量的主存缓冲区，</span><br><span class="hljs-comment">* MS 为 1 块容量的 S 的主存缓冲区，还有 1 块作为输出缓冲区。</span><br><span class="hljs-comment">*/</span><br>For i = <span class="hljs-number">1</span> to BR/(M<span class="hljs-number">-2</span>) <span class="hljs-comment">//一次读入M-2块</span><br>	read i-th Sub-<span class="hljs-built_in">set</span> of R into MR      <span class="hljs-comment">// 执行 BR/(M-2) 次,总共 BR 次 I/O   </span><br>	For j = <span class="hljs-number">1</span> to BS <span class="hljs-comment">//一次读入一块</span><br>		read j-th block of S into MS    <span class="hljs-comment">// 执行 BR/(M-2) * BS 次</span><br>		For p = <span class="hljs-number">1</span> to (M<span class="hljs-number">-2</span>)b/IR<br>		<span class="hljs-comment">/* 内存操作稍有不同，不是重点 */</span><br></code></pre></td></tr></tbody></table></figure><p>I/O 次数估计为 $B_S(B_R /(M-2)) + B_R$</p><blockquote><p>迭代器不考。</p></blockquote></li></ul><h3 id="一趟扫描算法"><a href="#一趟扫描算法" class="headerlink" title="一趟扫描算法"></a>一趟扫描算法</h3><ul><li><p>关系 $R$ 数据读取：</p><blockquote><p>$B(R)$ 是 $R$ 的<strong>存储块</strong>（磁盘块）数目</p><p>$T(R)$ 是 $R$ 的<strong>元组</strong>数目</p><p>忽略写回代价</p></blockquote><ul><li><p>聚簇关系：</p><blockquote><p>指关系的元组集中存放（一个块中仅是一个关系中的元组）。</p></blockquote><ul><li><p>TableScan(R) 为表空间扫描算法：</p><p>​ 扫描结果未排序 $B(R)$</p></li><li><p>SortTableScan(R)：</p><p>​ 扫描结果<strong>排序</strong> $B(R)\quad or\quad 3B(R)$</p><blockquote><p>内存装得下 $R$ 就只需要 $B(R)$，否则需要 $3B(R)$：</p><ul><li>先读一遍 $R$，做第一趟排序。</li><li>写回磁盘一次，因为还需要第二趟排序。</li><li>再多路读 $R$，做归并排序。</li><li>不考虑写回，上面共 $3B(R)$。</li></ul></blockquote></li><li><p>IndexScan(R) 为索引扫描算法：</p><p>​ 扫描结果未排序 $B(R)$</p></li><li><p>SortIndexScan(R)：</p><p>​ 扫描结果排序 $B(R)\quad or\quad 3B(R)$</p></li></ul></li><li><p>非聚簇关系：</p><blockquote><p>关系的元组不一定集中存放（一个块中不仅是一个关系中的元组）。最坏情况下就是相邻的元组都不在同一磁盘块，每次都要读一个新磁盘。</p></blockquote><ul><li>扫描结果未排序为 $T(R)$</li><li>扫描结果排序为 $T(R) + 2B(R)$</li></ul></li></ul></li><li><p>去重复 $\&amp;(R)$：</p><ul><li>在<strong>内存中保存</strong>已处理过的元组。</li><li>当新元组到达时，需与之前处理过的元组进行比较。</li><li>建立不同的<strong>内存数据结构</strong>（排序结构/散列结构/B+ 树），来保存之前处理过的数据，以便快速判断是否重复。</li><li>算法复杂性为 $B(R)$</li><li>应用条件为 $B(\&amp;(R))\le M$</li></ul></li><li><p>分组聚集 $\gamma _L(R)$</p><ul><li><p>需要在内存中保存所有的分组，保存每个分组上的聚集信息。</p></li><li><p>建立不同的内存数据结构（排序结构/散列结构/B+ 树），来保存之前处理过的数据，以便快速处理整个关系上的操作。</p></li><li>算法复杂性为 $B(R)$</li><li>应用条件为<strong>所有分组的数量应能在内存中完整保存</strong>。</li></ul></li><li><p>集合或者包上的二元运算：</p><ul><li><strong>扫描一个关系</strong> $R$，然后<strong>再扫描另一个关系</strong> $S$。</li><li>集合的操作需要去重复。包的操作需要做计数每个元组的<strong>出现次数</strong>（具体操作还需具体分析）。</li><li>算法复杂性为 $B(R)+B(S)$</li><li>应用条件为 $min(B(R), B(S))\le M$（只要用一个能放入内存就行）。</li></ul></li><li><p>连接操作实现算法 $P_4$ 的改进：</p><ul><li>主要思想就是把内存操作的两重循环通过散列的方式，压缩到一重循环就行。</li><li>散列函数可取连接条件中的相应属性，使得<strong>散列结果相同说明这两个属性满足连接条件</strong>。</li></ul></li></ul><h3 id="基于索引的选择算法"><a href="#基于索引的选择算法" class="headerlink" title="基于索引的选择算法"></a>基于索引的选择算法</h3><ul><li><p><strong>选择</strong>条件中有涉及到<strong>索引属性</strong>时，可以使用索引，辅助快速检索。</p></li><li><p>聚簇和非聚簇索引，使用时其效率是不一样的。</p></li><li><p>案例分析🗡：</p><ul><li><p>假设 $B(R)=1000, T(R)=20000$，即 $R$ 有 $20000$ 个元组存放到 $1000$ 个块中。</p></li><li><p>$a$ 是 $R$ 的一个属性，在 $a$ 上有一个索引，并且考虑 $\sigma_{a=0}(R)$ 操作：</p><ul><li><p>如果 $R$ 是<strong>聚簇</strong>的，且<strong>不使用索引</strong>，查询代价 $=~1000$ 个 I/O。</p><blockquote><p>一个块中仅是一个关系中的元组，所以最多遍历 $1000$ 次磁盘块就能找到所以元组。</p></blockquote></li><li><p>如果 $R$ <strong>不是聚簇</strong>的，且<strong>不使用索引</strong>，查询代价 $=~20000$ 个 I/O。</p><blockquote><p>一个块中不仅是一个关系中的元组，可能含有其他数据，必须通过元组的指针进行遍历，所以要访问 $20000$ 个元组，考虑最坏情况，相邻元组都不在同一个块，那么就要访问 $20000$ 个块。</p><p>$V(A, R)$ 表示 $R$ 中属性 $A$ 出现不同值的数目，即 $\Pi_A(R)$ 的数目。</p><p>PPT 中 $A,R$ 的顺序时常发生改变，询问老师说都可以。书上是属性在前，关系名在后。为了统一写法，下面全部采用书本的形式，因此和 PPT 几乎都是相反的。</p></blockquote></li><li><p>如果 $V(a,R)=100$ 且索引是聚簇的，查询代价估计 $=1000/100=10$ 个 I/O。</p><blockquote><p>有索引的帮助，可以快速定位到这个元组，再加上是聚簇的，所以相同值的也是相邻的。</p><p>因为有 $100$ 个不同的值，所以在最坏情况下平均分散到 $10$ 个块里面。</p></blockquote></li><li><p>如果 $V(a,R)=100$ 且索引是非聚簇的，查询代价 $=~20000/100=200$ 个 I/O。</p></li><li><p>如果 $V(a,R)=20000$，即 $a$ 是关键字，主键索引，查询代价 $=~20000/20000=1$ 个 I/O，不管是否是聚簇的。</p></li></ul></li></ul></li><li><p>基于有序索引的连接算法（Zig-Zag 连接算法）:</p><ul><li>以 $R$ 和 $S$ 做等值连接为例。</li><li>$R$ 和 $S$ 都有在 $Y$ 属性上的 B+ 树索引。</li><li>$R$ 和 $S$ 均从左至右读取索引树的叶子结点：<ol><li>读 $R$ 的第一个索引项赋予 $a$，再读 $S$ 的第一个索引项赋予 $b$；</li><li>如果 $a\not=b$，则：<ul><li>如果 $a&lt;b$，则将 $R$ 的下一个索引项赋予 $a$，继续执行 $2$。</li><li>如果 $a&gt;b$，则将 $S$ 的下一个索引项赋予 $b$，继续执行 $2$。</li></ul></li><li>如果 $a=b$，则将 $R$ 和 $S$ 关系中对应的元组读出并进行连接，直到 $R$ 的所有相等的 $a$ 值和 $S$ 的所有相等的 $b$ 值对应的元组都处理完毕，将 $R$ 的下一个索引项赋予 $a$，将 $S$ 的下一个索引项赋予 $b$，继续执行 $2$。</li></ol></li></ul></li></ul><h3 id="两阶段多路归并排序-TPMMS"><a href="#两阶段多路归并排序-TPMMS" class="headerlink" title="两阶段多路归并排序 TPMMS"></a>两阶段多路归并排序 TPMMS</h3><blockquote><p>实验做，考试老师说不会考。</p></blockquote><ul><li><p>基本思路：</p><ul><li><p>第一趟：</p><p>​ 划分子集，并使子集具有某种特性，如有序或相同散列值等。</p></li><li><p>第二趟：</p><p>​ 处理全局性内容的操作，形成<strong>结果</strong>关系。如<strong>多子集间的归并排序</strong>，相同散列值子集的操作等。</p></li></ul></li><li><p>内排序：</p><p>​ 待排序的数据可一次性地装入内存中，即排序者可以完整地看到和操纵所有数据。内存中数据的排序算法有插入排序、选择排序、冒泡排序等。</p></li><li><p>外排序：</p><p>​ 待排序的数据不能一次性装入内存，即排序者不能一次完整地看到和操纵所有数据，需要将数据分批装入内存分批处理的排序问题。</p></li><li><p>多路归并的过程（仅简单分析）：</p><ul><li><p>设内存块数为 $B_{memory}$，待排序数据块数为 $B_{problem}$。</p></li><li><p>第一趟划分子集并排序，这里要求每个子集的块数要小于等于内存块数 $B_{memory}$，I/O 次数为 $2B_{problem}$。</p></li><li><p>第二趟各子集间的归并排序，这里要求子集的数目要小于内存块数 $B_{memory}$，I/O 次数为 $2B_{problem}$。</p><blockquote><p>这两个限制说明大数据集块数 $\le B^2_{memory}$。</p><p>同时内存的块中得有一块用来输出（第一趟不需要输出块），一块用来比较（老师说可以没有）。</p></blockquote></li><li><p>算法的效率：</p><p>​ 读写磁盘块的次数，即 I/O 数 $=4B_{problem}$。</p></li></ul></li></ul><h3 id="语法优化技术"><a href="#语法优化技术" class="headerlink" title="语法优化技术"></a>语法优化技术</h3><blockquote><p>必考，估计选择填空题🗡。</p></blockquote><ul><li><p>通过语法树，表达和分析关系代数表达式：</p><ul><li>长这样：</li></ul><p><img src="/img/blog/ds-note-images/image-20211021164943547.png" srcset="/img/loading.gif" lazyload style="zoom:67%"></p><p>从叶子到树根执行。</p><ul><li><p>策略：</p><ul><li><p>尽可能<strong>提前</strong>选择和投影（相当于这两个运算在语法树上尽量下放）：</p><p>​ 可使中间结果变小，节省几个数量级的执行时间。</p></li><li><p><strong>选择与投影</strong>尽量一起做：</p><p>​ 投影或选择后，下一个投影或选择操作通过中间结果进行操作，这样就不需要再从磁盘读数据。</p></li><li><p>投影与其前后的二元运算结合：</p><p>​ 通过投影，去掉关系的<strong>无关属性</strong>（不参与二元运算的属性），可以避免多次扫描整个关系。</p><blockquote><p>PPT 似乎只使用了以上三个策略，后面 MOOC 中有使用，还是按 PPT 来吧。</p></blockquote></li><li><p>笛卡尔积转连接运算（把选择与其前的笛卡尔积合并成一个连接）：</p><p>​ 当 $R\times S$ 前有选择运算且其中<strong>存在条件</strong>是 $R,S$ 属性间比较的运算时，可将其转化为<strong>连接</strong>运算可节省时间。</p></li><li><p>执行连接运算前对关系做适当预处理：</p><p>​ 文件排序、建立临时索引等，可使两关系公共值高效联接。</p></li><li><p>找出表达式里的公共子表达式：</p><p>​ 若公共子表达式结果不大，则预先计算，以后可读入此结果，节时多，尤当视图情况下有用。</p></li></ul></li></ul></li><li><p>关系代数操作次序交换的等价性：</p><ul><li><p>$L_1$，<strong>连接与积</strong>（并交）的<strong>交换</strong>律：</p><p>​ 设 $E_1, E_2$ 是关系代数表达式，$F$ 是 $E_1, E_2$ 中属性的附加限制条件，则有：</p></li></ul></li></ul><script type="math/tex;mode=display">\begin{aligned}
E_1 \bowtie E_2 &\equiv E_2 \bowtie E_1 \\
E_1 \underset{F}\bowtie E_2 &\equiv E_2 \underset{F}\bowtie E_1 \\
E_1 \times E_2 &\equiv E_2 \times E_1
\end{aligned}</script><blockquote><p>通过交换，可以将 $E_1, E_2,\cdots ,E_n$ 中结果小集合小的放入内存，进行连接或者积操作，可以减小中间结果。</p></blockquote><ul><li><p>$L_2$，<strong>连接与积</strong>（并交）的<strong>结合</strong>律:</p><p>​ 若 $E_1, E_2, E_3$ 是关系代数表达式，$F_1, {~F}_2$ 是条件，则有:</p><script type="math/tex;mode=display">\begin{aligned}
(E_1 \underset{F_1}\bowtie E_2) \underset{F_2}\bowtie E_3 \equiv E_1 \underset{F_1}\bowtie (E_2\underset{F_2}\bowtie E_3)
\\(E_1 \bowtie E_2) \bowtie E_3 \equiv E_1 \bowtie(E_2 \bowtie E_3)
\\(E_1 \times E_2) \times E_3 \equiv E_1 \times(E_2 \times E_3)
\end{aligned}</script><blockquote><p>结合律和交换律说明结果与运算顺序无关，可以将 $E_1, E_2,\cdots ,E_n$ 中结果集合排序，升序放入内存，进行连接或者积操作，可以减小中间结果。</p></blockquote></li><li><p>$L_3$，<strong>投影</strong>串接律（双向使用）：</p><p>​ 设属性集 $\{A_1,\cdots, A_{n}\} \subseteq \{B_1, \cdots, B_m\}$，$ E$ 是表达式，则有:</p><script type="math/tex;mode=display">\Pi_{A_1, \cdots, A_{n}}\left(\Pi_{B_1, \cdots, B_m}(E)\right) \equiv \Pi_{A_1, \cdots, A_{n}}(E)</script><blockquote><p>从左往右使用，两遍扫描变为一遍扫描，减少 IO 次数。</p><p>从右到左使用，可以用于扩充，便于将投影在语法树中下放，减少无关属性。</p></blockquote></li><li><p>$L_4$，<strong>选择</strong>串接律（双向使用）：</p><p>​ 若 $E$ 是关系代数表达式，$F_1, ~F_2$ 是条件，则有:</p><script type="math/tex;mode=display">\sigma_{F_1}\left(\sigma_{F_2}(E)\right) \equiv \sigma_{F_1 \wedge F_2}(E)</script><blockquote><p>理由其实同上，只是扩充的时候是选择下放。</p></blockquote></li><li><p>$L_5$，<strong>选择和投影</strong>的<strong>交换</strong>律：</p><ul><li>设条件 $F$ 只涉及属性 $\{A_1, \ldots, A_{n}\}$，$E$是关系表达式，则有:</li></ul><script type="math/tex;mode=display">\Pi_{A_1, \cdots, A_{n}}\left(\sigma_F(E)\right) \equiv \sigma_F\left(\Pi_{A_1,\cdots, A_{n}}(E)\right)</script><ul><li>更一般地，若 $F$ 还涉及不属于 $\{A_1, . ., A_n\}$ 的属性 $\{B_1, . ., B_m\}$，则：</li></ul><script type="math/tex;mode=display">\Pi_{A_1, \cdots, A_{n}}\left(\sigma_F(E)\right) \equiv \Pi_{A_1, \cdots, A_{n}}\left(\sigma_F\left(\pi_{A_1,\cdots, A_{n}, B_1, \cdots, B_m}(E)\right)\right)</script></li><li><p>$L_6$，<strong>选择和积</strong>的<strong>交换</strong>律：</p><p>​ 设 $E_1, E_2$ 是关系代数表达式：</p><ul><li>若条件 $F$ 只涉及 $E_1$ 中的属性，则有：</li></ul><script type="math/tex;mode=display">\sigma_F\left(E_1 \times E_2\right) \equiv \sigma_F\left(E_1\right) \times E_2</script><ul><li>若 $F=F_1 \wedge F_2, F_1, F_2$ 分别只涉及 $E_1, E_2$ 中属性, 则有：</li></ul><script type="math/tex;mode=display">\sigma_F\left(E_1 \times E_2\right) \equiv \sigma_{F_1}\left(E_1\right) \times \sigma_{F_2}\left(E_2\right)</script><ul><li>若 $F=F_1 \wedge F_2, {~F}_1$ 只涉及 $E_1$ 中属性，而 $F_2$ 涉及 $E_1,E_2$ 中属性，则有：</li></ul><script type="math/tex;mode=display">\sigma_F\left(E_1 \times E_2\right) \equiv \sigma_{F_2}\left(\sigma_{F_1}\left(E_1\right) \times E_2\right)</script></li><li><p>$L_7$，<strong>投影和积</strong>的<strong>交换</strong>律：</p><p>​ 设 $E_1, E_2$ 为两关系代数表达式，$A_1, \cdots, A_{n}$ 是出现在 $E_1$ 或 $E_2$ 中的一些属性，其中 $B_1, \cdots, B_m$ 出现在 $E_1$ 中，<strong>剩余的属性</strong> $C_1, \cdots, C_k$ 出现在 $E_2$ 中，则有:</p><script type="math/tex;mode=display">\Pi_{A_1, \cdots, A_{n}}\left(E_1 \times E_2\right) \equiv \Pi_{B_1, \cdots, B_m}\left(E_1\right) \times \Pi_{C_1, \cdots, C_k}\left(E_2\right)</script></li><li><p>$L_8$，<strong>选择和并</strong>的<strong>交换</strong>律：</p><p>​ 设关系代数表达式 $E=E_1 \cup E_2, F$ 是条件，则有:</p><script type="math/tex;mode=display">\sigma_F\left(E_1 \cup E_2\right) \equiv \sigma_F\left(E_1\right) \cup \sigma_F\left(E_2\right)</script><blockquote><p>此定理要求 $E_1, E_2$ 是<strong>并相容</strong>的。</p></blockquote></li><li><p>$L_9$，<strong>选择和差</strong>的<strong>交换</strong>律：</p><p>​ 设关系代数表达式 $E=E_1-E_2, F$ 是条件，则有:</p><script type="math/tex;mode=display">\sigma_F\left(E_1-E_2\right) \equiv \sigma_F\left(E_1\right)-\sigma_F\left(E_2\right)</script></li><li><p>$L_{10}$，<strong>投影和并</strong>的<strong>交换</strong>律：</p><p>​ 设关系代数表达式 $E=E_1 \cup E_2, A_1, \cdots, A_{n}$ 是 $E$ 中的一些属性，则有:</p><script type="math/tex;mode=display">\Pi_{A_1, \cdots, A_{n}}\left(E_1 \cup E_2\right) \equiv \Pi_{A_1, \cdots, A_{n}}\left(E_1\right) \cup \pi_{A_1, \cdots, A_{n}}\left(E_2\right)</script><blockquote><p>因为投影会去重，<strong>投影和差</strong>的<strong>交换</strong>律是不成立的，即：</p><script type="math/tex;mode=display">\Pi_{A_1, \cdots, A_{n}}\left(E_1 - E_2\right) \not\equiv \Pi_{A_1, \cdots, A_{n}}\left(E_1\right) - \pi_{A_1, \cdots, A_{n}}\left(E_2\right)</script><p>一个大概的例子：</p><p>​ 假设 $E_1$ 只有 $3$ 个元组，在属性 ${A_1, \cdots, A_{n}}$ 上都相等，$E_2$ 只有一个元组，与 $E_1$ 的 $3$ 个元组之一相等。</p><ul><li><p>先差后投影：</p><p>​ $E_1-E_2$ 有两个元组，去重后有 $1$ 个元组。</p></li><li><p>先投影后差：</p><p>​ 投影后 $E_1,E_2$ 都只有一个元组，差运算后结果为空，与前者不等价。</p></li></ul></blockquote></li></ul><ul><li><p>优化算法执行流程：</p><ul><li><p>依据选择串接律 $\sigma_{F_1}\left(\sigma_{F_2}(E)\right) \equiv \sigma_{F_1 \wedge F_2}(E)$，对于右边形式的关系表达式，转为左边串接形式。</p></li><li><p>对每个选择和投影，依据定理 $L_4$ 至 $L_9$，尽可能把它下放（如果一个投影是对某表达式所有属性进行的，相当于 <code>select *</code>，则去掉）</p></li><li><p>依据选择串接律和投影串接律把串接的选择和投影组合为单个选择、单个投影。</p><blockquote><p>笔者感觉以上修改要多次使用，直到不能再应用为止。</p></blockquote></li><li><p>对修改后的语法树，将其内结点按以下方式<strong>分组</strong>：</p><ul><li>每个二元运算结点（积、并、差、连接等）和其所有<strong>一元运算直接祖先结点</strong>放在 一组</li><li>对于其后代结点，若后代结点是一串<strong>一元运算</strong>且<strong>以树叶为终点</strong>，则将这些一元运算结点放在该组中。</li><li>若后代节点有二元运算结点<strong>笛卡儿积</strong>，则不能将后代结点归入该组。</li><li>笔者认为可能是从叶子节点向上分组，这样遇到一个二元运算节点就做判断，这个二元节点向上的一元运算归为一组，向下到叶子节点的运算也归为这组，然后整个组就独立执行，输出一个结果集合，相当于一个叶子节点了。重复这个过程直到执行完毕。</li></ul></li><li><p>语法树执行顺序为：</p><p>​ 以每组结点为一步，后代先执行，从叶子执行到根。</p></li></ul></li></ul><h3 id="代价估计🗡"><a href="#代价估计🗡" class="headerlink" title="代价估计🗡"></a>代价估计🗡</h3><ul><li><p>统计信息：</p><ul><li><p>$T_R$ 或 $T(R)$：</p><p>​ 关系 $R$ 的元组数目。</p></li><li><p>$V(A, R)$：</p><p>​ $R$ 中属性 $A$ 出现不同值的数目，即 $\Pi_A(R)$ 的数目。</p><blockquote><p>PPT 中 $A,R$ 的顺序时常发生改变，询问老师说都可以。书上是属性在前，关系名在后。为了统一写法，下面全部采用书本的形式，因此和 PPT 几乎都是相反的。</p></blockquote></li></ul></li><li><p>估计的目标：</p><p>​ 给定一个表达式 $E$，如何估计 $E$ 的元组数目 $T(E)$。</p></li><li><p>估算 $\pi_A(R)$ 的大小：</p><blockquote><p>PPT：</p><p>​ $T(\pi_A(R))=T(R)$</p><p>笔者认为应该是：</p><p>​ $T(\pi_A(R))=V(A,R)$</p><p>投影运算并末减少行数，但可能有效地减少了存储结果关系的<strong>块数</strong>（每个元组所占的大小减少）。</p></blockquote></li><li><p>估算选择运算 $S= \sigma_{ A=c} (R)$ 的大小：</p><blockquote><p>严谨：</p><p>​ $T(S)$ 介于 $[0,T(R)-V(A, R)+1]$ 之间</p><p>原因分析：</p><ul><li>最小值为 $0$，因为可能关系 $R$ 中的 $A$ 属性不存在值为 $c$ 的元组。</li><li>最大值为 $T(R)-V(A, R)+1$，即关系 $R$ 中的 $A$ 属性值不为 $c$ 的元组数目都是 $1$，共有 $V(A,R)$。</li></ul><p>估计：</p><p>​ $T(S)=T(R) / V(A, R)$，即 $A$ 属性不同值的元组数相等。</p><p>暴力估计：</p><p>​ 不知道 $V(R,A)$ 时，默认为 $10$，即 $T(S) = T(R)/10$。</p></blockquote></li><li><p>估算选择运算 $S=\sigma_{A&lt;c}(R)$ 的大小：</p><blockquote><p>严谨：</p><p>​ $T(S)$ 介于 $0$ to $T(R)$ 之间</p><p>分析：</p><ul><li>最小值 $0$ 即不存在这样的元组。</li><li>最多 $T(R)$ 即所有元组都满足条件。</li></ul><p>估计：</p><p>​ $T(S)=T(R) / 2$，应有一半的元组满足条件。</p><p>实际常用估计：</p><p>​ $T(S)=T(R) / 3$</p></blockquote></li><li><p>估算选择运算 $S=\sigma_{A=10\quad and\quad B&lt;20}(R)$ 的大小</p><blockquote><p>估计：</p><p>​ $T(S)=T(R) /(V(R, A)^{*} 3)$</p><p>分析：</p><ul><li>$\sigma_{A=10\quad and\quad B&lt;20}(R)=\sigma_{B&lt;20}(\sigma_{A=10}(R))$</li><li>$A=10$，得出 $T(S)=T(R) / V(R, A)$</li><li>$B&lt;20$，得出 $T(S)=T(S) / 3$</li></ul></blockquote></li><li><p>估算选择运算 $S = \sigma_{C_1\quad or\quad C_2}(R)$ 的大小：</p><blockquote><p>估计：</p><p>​ $\begin{aligned}T(S)={n}(1-(1-\frac{m_1}{n})(1-\frac{m_2}{n}))\end{aligned}$</p><p>分析：</p><ul><li>$R$ 有 $n$ 个元组，其中有 $m_1$ 个满足 $C_1$，有 $m_2$ 个满足 $C_2$。</li><li>$\begin{aligned}(1-\frac{m_1}{n})\end{aligned}$ 是不满足 $C_1$ 的那些元组，$\begin{aligned}(1-\frac{m_2}{n})\end{aligned}$ 是不满足 $C_2$ 的那些元组。</li><li>两数之积是不满足条件的元组概率（这里并不严谨），$1$ 减去这个积就是满足条件元组出现的概率。</li></ul></blockquote></li><li><p>前一种类型的举例，估计选择运算 $S=\sigma_{A=10\quad or\quad B&lt;20} (R)$ 的大小：</p><blockquote><p>分析：</p><script type="math/tex;mode=display">\begin{gathered}
n=T(R)=10000\\ V(R, A)=50 \\
m_1=T(R) / V(R, A)=10000 / 50=200
\\m_2=T(R) / 3=10000 / 3 \approx 3333
\end{gathered}</script><p>即有 $m_1$ 个满足 $C_1$，有 $m_2$ 个满足 $C_ 2$，$\begin{aligned}(1-\frac{m_1}{n})(1-\frac{m_2}{n})\end{aligned}$ 是不满足这个条件的元组的概率，计算如下：</p><script type="math/tex;mode=display">T(S)=10000^{\star}(1-(1-200 / 10000)(1-3333 / 10000)) \approx 3466</script><p>也可以简单估计为 $T(S)=T(R) / 3=10000 / 3 \approx 3333$</p></blockquote></li><li><p>估算连接运算 $S’=R(X, Y)\quad \text{Natural Join}\quad S(Y, Z)$ 的大小：</p><blockquote><p>估计：</p><p>​ $\begin{aligned}T({S’})=\frac{T(R)T(S) }{\max(V(Y, R), V(Y, S))}\end{aligned}$</p><p>分析：</p><ul><li><p>假定 $V(Y, R)\ge V(Y, S), R$ 中元组 $r$ 和 $S$ 中元组有相同 $Y$ 值的概率 $=1 / V(Y,R)$</p></li><li><p>假定 $V(Y, R)&lt;V(Y, S), R$ 中元组 $r$ 和 $S$ 中元组有相同 $Y$ 值的概率 $=1 / V(Y, S)$</p></li><li><p>则笛卡尔积后的关系在 $Y$ 上相等的概率 $=1 / \max (V(R, Y), V(S, Y))$</p></li><li><p>笔者尝试解释：</p><ul><li><p>首先假设数据是均匀分布，即假设一个关系 $U$ 的 $Y$ 属性中，具有相同属性值的元组数均为 $x$ 个，这样总元组数是 $x\times V(Y,U)$。</p></li><li><p>$R$ 关系的总元组数为 $x_R\times V(Y,R)$，$S$ 关系的总元组数为 $x_S\times V(Y,S)$。</p></li><li><p>假设 $R.Y\subseteq S.Y,V(Y, R)&lt;V(Y,S)$，即 $R$ 的 $Y$ 属性值在 $S$ 中均存在。这使得 $R$ 的每个元组，都能等值连接 $x_S$ 个 $S$ 的元组。</p></li><li><p>所以 $R\times S$ 中，满足 $R.Y=S.Y$ 的元组数为 $x_R\times V(Y,R)\times x_S$。然后除以总元组数即可得到概率（其实分子就是估计值 $T(S’)$）：</p><script type="math/tex;mode=display">\frac{x_R\times V(Y,R)\times x_S}{x_R\times V(Y,R)\times x_S \times V(Y,S)}=\frac{1}{V(Y,S)}</script></li></ul></li><li><p>PPT 上的例子 $T(R)=10000, T(S)=50000, V(R, Y)=500, V(S, Y)=1000$，</p><p>估计为 $T(S’)=10000 * 50000 / 1000=500000$</p></li></ul></blockquote></li></ul><h2 id="数据库事务处理技术"><a href="#数据库事务处理技术" class="headerlink" title="数据库事务处理技术"></a>数据库事务处理技术</h2><h3 id="事务（纯复制）"><a href="#事务（纯复制）" class="headerlink" title="事务（纯复制）"></a>事务（纯复制）</h3><ul><li><p>事务的定义：</p><ul><li>事务是数据库管理系统提供的控制数据操作的一种手段。</li><li>通过这一手段，应用程序员将一系列的数据库操作组合在一起作为一个整体进行操作和控制，以便数据库管理系统能够提供一致性状态转换的保证。</li></ul></li><li><p>事务的宏观性（应用程序员看到的事务）：</p><p>​ 一个存取或改变数据库内容的程序的一次执行，或者说一条或多条 SQL 语句的一次执行被看作一个事务。</p><blockquote><p>事务一般是由应用程序员提出，因此有开始和结束，结束前需要<strong>提交或撤消</strong>（通过 commit 或 rollback 确认的）。</p></blockquote></li><li><p>事务的微观性（DBMS 看到的事务）：</p><p>​ 对数据库的一系列基本操作（读、写）的一个整体性执行。</p></li><li><p>事务的并发执行：</p><p>​ 多个事务从宏观上看是并行执行的，但其微观上的基本操作（读、写）则可以是交叉执行的。</p><blockquote><p>并发控制就是通过事务微观交错执行次序的正确安排，保证事务宏观的独立性、完整性和正确性。</p></blockquote></li><li><p>事务的特性（ACID 特性🗡）：</p><ul><li><p><strong>原子性</strong>（atomicity）：</p><p>​ 事务的所有操作在数据库中<strong>要么全部正确反映出来，要么完全不反映</strong>。</p></li><li><p><strong>一致性</strong>（consistency）：</p><p>​ 保证事务的操作状态是正确的，不能出现「<strong>丢失修改，不可重复读，脏读</strong>」三类错误，由隔离性保证。</p><blockquote><ul><li><p>丢失修改：</p><p>​ 操作顺序是 $T_1$ 读，$T_2$ 读，$T_1$ 写，$T_2$ 写。$T_1$ 的修改就被 $T_2$ 所覆盖了，即丢失了修改。</p></li><li><p>不可重复读（理应能够重复读，但是现在不能重复读了，同一事务两次读期间未作修改，但读到的内容却不同）：</p><p>​ 操作顺序是 $T_1$ 读，$T_2$ 读，$T_2$ 写，$T_1$ 再读，发现与第一次读的数据不一致。</p></li><li><p>脏读：</p><p>​ 操作顺序是 $T_2$ 读，$T_2$ 写，$T_1$ 读，$T_2$ 回滚，此时 $T_1$ 读到的是其他事务未提交的数据，回滚后这个数据已经无效了，称为脏数据。</p></li></ul></blockquote></li><li><p><strong>隔离性</strong>（isolation）：</p><p>​ 尽管多个事务可能并发执行，但系统保证，对于任何一对事务 $T_i$ 和 $T_j$，在 $T_i$ 看来，$T_j$ 或者在 $T_i$ 开始之前已经完成执行，或者在 $T_i$ 完成之后开始执行。因此，每个事务都感觉不到系统中有其他事务在并发地执行。</p></li><li><p><strong>持久性</strong>（durability）：</p><p>​ 一个事务成功完成后，它对数据库的改变必须是<strong>永久</strong>的，即使出现系统故障。</p></li></ul><blockquote><p>可以说具有 ACID 特性的若干数据库基本操作的组合体被称为事务。</p></blockquote></li></ul><h3 id="事务调度"><a href="#事务调度" class="headerlink" title="事务调度"></a>事务调度</h3><ul><li><p>事务调度概念：</p><p>​ 一组事务的基本步骤（读、写、其他控制操作如加锁、解锁等）的一种执行顺序称为对这组事务的一个调度。</p></li><li><p>并发调度的正确性：</p><p>​ 并发调度下所得到的新数据库<strong>结果</strong>与分别串行地运行这些事务所得的新数据库完全一致，调度才是正确的，是结果意义上的正确。</p></li><li><p>可串行性：</p><p>​ 如果不管数据库初始状态如何，一个调度对数据库状态的影响都和某个<strong>串行调度</strong>相同，则我们说这个调度是可串行化的或具有可串行性。</p><blockquote><p>可串行化调度一定是正确的并行调度，但正确的并行调度，却未必都是可串行化的调度。</p><p>因为并行调度的正确性是指<strong>内容上</strong>结果正确性（结果对就对了），而可串行性是指<strong>形式上</strong>结果正确性，便于操作。</p></blockquote></li><li><p>一种简单的事务调度的标记模型：</p><ul><li><p>$r_T(A)$：</p><p>​ 事务 $T$ 读 $A$。</p></li><li><p>$w_T(A)$：</p><p>​ 事务 $T$ 写 $A$。</p></li></ul></li><li><p>冲突：</p><ul><li><p>如果调度中两个动作的顺序交换，若涉及的事务中至少有一个事务的行为会改变，则称这两个动作<strong>冲突</strong>。</p></li><li><p>有冲突的两个操作是不能交换次序的，没有冲突的两个事务是可交换的</p></li><li><p>几种冲突的情况：</p><ul><li><strong>同一事务</strong>的<strong>任何两个操作</strong>都是冲突的：<script type="math/tex;mode=display">r_i(X) ; w_i(Y) \quad w_i(X) ; r_i(Y)</script></li><li><strong>不同事务</strong>对<strong>同一元素</strong>的两个<strong>写</strong>操作是冲突的：<script type="math/tex;mode=display">w_i(X) ; w_j(X)</script></li><li><strong>不同事务</strong>对<strong>同一元素</strong>的<strong>一读一写</strong>操作是冲突的：<script type="math/tex;mode=display">w_i(X) ; r_j(X) \quad r_i(X) ; w_j(X)</script></li></ul></li></ul></li><li><p>冲突可串行性：</p><p>​ 一个调度，如果通过<strong>交换</strong>相邻两个<strong>无冲突</strong>的操作能够转换到某一个<strong>串行</strong>的调度（注意不是可串行），则称此调度为<strong>冲突可串行化</strong>的调度。</p><blockquote><p><strong>冲突可串行性</strong>是比<strong>可串行性</strong>更严格的概念，即<strong>冲突可串行性</strong>是<strong>可串行性</strong>的充分不必要条件。</p><p>例子：</p><p>​ $w_1(Y) ; w_2(Y) ; w_2(X) ; w_1(X) ; w_3(X)$ 是一个<strong>可串行化</strong>的调度，因为它与串行调度 $w_1(Y) ; w_1(X) ; w_2(Y) ; w_2(X) ; w_3(X)$ 的结果等价。</p><p>​ 但是它相邻动作都是冲突的，不能交换形成串行调度，所以不是<strong>冲突可串行性</strong>的调度。</p></blockquote></li><li><p>冲突可串行性判别算法：</p><ul><li>构造一个有向图，结点是每一个事务 $T_i$。</li><li>如果 $T_i$ 的一个操作与 $T_j$ 的一个操作发生冲突，且 $T_i$ 在 $T_j$ 前执行，则绘制一条由 $T_j$ 指向 $T_j$ 的有向边，表示 $T_i$ 要在 $T_j$ 前执行。</li><li>如果此有向图没有环，则是冲突可串行化的。</li></ul><blockquote><p>例子：</p><div align="center"><img src="/img/blog/ds-note-images/image-20211116223739408.png" srcset="/img/loading.gif" lazyload></div><p>与边上的元素无关，只要存在环就是不满足冲突可串行的。</p></blockquote></li></ul><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul><li><p>锁的类型：</p><ul><li><p>排他锁 X：</p><p>​ 只有一个事务能读、写，其他任何事务都不能读、写。</p></li><li><p>共享锁 S：</p><p>​ 所有事务都可以读，但任何事务都不能写。</p></li><li><p>更新锁 U：</p><p>​ 初始读，以后可升级为写。</p></li><li><p>增量锁 I（后面不涉及）：</p><p>​ 增量更新（例如 $A=A+x$）区分增量更新和其他类型的更新。</p></li></ul></li><li><p>相容性矩阵：</p><ul><li><p>当某事务对一数据对象<strong>持有一种锁</strong>时，<strong>另一事务</strong>再申请对该对象加某一类型的锁，是允许（填「是」）还是不允许（填「否」）。</p></li><li><p>有更新锁的情况：</p><p>| | | 申请锁 | 申请锁 | 申请锁 |<br>| :—————: | :———: | :———: | :———: | :———: |<br>| | | 共享锁 S | 排他锁 X | 更新锁 U |<br>| 持有锁的模式 | 共享锁 S | 是 | 否 | 是 |<br>| 持有锁的模式 | 排他锁 X | 否 | 否 | 否 |<br>| 持有锁的模式 | 更新锁 U | 否 | 否 | 否 |</p></li></ul></li><li><p><strong>锁协议</strong>：</p><blockquote><p>🗡重难点，PPT 更改了很多次，也特意问了老师和同学，希望下面理解是正确的，考试大题问使用哪种锁协议，并说明理由。</p></blockquote><ul><li><p>背景：</p><p>​ 一开始并发控制的时候，读写完全没有锁，如果不是可串行化调度就会出错。</p></li><li><p>$0$ 级协议：</p><ul><li><p>所有写操作都要加排他锁，但排他锁是写完就释放，而不是直到提交事务才释放。</p><div align="center"><img src="/img/blog/ds-note-images/image-20211117001704015.png" srcset="/img/loading.gif" lazyload></div><blockquote><p>注意在排他锁期间是可以读的，读操作并没有要求上锁，也就不会因为申请有关读的锁而阻塞。</p></blockquote></li><li><p><strong>不能防止丢失修改，不可重复读，脏读</strong>三种不一致错误，<del>完全没用属于是</del>。</p><blockquote><p>分析：</p><ul><li><p>丢失修改：</p><div align="center"><img src="/img/blog/ds-note-images/image-20211117000600586.png" srcset="/img/loading.gif" lazyload></div></li><li><p>不可重复读：</p><p></p><div align="center"><img src="/img/blog/ds-note-images/image-20211117000728378.png" srcset="/img/loading.gif" lazyload><p></p></div></li><li><p>脏读：</p><p></p><div align="center"><img src="/img/blog/ds-note-images/image-20211117000704174.png" srcset="/img/loading.gif" lazyload><p></p></div></li></ul></blockquote></li></ul></li><li><p>$1$ 级协议：</p><ul><li><p>所有写操作都要加排他锁，排他锁直到提交事务才释放。</p><p></p><div align="center"><img src="/img/blog/ds-note-images/image-20211117001725343.png" srcset="/img/loading.gif" lazyload><p></p></div></li><li><p>可以<strong>防止丢失修改</strong>，因为在别人不能在你提交前进行修改（有写排他锁），这样你的修改将可以一直保留到提交。</p></li><li><p>不能防止不可重复读和脏读，理由完全同 $0$ 级协议的图，因为对读没有任何限制，你排他锁关我读操作什么事。</p></li></ul></li><li><p>$2$ 级协议：</p><ul><li><p>所有写操作同 $1$ 级协议，读操作要加<strong>共享锁</strong>，但共享锁是读完就释放，而不是直到提交事务才释放。</p><div align="center"><img src="/img/blog/ds-note-images/image-20211117001833104.png" srcset="/img/loading.gif" lazyload></div></li><li><p>可以<strong>防止丢失修改</strong>，理由同 $1$ 级协议。</p></li><li><p>可以<strong>防止脏读</strong>，因为读操作需要申请<strong>共享锁</strong>，你能申请到共享锁，是因为这个元素没有被上<strong>排他锁</strong>，所以就不会有对该元素的写操作，那么即使有回滚也和该元素无关。</p></li><li><p><strong>不能防止不可重复读</strong>，理由见下图：</p><div align="center"><img src="/img/blog/ds-note-images/image-20211117002237934.png" srcset="/img/loading.gif" lazyload></div></li></ul></li><li><p>$3$ 级协议：</p><ul><li><p>所有写操作同 $1$ 级协议，读操作要加<strong>共享锁</strong>，直到提交事务才释放。</p><div align="center"><img src="/img/blog/ds-note-images/image-20211117002930381.png" srcset="/img/loading.gif" lazyload></div></li><li><p><strong>防止丢失修改，不可重复读，脏读</strong>。</p><blockquote><p>不可重复读现象不会发生，因为不会出现上图的共享锁释放后还可以被别人修改，且我再读的现象。</p></blockquote></li></ul></li></ul></li><li><p>封锁粒度：</p><ul><li><p>定义：</p><p>​ 封锁粒度是指封锁数据对象的大小。</p></li><li><p>粒度单位：</p><p>​ 属性值 $&lt;$ 元组 $&lt;$ 元组集合 $&lt;$ 整个关系 $&lt;$ 整个 DB</p></li><li><p>由前往后：</p><p>​ <strong>并发度小，封锁开销小</strong>。</p></li></ul></li><li><p>两段封锁协议：</p><ul><li><p>每个事务分两个阶段提出加锁和解锁申请。</p><ol><li><p>增长阶段：</p><p>​ 事务可以获得锁，但不能释放锁。</p></li><li><p>缩减阶段：</p><p>​ 事务可以释放锁，但不能获得新锁。</p></li></ol><blockquote><p>等价于 PPT 中的加锁段中不能有解锁操作，解锁段中不能有加锁操作。</p><p>每个事务中所有<strong>封锁</strong>请求<strong>先于</strong>任何一个<strong>解锁</strong>请求。</p><div align="center"><img src="/img/blog/ds-note-images/image-20211117100646462.png" srcset="/img/loading.gif" lazyload></div></blockquote></li><li><p>可以保证<strong>冲突可串行性</strong>的，但是可能产生<strong>死锁</strong>。</p></li></ul></li></ul><h3 id="基于时间戳的并发控制方法🗡"><a href="#基于时间戳的并发控制方法🗡" class="headerlink" title="基于时间戳的并发控制方法🗡"></a>基于时间戳的并发控制方法🗡</h3><ul><li><p>不用锁实现并发控制。</p></li><li><p>时间戳定义：</p><p>​ <strong>时间戳</strong>是一种基于时间的标志，将某一时刻转换成的一个数值，具有<strong>唯一性和递增性</strong>。</p></li><li><p>基本思想：</p><ul><li><p>事务 $T$ 启动时，系统将该时刻作为 $T$ 的时间戳。</p></li><li><p>时间戳可以表征一系列事务执行的<strong>先后</strong>次序，时间戳小的事务先执行，时间戳大的事务后执行（但是实际上是交叉执行的）。</p></li><li><p>强制事务调度<strong>等价</strong>于一个特定顺序（即时间戳升序）的<strong>串行</strong>调度。</p></li><li><p>对于每个动作都要判断是否存在时间戳上的冲突（保证时间戳小的先操作，大的后操作）：</p><ul><li><p>如无冲突，予以执行；</p></li><li><p>如有冲突，则撤销这个动作对应的事务，并重启该事务，此时该事务获得了一个<strong>更大</strong>的时间戳，对应的动作位置会发生改变，重新做冲突判断。</p><blockquote><p>回滚 = 撤销 + 重启</p></blockquote></li></ul></li><li><p>冲突类型：</p><ol><li>时间戳大的先写（读），时间戳小的后读（写）</li><li>时间戳大的先写，时间戳小的后写</li></ol></li></ul></li><li><p>简单调度：</p><ul><li><p>对 DB 中的每个数据元素 $x$，系统保留其上的最大时间戳：</p><ul><li><p>$RT(x)$：</p><pre><code class="hljs">**读**过 $x$ 的事务中**最大的时间戳**。
</code></pre></li><li><p>$WT(x)$：</p><p>​ <strong>写</strong>过 $x$ 的事务中最大的时间戳。</p></li></ul></li><li><p>事务的时间戳 $TS(T)$</p></li><li><p>读 - 写并发（对应解决冲突类型 $1$）：</p><ul><li><p>若 $T$ 事务读 $x$，则比较 $TS(T)$ 与 $WT(x)$：</p><ul><li>若 $TS(T) \ge WT(x)$（$T$ 后进行），则允许 $T$ 操作，更改 $RT(x)$ 为 $\max\{RT(x),TS(T)\}$</li><li>否则有冲突，$T$ 回滚。</li></ul></li><li><p>若 $T$ 事务写 $x$，则比较 $TS(T)$ 与 $RT(x)$，其实同时要考虑「写 - 写」并发：</p><ul><li><p>若 $TS(T) \ge RT(x)$（$T$ 后进行），则允许 $T$ 操作，更改 $WT(x)$ 为 $TS(T)$</p><blockquote><p>这里与 PPT 不同，笔者认为 $TS(T)$ 不会比 $WT(x)$ 小（即前者一定更大），否则会发生写 - 写冲突。</p></blockquote></li><li><p>否则有冲突，$T$ 回滚。</p></li></ul></li></ul></li><li><p>写 - 写并发（对应解决冲突类型 $2$）：</p><ul><li>若 $T$ 事务写 $x$，则比较 $TS(T)$ 与 $WT(x)$：</li><li>若 $TS(T) \ge WT(x)$，则允许 $T$ 写，并且更改 $WT(x)$ 为 $TS(T)$ ；</li><li>否则有冲突，$T$ 回滚（或者采用所谓的<strong>托马斯写</strong>规则，直接<strong>忽略</strong>这个写而不是回滚整个事务，反正它已经被时间戳大的写覆盖了）。</li></ul></li><li><p>以上简单调度会产生两种不一致错误（即时间戳并没有对这两种错误加以限制，只是消除了<strong>不可重复读</strong>错误）：</p><ul><li><p>脏读：</p><div align="center"><img src="/img/blog/ds-note-images/image-20211117151647520.png" srcset="/img/loading.gif" lazyload></div><p>​ 事务 $T$ 读取了事务 $U$ 没提交的数据，在 $U$ 回滚后就变成了脏数据。</p></li><li><p>类似丢失修改的错误：</p><div align="center"><img src="/img/blog/ds-note-images/image-20211117152026245.png" srcset="/img/loading.gif" lazyload></div><p>$T$ 的写在<strong>托马斯写</strong>规则下，会被忽略，但是 $U$ 终止了，导致谁都没用写成 $x$。这种情况下理应<strong>保留 $T$ 的写</strong>。</p></li></ul></li></ul></li><li><p>优化后的时间戳调度：</p><ul><li><p>$WT(x),RT(x),TS(T)$ 与简单调度定义相同。</p></li><li><p>增加<strong>提交位</strong> $C(x)$：</p><ul><li>$C(x)=1$ 表明最近写 $x$ 的事务（时间戳较大）已经<strong>提交</strong>，就不会发生<strong>回滚</strong>现象。</li><li>$C(x)$ 的意义：将一些可能导致脏读和丢失修改的操作，<strong>延迟</strong>到确定提交（或回滚）后再处理。</li></ul></li><li><p>对来自事务 $T$ 的读写请求，调度器可以：</p><ul><li>同意请求</li><li>回滚</li><li><strong>推迟</strong>，并在以后决定是回滚还是要重新判断（简单调度无此项选择）</li></ul></li><li><p>若 $T$ 事务读 $x$，则比较 $TS(T)$ 与 $WT(x)$：</p><ul><li><p>若 $TS(T) \ge WT(x)$（$T$ 后进行），理论上应该允许 $T$ 操作，但要判断最近的写是否提交：</p><ul><li><p>$C(x)=1$，说明已提交，不会回滚，同意请求，可以放心的读，不会是脏数据。更改 $RT(x)$ 为 $\max\{RT(x),TS(T)\}$</p></li><li><p>推迟 $T$ 直到 $C(x)=1$ 或写 $x$ 的事务终止</p><blockquote><p>前一种情况仍可以放心读，后一种情况就不能读了，需要回滚。</p></blockquote></li></ul></li><li><p>否则有冲突，$T$ 回滚。</p></li></ul></li><li><p>若 $T$ 事务写 $x$，则比较 $TS(T),RT(x),WT(x)$，即同时要考虑「写 - 读」和 「写 - 写」并发：</p><ul><li><p>若 $TS(T) \ge RT(x)$ 且 $TS(T) \ge WT(x)$，则允许 $T$ 操作，更改 $WT(x)$ 为 $TS(T)$。</p></li><li><p>如果 $TS(T)\ge RT(x)$，但是 $TS(T)&lt;WT(x)$，就要判断是否已提交</p><ul><li><p>$C(x)=1$，那么前一个 $x$ 的写已提交，则忽略 $T$ 的写（托马斯写规则）。</p></li><li><p>否则推迟 $T$ 直到 $C(x)=1$ 或写 $x$ 的事务终止。</p><blockquote><p>如果是前一种情况就会忽略 $T$ 的写。后一种情况比较复杂，我觉得不能简单地通过 $T$ 的写请求：</p><ul><li>假设现在有事务 $S_1,S_2,T$，时间戳排序为 $T&lt;S_1&lt;S_2$，写 $x$ 的顺序为 $S_1,S_2,T$。此时 $WT(x)=TS(S_2)$，且 $S_1$ 已提交，$S_2$ 未提交。</li><li>$T$ 的写请求会进入推迟判断，即使最后 $S_2$ 回滚了，但是由于 $S_1$ 的写已经提交，也应该忽略 $T$ 的写。</li><li>PPT 对这种情况没有处理办法（如何感知 $S_1$ 的存在），所以这只是笔者的一种疑惑。</li></ul></blockquote></li></ul></li><li><p>否则有冲突，$T$ 回滚。</p></li></ul></li><li><p>假设调度器收到提交 $T$ 的请求：</p><ul><li>它必须找到 $T$ 所写的所有数据库元素 $x$, 并置 $C(x)=1$。</li><li>等待 $x$ 被提交的读动作可以继续读，写动作要被忽略。</li></ul></li><li><p>假设调度器收到终止 $T$ 的请求：</p><p>​ 任何等待 $T$ 所写元素 $x$ 的事务判断这一动作在 $T$ 的写被终止后是否合法。</p><blockquote><p>具体怎么判断就像上面说的一样还缺少一些信息作为判断依据。</p></blockquote></li></ul></li></ul><h3 id="基于有效性确认的并发控制方法"><a href="#基于有效性确认的并发控制方法" class="headerlink" title="基于有效性确认的并发控制方法"></a>基于有效性确认的并发控制方法</h3><ul><li><p>基本思想：</p><ul><li><p>事务在启动时刻被赋予唯一的时间戳，以示其启动顺序。</p></li><li><p>RS(T)：</p><p>​ 事务 T 读数据的集合。</p></li><li><p>WS(T)：</p><p>​ 事务 T 写数据的集合。</p></li><li><p>事务分三个阶段进行：</p><ul><li><p>读阶段：</p><p>​ 事务从数据库中读取读集合中的<strong>所有元素</strong>，在其局部地址空间<strong>计算</strong>它将要<strong>写</strong>的所有值。</p></li><li><p>有效性确认阶段：</p><p>​ 调度器通过比较该事务与<strong>其它事务的读写集合</strong>来确认该事务的有效性。</p></li><li><p>写阶段：</p><p>​ 通过有效性确认后，该事务立刻往数据库中写入其写集合中元素的值（这个过程要判断「读 - 写」和「写 - 写」冲突）。</p></li></ul></li><li><p>并发事务串行的顺序即事务有效性确认的顺序。</p></li></ul></li><li><p>集合定义：</p><ul><li>START 集合：<ul><li>已经开始但<strong>尚未完成有效性确认</strong>的事务集合。</li><li>对此集合中的事务，调度器维护 START(T)，即 T 开始的时间。</li></ul></li><li>VAL 集合：<ul><li>已经<strong>确认有效性</strong>但<strong>尚未完成写阶段</strong>写的事务。</li><li>对此集合中的事务，调度器维护 START(T) 和 VAL(T)，即 T 确认的时间。</li></ul></li><li>FIN 集合：<ul><li>已经<strong>完成写阶段</strong>的事务。</li><li>对此集合中的事务，调度器记录 START(T)，VAL(T) 和 FIN(T)，即 T 完成的时间。</li></ul></li></ul></li><li><p>有效性确认规则</p><ul><li><p>读 - 写并发：</p><p>​ 对于所有<strong>已经过有效性确认</strong>，且在 T 开始前<strong>没有完成</strong>的 U，即对于满足 FIN(U)&gt;START(T) 的 U，检测 RS(T) $\cap$ WS(U) 是否为空：</p><ul><li>若为空，则确认 T。</li><li>否则，不予确认 T。</li></ul></li><li><p>写 - 写并发：</p><p>​ 对于所有已经过有效性确认，且在 T 有效性确认前没有完成的 U，即对于满足 FIN(U)&gt;VAL(T) 的 U，检测 WS(T) $\cap$ WS(U) 是否为空：</p><ul><li>若为空，则确认 T。</li><li>否则，不予确认 T。</li></ul></li></ul></li><li><p>例子：</p><div align="center"><img src="/img/blog/ds-note-images/image-20211117183843703.png" srcset="/img/loading.gif" lazyload></div></li></ul><h2 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h2><h3 id="故障恢复的宏观思路"><a href="#故障恢复的宏观思路" class="headerlink" title="故障恢复的宏观思路"></a>故障恢复的宏观思路</h3><ul><li><p>故障类型：</p><ul><li><p>事务故障：</p><p>​ 某一个程序（事务）自身运行错误所引起的故障，影响该程序（事务）本身，只需要撤销事务和重做事务来进行恢复。</p></li><li><p>系统故障：</p><p>​ 由于掉电、非正常关机等所引起的故障。影响<strong>正在运行的事务</strong>以及数据库<strong>缓冲区</strong>（数据库缓冲区涉及正在运行和已经运行的事务）。</p></li><li><p>介质故障：</p><p>​ 由于介质（数据库）损坏等所引起的故障。影响是全面的，既影响内存中的数据, 又影响介质中存储的数据。</p></li></ul></li><li><p>故障会破坏事务的原子性，一致性和持久性。</p><blockquote><p>隔离性因为故障发生后不能执行事务，事务肯定是越少越不容易破坏隔离性。</p></blockquote></li><li><p>故障恢复意义：</p><p>​ 把 DB 由<strong>当前不正确状态</strong>恢复到<strong>已知正确</strong>的某一状态。</p></li><li><p>需要保证事务的：</p><ul><li><p>原子性：</p><p>​ 事务的所有操作，要么全都执行，要么全都不执行。</p></li><li><p>持久性：</p><p>​ 已提交的事务对数据库产生的影响是持久的（缓冲区内容保证写回磁盘），未提交的事务对数据库不应有影响（缓冲区内容不能影响磁盘）。</p></li></ul></li><li><p>运行日志：</p><ul><li><p>运行日志是 DBMS 维护的一个文件，该文件以流水方式记录了每一个事务对数据库的每一次操作及操作顺序。</p><blockquote><p>MOOC 上题目说「日志文件是用于记录对数据的所有更新操作」。</p></blockquote></li><li><p>运行日志直接写入介质存储上，会保持正确性。</p></li><li><p>当事务对数据库进行操作时，<strong>先写运行日志</strong>。写成功后，再与数据库缓冲区进行信息交换。</p><div align="center"><img src="/img/blog/ds-note-images/image-20211117190515585.png" srcset="/img/loading.gif" lazyload></div></li><li><p>保存信息：</p><ul><li>&lt; Start T &gt;，表示事务 T 已经开始</li><li>&lt; Commit T &gt;，表示事务 T 成功完成</li><li>&lt; Abort T &gt;，事务 T 未成功，被中止</li><li>&lt; T, X, $v_1$ &gt; 或者 &lt; T, X, $v_2$ &gt; 或者 &lt; T, X, $v_1$, $v_2$ &gt;（对应 Undo 型日志，Redo 型日志，Undo/Redo 型日志）</li><li>表示事务 T 改变了数据库元素 X，X 原来的值为 $v_1$（X 的旧值），X 新的值为 $v_2$。</li></ul></li></ul></li><li><p>事务故障的恢复：</p><ul><li><p>事务故障可通过重做事务（Redo）和撤消事务（Undo）来恢复。</p></li><li><p>重做事务可保证<strong>已提交事务的持久性</strong>，而撤销事务则消除<strong>未提交事务</strong>的影响。</p><blockquote><p>已提交事务的写数据，可能只是放在缓冲区中，还没有写入磁盘，当发生故障时将丢失修改。所以必须通过 Redo 重新把修改写磁盘。</p></blockquote></li><li><p>DBMS 在运行日志中定期设置及更新<strong>检查点</strong>（checkpoint）：</p><ul><li>在检查点时，DBMS 强制使 DB 缓冲区中的内容与 DB 中的内容保持一致，即将 DB 缓冲区更新的所有内容写回 DB 中。</li><li>保证在检查点之前内存中数据与 DB 中数据是<strong>保持一致</strong>的，即检查点<strong>之前结束</strong>的事务不需要恢复（已经写回 DB）。</li><li>检查点之后<strong>结束或发生</strong>的事务需要依据<strong>运行日志</strong>进行恢复（不能确定是否写回 DB）：<strong>故障点前结束的重做，故障点时刻未结束的撤消</strong>。</li></ul><div align="center"><img src="/img/blog/ds-note-images/image-20211117200855482.png" srcset="/img/loading.gif" lazyload></div></li><li><p>通过副本实现<strong>介质故障</strong>恢复：</p><ul><li>在某一时刻（转储点），对数据库在其他介质存储上产生的另一份等同记录，即副本。</li><li>当 DB 发生故障时用副本替换，且由于介质故障影响很大，替换后还需要依据<strong>运行日志</strong>进行恢复。</li><li>转储点的设置：<ul><li>过频会影响系统工作效率。</li><li>过疏会造成运行日志过大，也影响系统运行性能（转储点前的日志不需要保存）。</li><li>备份转储周期与运行日志的大小密切相关，合理设置。</li></ul></li></ul></li></ul></li></ul><h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><ul><li><p>事务和缓冲区的操作：</p><ul><li><p>READ(X,t)：</p><p>​ 将元素 X 读到事务的<strong>局部变量</strong> t 中。</p></li><li><p>WRITE(X,t)：</p><p>​ 将事务局部变量 t 写回元素 X。</p></li><li><p>INPUT(X)：</p><p>​ 将元素 X 从磁盘读入到内存缓冲区中。</p></li><li><p>OUTPUT(X)：</p><p>​ 将元素 X 从缓冲区写<strong>回到磁盘</strong>中。</p></li><li><p>COMMIT：</p><p>​ 事务提交。</p></li><li><p>ABORT：</p><p>​ 事务撤销。</p></li></ul></li><li><p><strong>缓冲区策略</strong>🤏🗡：</p><ul><li><p>Force：</p><p>​ 缓冲区中的数据最晚在 commit 的时候写入磁盘。</p></li><li><p>No Force：</p><p>​ 缓冲区中的数据可以一直保留，在 commit 之后过一段时间再写入磁盘。</p><blockquote><p>如果在系统崩溃的时候还没写入到磁盘，需要 Redo。</p></blockquote></li><li><p>Steal：</p><p>​ 允许在事务 commit 之前把缓冲区中的数据写入磁盘（先偷偷写一点）。</p><blockquote><p>此时若系统在 commit 之前崩溃时，已经有数据写入到磁盘了，要恢复到崩溃前的状态，需要 Undo。</p></blockquote></li><li><p>No Steal：</p><p>​ 不允许在事务 commit 之前把缓冲区中的数据写入磁盘。</p><blockquote><p>Steal/No Steal 关心的缓冲区的数据最早什么时候开始写磁盘。</p><p>Force/No Force 关心的缓冲区的数据最晚什么时候要写回磁盘。</p></blockquote></li><li><p>各种搭配的效率和策略比较：</p><p>​ 最灵活且常用 Steal + No Force</p><div align="center"><img src="/img/blog/ds-note-images/image-20211117201057674.png" srcset="/img/loading.gif" lazyload></div></li></ul></li></ul><h3 id="三种日志类型"><a href="#三种日志类型" class="headerlink" title="三种日志类型"></a>三种日志类型</h3><blockquote><p>这一节老师讲的很快，很多地方存在疑惑（为什么要执行到哪个地方，检查点实际的作用）都不太清楚，只能盲目搬运 PPT 了😫。</p></blockquote><ul><li><p>判断确定每一个事务是否已完成：</p><ul><li><p>已完成（Redo 关注的）：</p><p>​ &lt; START T &gt;$\cdots$&lt; COMMIT T &gt;</p></li><li><p>未完成（Undo 关注的）：</p><ul><li>&lt; START T &gt;$\cdots$&lt; ABORT T &gt;</li><li>&lt; START T &gt;$\cdots$</li></ul></li></ul></li><li><p>检查点类型：</p><ul><li>静止检查点：<ul><li>周期性地对日志设置检查点。</li><li><strong>停止接受</strong>新的事务，等到所有当前活跃事务提交或终止，并在日志中写入了 COMMIT 或 ABORT 记录。</li><li>最后将日志刷新到磁盘，写入日志记录 &lt; CKPT &gt;，并再次刷新日志。</li></ul></li><li>非静止检查点：<ul><li>在设置检查点时不必关闭系统，<strong>允许新事务</strong>进入。</li><li>写入一条 &lt; START CKPT($T_1,\cdots,T_k$) &gt;，其中 $T_1,\cdots,T_k$ 是所有<strong>活跃的未结束</strong>的事务。</li><li>继续正常的操作，直到 $T_1,\cdots,T_k$ 都完成时，写入 &lt; END CKPT &gt;。</li></ul></li></ul></li><li><p>Undo 型日志：</p><ul><li><p>对应 Steal + Force 策略</p></li><li><p>对于任一事务 T，按下列顺序向磁盘输出 T 的日志信息：</p><ul><li><p>首先，&lt; T, X, $v$ &gt; 被写到日志中，$v$ 为 X 的旧值。</p></li><li><p>其次，OUTPUT(X)</p></li><li><p>最后，&lt; COMMIT T &gt; 或 &lt; ABORT T &gt;被写到日志中</p><blockquote><p>将事务改变的<strong>所有数据写到磁盘前</strong>不能<strong>提交</strong>该事务。</p></blockquote></li></ul></li><li><p>🗡从日志的尾部开始按日志记录的反序，处理每一日志记录，撤销<strong>未完成事务</strong>的所有修改，处理到检查点为止。</p></li><li><p>如果是在 &lt; COMMIT T &gt; 后发生故障，无需对 T 做任何处理，因为 T 已经完成它要做的所有动作了，满足原子性。</p></li><li><p>反之，T 所有动作带来的影响都要撤销掉，通过 &lt; T, X, $v$ &gt; 还原。</p></li><li><p>可能频繁地写磁盘，导致性能下降。</p></li></ul></li><li><p>Redo 型日志：</p><ul><li><p>对应 No Steal + No Force 策略</p></li><li><p>对于任一事务 T，按下列顺序向磁盘输出 T 的日志信息：</p><ul><li><p>首先，&lt; T, X, $v$ &gt; 被写到日志中，$v$ 为 X 的新值。</p></li><li><p>其次，&lt; COMMIT T &gt; 或 &lt; ABORT T &gt;被写到日志中</p></li><li><p>最后，OUTPUT(X)</p><blockquote><p>与 Undo 写入日志的顺序不一样。</p></blockquote></li></ul></li><li><p>从日志的起始位置（检查点）开始按日志记录的正序处理每一日志记录，重做<strong>已提交事务</strong>的所有修改。</p><blockquote><p>在检查点处，要将之前所有已提交的事务写回磁盘（Undo 不用是因为它的 OUTPUT 在提交前做完）。</p></blockquote></li><li><p>如果是在 &lt; COMMIT T &gt; 前发生故障，无需对 T 做任何处理，因为 T 并没有将影响写入数据库（OUTPUT 还没执行）。</p></li><li><p>反之，通过 &lt; T, X, $v$ &gt; 更新数据库。</p></li><li><p>数据必须在 Commit 后才可见，灵活性差。</p></li></ul></li><li><p>Undo/Redo 型日志：</p><ul><li><p>对应 Steal + No Force 策略</p></li><li><p>对于任一事务 T，按下列顺序向磁盘输出 T 的日志信息：</p><ul><li><p>首先，&lt; T, X, $u$, $v$ &gt; 被写到日志中，$u$ 为 X 的旧值，$v$ 为 X 的新值。</p></li><li><p>（&lt; COMMIT T &gt; 或 &lt; ABORT T &gt;）或 OUTPUT(X) 被写到日志中</p></li><li><p>OUTPUT(X) 或（&lt; COMMIT T &gt; 或 &lt; ABORT T &gt;）被写到日志中</p><blockquote><p>无所谓 OUTPUT 和 COMMIT 谁先写，很灵活。</p></blockquote></li></ul></li><li><p>先<strong>自后向前</strong>地<strong>撤销</strong>所有<strong>未提交</strong>的事务，再<strong>自前向后</strong>地<strong>重做</strong>所有<strong>已提交</strong>的事务。</p></li></ul></li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" class="category-chain-item">课程笔记</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Hitsz/">#Hitsz</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">#数据库</a></div></div><div class="license-box my-3"><div class="license-title"><div>数据库系统笔记</div><div>https://ailanxier.top/Database_System</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Zeyu Dong</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年1月17日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/git" title="Git 学习笔记"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Git 学习笔记</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/Operating_System" title="操作系统笔记"><span class="hidden-mobile">操作系统笔记</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments("#valine",function(){Fluid.utils.createScript("https://lib.baomitu.com/valine/1.4.16/Valine.min.js",function(){var i=Object.assign({appId:"RPMS8nldJp0JoyyYWovwKE7g-gzGzoHsz",appKey:"XyHCoNwPhJnfnVvl8QA63j3L",path:"window.location.pathname",placeholder:null,avatar:"retro",meta:["nick","mail","link"],requiredFields:[],pageSize:10,lang:"zh-CN",highlight:!1,recordIP:!1,serverURLs:"",emojiCDN:null,emojiMaps:null,enableQQ:!1},{el:"#valine",path:window.location.pathname});new Valine(i),Fluid.utils.waitElementVisible("#valine .vcontent",()=>{var i="#valine .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(i),Fluid.plugins.fancyBox(i)})})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.13.10/mermaid.min.js",function(){mermaid.initialize({theme:"default"})})</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,t=t.getElementById("subtitle");t&&e&&e(t.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-t}),0<o.find(".toc-list-item").length&&o.css("visibility","visible"))})</script><script>!function(){var n,i=CONFIG.code_language.enable&&CONFIG.code_language.default,t=CONFIG.copy_btn;(i||t)&&(n="",n+='<div class="code-widget">',n+="LANG",n+="</div>",jQuery(".markdown-body pre").each(function(){var e,a=jQuery(this);0<a.find("code.mermaid").length||0<a.find("span.line").length||(e="",i&&(e=CONFIG.code_language.default,0<a[0].children.length&&2<=a[0].children[0].classList.length&&a.children().hasClass("hljs")?e=a[0].children[0].classList[1]:a[0].getAttribute("data-language")?e=a[0].getAttribute("data-language"):a.parent().hasClass("sourceCode")&&0<a[0].children.length&&2<=a[0].children[0].classList.length?(e=a[0].children[0].classList[1],a.parent().addClass("code-wrapper")):a.parent().hasClass("markdown-body")&&0===a[0].classList.length&&a.wrap('<div class="code-wrapper"></div>'),e=e.toUpperCase().replace("NONE",CONFIG.code_language.default)),a.append(n.replace("LANG",e).replace('code-widget">',(a=a[0],(0<=Fluid.utils.getBackgroundLightness(a)?"code-widget-light":"code-widget-dark")+(t?' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>':' code-widget">')))),t&&Fluid.utils.createScript("https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js",function(){new window.ClipboardJS(".copy-btn",{target:function(e){for(var a=e.parentNode.childNodes,n=0;n<a.length;n++)if("CODE"===a[n].tagName)return a[n]}}).on("success",function(e){e.clearSelection(),e.trigger.innerHTML=e.trigger.innerHTML.replace("icon-copy","icon-success"),setTimeout(function(){e.trigger.innerHTML=e.trigger.innerHTML.replace("icon-success","icon-copy")},2e3)})}))}))}()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o,n=[];for(o of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))n.push(".markdown-body > "+o.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))})</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script>MathJax={tex:{inlineMath:{"[+]":[["$","$"]]}},loader:{load:["ui/lazy"]},options:{renderActions:{findScript:[10,n=>{document.querySelectorAll('script[type^="math/tex"]').forEach(e=>{var t=!!e.type.match(/; *mode=display/);const a=new n.options.MathItem(e.textContent,n.inputJax[0],t);t=document.createTextNode("");e.parentNode.replaceChild(t,e),a.start={node:t,delim:"",n:0},a.end={node:t,delim:"",n:0},n.math.push(a)})},"",!1],insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(e=>{let t=e.parentNode;"li"===t.nodeName.toLowerCase()&&t.parentNode.classList.add("has-jax")})},"",!1]}}}</script><script src="https://lib.baomitu.com/mathjax/3.2.0/es5/tex-svg-full.js"></script><script src="/js/local-search.js"></script><script defer src="/js/leancloud.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ["$","$"], ["\\(","\\)"] ], skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'], processEscapes: true } }); MathJax.Hub.Queue(function() { var all = MathJax.Hub.getAllJax(); for (var i = 0;
    i
    < all.length; ++i) all[i].SourceElement().parentNode.className +=' has-jax' ; });</script><script id="MathJax-script" async src="https://lib.baomitu.com/npm/mathjax@3/es5/tex-svg-full.js"></script></body></html>