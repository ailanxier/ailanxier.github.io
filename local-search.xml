<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>FHE学习笔记 #1 离散数学名词</title>
    <link href="/FHE-1-Discrete%20mathematics.html"/>
    <url>/FHE-1-Discrete%20mathematics.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>参考教材：</p><p>邓少强，朱富海：《抽象代数》，北京，科学出版社，2017 年</p><p>文章使用 wolai 编写并导出，在 <a href="https://www.wolai.com/ailanxier/wBn2PmNvMx2BM8yeM7tgr9">wolai</a> 中观看效果更好，有颜色高亮和实时更新</p>          </div><ul><li><p>群 Group</p><p>对于非空集合 $G$，$\circ$ 是它的一个代数运算，如果满足以下条件：</p><ul><li><p><strong>结合律</strong>成立，即对 $G$ 中任意元素 $a, b, c$ 都有</p><script type="math/tex; mode=display">(a \circ b) \circ c=a \circ(b \circ c)</script></li><li><p>$G$ 中有元素 $e$，叫做 $G$ 的<strong>左单位元</strong>，它对 $G$ 中每个元素 $a$ 都有</p><script type="math/tex; mode=display">e \circ a=a</script></li><li><p>对 $G$ 中每个元素 $a$，在 $G$ 中都有元素 $a^{-1}$，叫做 $a$ 的<strong>左逆元</strong> (Inverse)，使</p><script type="math/tex; mode=display">a^{-1} \circ a=e</script></li></ul><p>则称 $G$ 对代数运算 $\circ$ 作成一个<strong>群</strong>。</p><p>群是一个满足封闭性、满足<strong>结合律、有单位元、有逆元</strong>的二元运算的代数结构。</p><p>单位元，也叫幺元，英文 Identity Element。</p></li><li><p>半群 Semi-group</p><p>设 $S$ 是一个非空集合，如果它有一个代数运算满足<strong>结合律</strong>，则称 $S$ 是一个半群。</p></li><li><p>子群</p><ul><li><p>设 $H$ 是群 $G$ 的一个非空子集，如果 $H$ 对于 $G$ 的运算也构成群，则称 $H$ 为 $G$ 的子群，记作 $H&lt;G$</p></li><li><p>设 $m \in \mathbb{N}$，则 $m \mathbb{Z}=\{m n \mid n \in \mathbb{Z}\}$ 是 $\mathbb{Z}$ 的子群</p></li><li><p>$\mathbb{Z}$ 的任何子群都形如 $m \mathbb{Z}, m \in \mathbb{N}$.</p></li></ul><p>设 $G$ 为群，$a \in G$，记 $a^0=e$</p><ul><li><p>对 $k \in \mathbb{N}$，令 $a^k=a \cdot a^{k-1},a^{-k}=\left(a^{-1}\right)^k$ </p></li><li><p>对 加法群 $G$，$a^n$ 通常记为 $n a$</p></li><li><p>$\langle a\rangle=\left\{a^n \mid n \in \mathbb{Z}\right\}$ 是 $G$ 的子群，称为 $a$ 生成的子群，子群的阶也称为 $a$ 的阶</p></li></ul><p>更一般地，设 $S$ 是群 $G$ 中一个非空子集，令 $S^{-1}=\left\{a^{-1} \mid a \in S\right\}$，记</p><script type="math/tex; mode=display">\langle S\rangle=\{x_1 \cdots x_m \mid m \in \mathbb{N}, x_1, \cdots, x_m \in S \cup S^{-1}\}</script><p> $\langle S\rangle$ 是 $G$ 的一个子群，称为 $S$ 生成的子群。</p></li><li><p>陪集 Coset</p><p>设 $H$ 是群 $G$ 的一个子群，$a \in G$。则称群 $G$ 的子集</p><script type="math/tex; mode=display">a H=\{a x \mid x \in H\}</script><p>为群 $G$ 关于子群 $H$ 的一个左陪集。而称</p><script type="math/tex; mode=display">H a=\{x a \mid x \in H\}</script><p>为群 $G$ 关于子群 $H$ 的一个右陪集。</p><blockquote><p>以上叙述中都把群 $G$ 中的运算记作乘法，并且省去了运算符。</p><p>如果群 $G$ 中的运算记作加法，则以 $a$ 为代表的左陪集应该记作 </p><script type="math/tex; mode=display">a+H=\{a+h|h\in H\}</script></blockquote></li><li><p>同余类 Congruence Class（或剩余类 Residue Class）</p><blockquote><p><a href="https://en.wikipedia.org/wiki/Modular_arithmetic" title="Modular arithmetic - Wikipedia">Modular arithmetic - Wikipedia</a></p></blockquote><ul><li><p>模 $m$ 同余是一个等价关系，由此确定了整数上的一个分类</p></li><li><p>对于 $\forall a\in [0,m-1]$，集合 $a+m\mathbb{Z}$ 中的所有数模 $m$ 同余，这个集合叫做 $a$ 的等价类，也叫同余类，记作 $[a]\text{~or~}\overline{a}_m$</p></li><li><p>满足：</p><script type="math/tex; mode=display">\mathbb{Z}=(0+m \mathbb{Z}) \cup(1+m \mathbb{Z}) \cup \cdots \cup((m-1)+m \mathbb{Z})=\{\overline0+\overline1+\cdots+\overline {m-1} \}</script></li></ul></li><li><p>最小剩余系（Residue Systems）</p><p>每个等价类通常用他们的最小非负元素来表示，这些最小代表的集合就是模 $m$所得的余数域，也叫最小的剩余系 $\mathbb{Z}_m=\{0,1,\cdots,m-1\}$</p></li><li><p>商集 Equivalence Set</p><p>商集是集合的一个划分，设 $\sim$ 为集合 $S$ 的一个等价关系，则 $S/\sim$ 称为商集，是等价类构成的集合。</p></li><li><p>正规子群 Normal Subgroup 和商群 Quotient Group</p><blockquote><p><a href="https://en.wikipedia.org/wiki/Quotient_group#Definition" title="Quotient group - Wikipedia">Quotient group - Wikipedia</a></p></blockquote><ul><li><p>设 $H$ 是群 $G$ 的一个子群，如果 $\forall a\in G,~aH=Ha$，则称 $H$ 为 $G$ 上的正规子群，记作 $H\lhd G$</p></li><li><p>设 $H$ 是群 $G$ 的一个正规子群，定义 $G/H=\{aH|a\in G\}$，对于陪集乘法</p><script type="math/tex; mode=display">(aH)(bH)=a(Hb)H=(ab)HH=abH</script><p>构成一个陪集为元素的群，叫做商群</p></li><li><p>由于 $\{\mathbb{Z} ;+\}$ 是交换群，故其任一子群 $m \mathbb{Z}$ 是 $\mathbb{Z}$ 的正规子群，所以有商群：</p><script type="math/tex; mode=display">\begin{aligned}&\mathbb{Z} / m \mathbb{Z}= \begin{cases}\mathbb{Z}, & m=0 \\ \{\overline{0}, \overline{1}, \cdots, \overline{m-1}\}, & m \neq 0\end{cases}\\&m\mathbb{Z}=\overline 0\\&\overline a=a+m\mathbb{Z}=a\circ m\mathbb{Z}\end{aligned}</script><p>注意商群元素之间的运算为模 $m$ 加法，这个群通常简记为 $\mathbb{Z}_m$（但是这个记号容易弄混），称为模 $m$ 的剩余类加群。</p></li><li><p>当商群元素间的运算为模 $m$ 乘法，这个商群记为 $(\mathbb{Z} / m \mathbb{Z})^\times$，不同于加群，这个群的大小为欧拉函数 $\varphi(m)$，即集合 $\{1,\cdots,m-1\}$ 中与 $m$ 互质的数的个数，则</p><script type="math/tex; mode=display">\begin{aligned}&(\mathbb{Z} / m \mathbb{Z})^\times=  \{\overline p|~\overline p\in(\mathbb{Z} / m \mathbb{Z})^+,\gcd(p,m)=1\},  m \neq 0\\&\overline 1 \text{~is~the~identity}\\&\overline a\times \overline b=\overline{a\times b}\end{aligned}</script><blockquote><p><a href="https://en.wikipedia.org/wiki/Multiplicative_group_of_integers_modulo_n" title="Multiplicative group of integers modulo n - Wikipedia">Multiplicative group of integers modulo n - Wikipedia</a></p><p><a href="http://www.math.columbia.edu/\~rf/numbertheory2.pdf" title="http://www.math.columbia.edu/\~rf/numbertheory2.pdf">http://www.math.columbia.edu/~rf/numbertheory2.pdf</a></p><p>其中单位元为 $\overline 1$ ，一个元素 $\overline a$ 的最小非负代表数 $a$ 的逆元 $a^{-1}$ 要满足同余方程 $aa^{-1} \equiv  1(\mathrm{mod}~m)$，即方程 $ax + my=  1$ 要有整数解 $x,y$。</p><p>根据裴蜀（贝祖）定理的推论，$𝑎,𝑏$ 互质的充要条件是存在整数 $𝑥,𝑦$ 使 $𝑎𝑥+𝑏𝑦=1$，所以 $\mathbb{Z}_m^\times$ 中的最小非负代表数都是和 $m$ 互质的数，否则没有逆元。</p></blockquote></li></ul></li><li><p>环 Ring</p><p>设非空集合 $R$ 有两个代数运算，一个叫做加法（一般用 $+$ 表示），另一个叫做乘法。如果：</p><ul><li><p>$R$ 对加法作成一个交换群</p></li><li><p>$R$ 对乘法满足<strong>结合律（即半群）</strong></p></li><li><p>乘法对加法满足<strong>左右分配律</strong>：</p><script type="math/tex; mode=display">\forall a,b,c\in R,\quad a(b+c)=a b+a c, \quad(b+c) a=b a+c a</script></li></ul><p>则称 $R$ 对这两个代数运算作成一个环。</p><blockquote><p>若对乘法满足交换律，则称为可换环 Commutative Ring</p></blockquote></li><li><p>理想 Ideal</p><blockquote><p><a href="https://en.wikipedia.org/wiki/Ideal_\(ring_theory\">Ideal (ring theory) - Wikipedia</a> “Ideal (ring theory) - Wikipedia”)</p></blockquote><ul><li><p>设 $R$ 为环，$I$ 为 $R$ 的子环，如果 $I$ 满足条件「$a \in I, x \in R \Rightarrow x a \in I$」，则称 $I$ 为 $R$ 的左理想</p></li><li><p>如果 $I$ 满足条件「$a \in I, y \in R \Rightarrow a y \in I$」，则称 $I$ 为 $R$ 的右理想</p></li><li><p>若一个子环既是左理想，又是右理想，则称为双边理想 Two-sided Ideal</p></li></ul></li><li><p>主理想 Principal Ideal</p><blockquote><p><a href="https://en.wikipedia.org/wiki/Principal_ideal" title="Principal ideal - Wikipedia">Principal ideal - Wikipedia</a></p></blockquote><ul><li><p>主理想是环 $R$ 的一个由单个元素 $a$ 生成的理想 $I$，分为左/右/双边主理想</p></li><li><p>左主理想严谨表示为（右类似）：</p><script type="math/tex; mode=display">I=Ra=\{ra|r\in R\}</script></li><li><p>双边主理想严谨表示为（没太看懂，国内博客好像不太一致）：</p><script type="math/tex; mode=display">I=R a R=\left\{r_{1} a s_{1}+\ldots+r_{n} a s_{n}| r_{1}, s_{1}, \ldots, r_{n}, s_{n} \in R\right\}</script></li><li><p>对于可换环，以上三种主理想是一样的，可以记由 $a$ 生成的环为 $I=\langle a\rangle \text{~or~} I=(a)$</p></li></ul><blockquote><p>$\mathbb{Z}$ 的主理想就是 $\langle m \rangle = m\mathbb{Z}$</p></blockquote></li><li><p>商环 Quotient Ring（或剩余类环 Residue Class Ring）</p><blockquote><p><a href="https://en.wikipedia.org/wiki/Quotient_ring" title="Quotient ring - Wikipedia">Quotient ring - Wikipedia</a></p></blockquote><p>设 $R$ 是一个环，$I$ 是 $R$ 的理想。考虑加法群 $\{R ;+\}$ 对于子群 $I$ 的商群 $R / I$，将 $a \in R$ 所在的等价类记为 $a+I$。在 $R / I$ 上定义乘法如下:</p><script type="math/tex; mode=display">(a+I)(b+I)=a b+I .</script><p>则集合 $R / I$ 对于商群的加法以及上述乘法运算构成一个环，称为 $R$ 对于理想 $I$ 的商环。</p><blockquote><p>$\mathbb{Z}/m\mathbb{Z}$ 就是一个商环，当 $m&gt;0$ 时，称 $\mathbb{Z}/m\mathbb{Z}$ 为 $\mathbb{Z}$ 模 $m$ 的剩余类环</p></blockquote></li><li><p>多项式环 Polynomial ring</p><blockquote><p>[<a href="https://en.wikipedia.org/wiki/Polynomial\_ring](">https://en.wikipedia.org/wiki/Polynomial\_ring](</a></p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>科研笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>全同态加密</tag>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 学习笔记</title>
    <link href="/git.html"/>
    <url>/git.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>资料主要来自：</p><ol><li><a href="https://git-scm.com/book/zh/v2">ProGit 2nd Edition (2014) 中文版</a></li><li><a href="https://git-scm.com/docs">Git Reference</a></li><li><a href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Branching 中文网站</a></li></ol><p>基于目前普遍使用的 Git 最新版本，记录了一些较为有用的 Git 科技。</p><p>推荐到 <a href="https://github.com/ailanxier/ailanxier.github.io/releases/tag/git">Github 仓库</a> 下载该博客的 PDF 版本查看。</p>          </div><h2 id="Git-基本信息"><a href="#Git-基本信息" class="headerlink" title="Git 基本信息"></a>Git 基本信息</h2><h3 id="Git-特性"><a href="#Git-特性" class="headerlink" title="Git 特性"></a>Git 特性</h3><ul><li><p>Git 和其它版本控制系统的主要差别在于对待数据的方法：</p><ul><li><p>其他系统：</p><p>​    存储每个文件与初始版本的差异，如图：</p><div align="center"><img src="../img/blog/git-note-images/delta.png"></div></li><li><p>Git：</p><p>​    存储项目随时间改变的<strong>快照</strong>，把数据看作是对小型文件系统的一组快照。每次 commit 或保存项目状态时，Git 对当时的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改，Git <strong>不再重新存储</strong>该文件，而是只保留一个链接指向之前存储的文件。Git 对待数据更像是一个<strong>快照流</strong>：</p><div align="center"><img src="../img/blog/git-note-images/snapshots.png"></div></li></ul></li><li><p>Git 保护文件完整性：</p><ul><li>Git 中所有数据在存储前都计算<strong>校验和</strong>，不能在不改变校验和的情况下修改文件。</li><li>计算校验和的机制叫做 <strong>SHA-1 散列</strong>（hash，哈希），由 40 个十六进制字符组成。</li><li>Git 以校验和来引用文件，而不是文件名。</li></ul></li><li><p>Git 一般只增加数据，难以清除数据库中数据，使得 Git 操作一般都是<strong>可逆的</strong></p></li></ul><h3 id="「三棵树」-🌳"><a href="#「三棵树」-🌳" class="headerlink" title="「三棵树」 🌳"></a>「三棵树」 🌳</h3><p>Git 项目的三个工作区域（文件的集合）：</p><ul><li><strong>Git 仓库</strong>，.git directory，保存项目的元数据和对象数据库的地方。</li><li><strong>暂存区域</strong>，或 Index，或 Staging Area，保存了<strong>下次将提交的文件列表信息</strong>，一般在 Git 仓库目录中。有时候也被称作「索引」，不过一般还是叫暂存区域。</li><li><strong>工作目录</strong>，Working Directory(Tree)，对项目的<strong>某个版本</strong>独立提取出来的内容，放在磁盘上可以使用或修改</li></ul><h3 id="Git-基础操作"><a href="#Git-基础操作" class="headerlink" title="Git 基础操作"></a>Git 基础操作</h3><ul><li><p><code>git config</code>：</p><ul><li><p>用于设置控制 Git 外观和行为的配置变量，它们存储在三个不同的位置：</p><ul><li><p><code>/etc/gitconfig</code> 文件: </p><p>使用 <code>--system</code> 选项读写该文件，包含系统上每一个用户及他们仓库的通用配置。</p></li><li><p><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code> 文件：</p><p> 使用 <code>--global</code> 选项读写该文件，只针对当前用户，一般 Windows 设置此处。 </p></li><li><p>当前使用仓库的 Git 目录中的 config 文件（就是 <code>.git/config</code>）：</p><p>针对该仓库。</p> <div class="note note-info">            <p>每一个级别覆盖上一级别的配置。</p>          </div></li></ul></li><li><p>用户信息：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git config --global user.name <span class="hljs-string">"用户名"</span></span><br><span class="hljs-meta">$</span><span class="bash"> git config --global user.email <span class="hljs-string">"邮箱"</span></span><br></code></pre></td></tr></tbody></table></figure></li><li><p>Git 操作别名 <code>alias</code>：</p><ul><li><p>相当于 <code>define</code>，不用输入复杂的操作命令，只需要输入它的别名</p></li><li><p>以 <code>git log</code> 的显示优化为例子，可以以 Git 图形象展示分支和提交情况，并涂上颜色 <span class="">🖍</span></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --graph --pretty=format:<span class="hljs-string">'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset'</span> --abbrev-commit --date=relative</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>对这一操作起别名 <code>showlog</code>，截取 <code>git</code> 之后的部分：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git config --global alias.showlog <span class="hljs-string">"log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit --date=relative"</span></span><br></code></pre></td></tr></tbody></table></figure></li></ul></li><li><p>设置编辑器：</p><p>​    默认编辑器为 Vim，入门不太友好，如果配置有 VSCode 或其他编辑器，可以修改默认编辑器：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git config --global core.editor <span class="hljs-string">"code --wait"</span></span><br></code></pre></td></tr></tbody></table></figure></li><li><p><code>git config --list</code> 命令来列出所有 Git 配置</p></li></ul></li><li><p>获取<strong>帮助文档</strong>的三种方式：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">help</span> &lt;verb&gt;</span><br><span class="hljs-meta">$</span><span class="bash"> git &lt;verb&gt; --<span class="hljs-built_in">help</span></span><br><span class="hljs-meta">$</span><span class="bash"> man git-&lt;verb&gt;</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>获取 Git 仓库</p><ul><li><code>git init</code> 创建 <code>.git</code> 的子目录，含有初始化的 Git 仓库中所有的必须文件，此时三棵树只有工作目录，其他两棵树都为空，后续可以添加远程仓库。</li><li><code>git clone</code> 克隆现有的仓库。</li></ul></li><li><p><strong>忽略文件</strong>：</p><ul><li><p>对于不希望 Git 加入版本控制的文件，可以通过 <code>.gitignore</code> 文件，列出要忽略的文件模式，一行一个规则（所有空行或者以 <code>＃</code> 开头的行都会被 Git 忽略）。</p></li><li><p>经典格式：</p><ul><li><p>按文件名忽略单个文件：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 忽略当前文件夹下的 a 文件：</span><br>a<br><span class="hljs-comment"># 忽略所有子目录下的 a 文件</span><br>*/a<br></code></pre></td></tr></tbody></table></figure></li><li><p>按后缀忽略文件：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 忽略所有的 .a 文件</span><br>*.a<br><span class="hljs-comment"># 用 ! 否定忽略 test.a 文件, 即使前面忽略了所有的 .a 文件</span><br>!test.a<br><span class="hljs-comment"># 忽略 /b/test.a,不能忽略 /b/b/test.a</span><br>b/*.a<br><span class="hljs-comment"># 忽略 b 目录及其子目录下所有的 .a 文件</span><br>b/**/*.a<br></code></pre></td></tr></tbody></table></figure></li><li><p>忽略文件夹：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 忽略根目录下的 a 文件夹，以下等价</span><br>a/<br>/a/<br>/a/*<br><span class="hljs-comment"># 忽略 a 文件夹, 不管是根目录下的 /a/, 还是子目录下的 /child/a/</span><br>a/*<br></code></pre></td></tr></tbody></table></figure></li><li><p>否定的格式和忽略格式一样，只需要加 <code>!</code></p></li><li><p>glob 模式规则（简化版正则表达式规则）：</p><ul><li><p>以星号 <code>*</code> 通配任意个字符</p></li><li><p>以问号 <code>?</code> 通配单个字符</p></li><li><p>以方括号 <code>[]</code> 包含单个字符的匹配列表：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 忽略 debug0.log、debugA.log 等</span><br>debug[a-zA-Z0-<span class="hljs-number">9</span>].log      <br> <span class="hljs-comment"># 仅忽略 debug0.log、debug1.log</span><br>debug[01].log        <br><span class="hljs-comment"># 不忽略 debug0.log、debug1.log</span><br>debug[!01].log       <br></code></pre></td></tr></tbody></table></figure></li></ul></li></ul></li><li><p>要注意的细节：</p><ul><li><p><code>gitignore</code> 是从上到下一行一行匹配，<strong>后面的会覆盖前面</strong>的。</p></li><li><p>默认编码是 GBK，所以<strong>不能识别中文</strong>。</p></li><li><p>对于已经加入版本控制的文件，不能仅通过修改 <code>.gitignore</code> 来取消跟踪，还要使用：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git update-index --assume-unchanged 文件路径</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>一般对于各种语言和项目有 <code>.gitignore</code> 模板</p></li></ul></li></ul></li></ul><h2 id="Git-本地操作"><a href="#Git-本地操作" class="headerlink" title="Git 本地操作"></a>Git 本地操作</h2><h3 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h3><ul><li><p><strong>工作目录</strong>下的每一个文件处于三种状态之一：</p><ul><li><p><strong>已跟踪</strong>，指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于<strong>未修改 Unmodified，已修改 Modified 或已放入暂存区状态 Staged</strong>。</p><blockquote><p>初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。</p></blockquote></li><li><p><strong>已忽略</strong>，在提交前已经被  <code>.gitignore</code>  规则忽略。</p></li><li><p><strong>未忽略且未跟踪</strong>，不是以上两种状态的文件</p></li><li><p>状态转换：</p><div align="center"><img src="../img/blog/git-note-images/status.png"></div></li></ul></li><li><p><code>git status</code> 查看文件状态：</p><ul><li><p>会显示了<strong>当前所在分支</strong>，以及这个分支同远程服务器上对应的分支是否偏离</p></li><li><p>输出格式：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">Changes to be committed:<br><span class="hljs-comment"># 已添加到暂存区的状态，包含 modified, new file, renamed, deleted</span><br><br>Changes <span class="hljs-keyword">not</span> staged <span class="hljs-keyword">for</span> commit:<br><span class="hljs-comment"># 工作目录的状态，未添加到暂存区，包含 modified, deleted</span><br><br>Untracked files:<br><span class="hljs-comment"># 未忽略且未跟踪的新文件</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>使用 <code>-s</code> 选项让输出更简洁：</p><ul><li><p>例子输出：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git status -s</span><br>M  README<br>MM Rakefile<br>A  lib/git.rb<br>?? LICENSE.txt<br></code></pre></td></tr></tbody></table></figure></li><li><p>状态分为<strong>两列</strong>，<strong>左列</strong>为上述所谓的<strong>暂存区状态</strong>，<strong>右列</strong>为<strong>工作目录状态</strong>。</p></li><li><p><code>M</code> 表示文件被修改过，<strong>左边</strong>的 <code>M</code> 表示该文件被修改了<strong>并放入了暂存区</strong>，<strong>右边</strong>的 <code>M</code> 表示该文件被修改了但是还<strong>没放入暂存区</strong>。同时具有两列状态的还有 <code>D</code>，表示一个<strong>已跟踪文件被删除</strong>。</p><blockquote><p>上面 <code>Rakefile</code> 文件可能经历了<strong>两次修改</strong>，第一次修改后，加入到了暂存区中，有了左边的 <code>M</code>，之后再进行第二次修改，未加入到暂存区，此时就会得到右边的 <code>M</code>。若再将该文件放入暂存区，则只会输出左边的 <code>M</code>。</p></blockquote></li><li><p><code>A</code> 表示文件新添加到暂存区中，之前可能处于为未跟踪状态，只会出现在<strong>左边</strong>。同样只会出现在左边的还有<strong>更名</strong>操作产生的状态 <code>R</code>。</p></li><li><p><code>??</code> 表示未忽略且未跟踪的新文件。</p></li></ul></li><li><p>当 <code>git status</code> 输出 <code>working tree clean</code> 时，或 <code>-s</code> 选项无输出时，表示当前没有修改，三棵树保持一致。许多命令都要求在 <code>working tree clean</code>，以防丢失修改。</p></li></ul></li></ul><h3 id="Git-个人开发操作"><a href="#Git-个人开发操作" class="headerlink" title="Git 个人开发操作"></a>Git 个人开发操作</h3><ul><li><p>查看文件差异：</p><ul><li><p>直接上图：</p><div align="center"><img src="../img/blog/git-note-images/diff.png"></div></li><li><p><code>git diff</code> 本身只显示<strong>尚未暂存的改动</strong>，而不是自上次提交以来所做的所有改动。所以暂存了所有更新过的文件后，运行 git diff 会什么也不输出。</p></li></ul></li><li><p><code>git add</code> 添加进暂存区：</p><ul><li>在新版本的 Git 中，<code>git add .</code> 和 <code>git add -A</code> 操作效果一致，都是将未跟踪、已跟踪被修改，已跟踪被删除的文件添加到暂存区。</li><li><code>git add -u</code> <strong>不会将未跟踪</strong>文件添加到暂存区，<code>u</code> 即 <code>update</code>，顾名思义就是只有<strong>已被跟踪</strong>的文件被更新（删除或被修改）才会添加到暂存区。</li></ul></li><li><p><code>git rm</code> 删除：</p><ul><li><p>清除不小心添加到暂存区的文件，不想让 Git 去跟踪。如果已经提交了，需要用之前说的方式删除：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git update-index --assume-unchanged 文件路径</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>不带选项时，是<strong>同时删除</strong>暂存区和工作目录下的文件，并且该文件的状态变为<strong>左边</strong>的 <code>D</code>，即删除这一动作也会被提交。</p></li><li><p><code>--cache</code> 选项，<strong>只删除暂存区</strong>的文件，不删除工作目录的文件，比如一些中间过程文件。文件状态会同时出现在暂存区和工作目录：</p><ul><li><p>在暂存区中显示<strong>左边</strong>的 <code>D</code></p></li><li><p>在工作目录中显示<strong>未跟踪</strong>的 <code>??</code></p></li><li><p>当使用简洁输出状态的时，会产生以下奇妙输出：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git rm --cache d</span><br><span class="hljs-meta">$</span><span class="bash"> git status -s</span><br>D  d<br>?? d<br></code></pre></td></tr></tbody></table></figure></li></ul></li><li><p>可以使用 glob 模式规则选择删除文件</p></li></ul></li><li><p><code>git mv</code> <strong>移动或更名</strong>文件：</p><ul><li>格式：<code>git mv a b</code>，<code>b</code> 可以是另一个文件名，也可以是一个具体的文件路径。</li><li>工作目录和暂存区的文件都会被移动</li><li>Git 会意识到这是一次改名，文件的状态会变成 <code>renamed</code> 或<strong>左边</strong>的 <code>R</code>。</li></ul></li><li><p><code>git commit</code> 提交更新：</p><ul><li><code>-a</code> 选项，跳过使用暂存区，直接把已修改或者已删除的文件添加提交，但是对于<strong>未跟踪的新文件</strong>不会添加，一般只用在修改少量文件的提交。</li><li><code>--amend</code> 选项，尽量在未推送到远程时使用（除非只有自己用），可以<strong>替换</strong>掉当前 <code>HEAD</code> 指向的提交（校验和改变），用于补充一些修改，保持 Git 记录工整。如果不使用 <code>-m</code> 编写新的提交信息，则会使用旧的提交信息。 </li></ul></li></ul><h3 id="后悔药：撤销操作-💊"><a href="#后悔药：撤销操作-💊" class="headerlink" title="后悔药：撤销操作 💊"></a>后悔药：撤销操作 💊</h3><ul><li><p><strong>强烈建议使用</strong>的 <code>git restore</code>：</p><ul><li><p>新版本的撤销命令，分担了原来 <code>git checkout</code> 和 <code>git reset</code> 的大量任务，通常格式为：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git restore [-s &lt;tree-ish&gt;] [--staged] [--worktree] 文件路径</span><br></code></pre></td></tr></tbody></table></figure></li><li><p><code>[]</code> 表示这一选项或参数可有可无。不带任何选项时，则会默认从<strong>暂存区</strong>还原工作目录下的文件。</p></li><li><p><code>-s &lt;tree&gt;</code> 选项，从 <code>&lt;tree-ish&gt;</code> 对应的提交还原文件，可以是 <code>HEAD</code>，分支名，或是提交的校验和前几位。</p></li><li><p><code>--staged</code> 选项，从 <strong><code>HEAD</code></strong> 或者在设置 <code>-s &lt;tree-ish&gt;</code> 后，从 <code>&lt;tree-ish&gt;</code> 还原文件，只会改变<strong>暂存区</strong>。</p></li><li><p><code>--worktree</code> 选项，一般和 <code>--staged</code> 一起用（因为没有 <code>--staged</code> 时就是会还原工作目录的），表示<strong>同时改变暂存区和工作目录</strong>。</p></li><li><p>通过灵活使用上述选项，改变文件状态，基本上满足工作需求</p></li></ul></li><li><p><code>git reset</code> 重置：</p><ul><li><p>当重置目标是文件时，<code>reset</code> 改变的是<strong>暂存区</strong>的对应文件，格式为：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git reset [&lt;tree-ish&gt;] [--] 文件路径</span><br></code></pre></td></tr></tbody></table></figure><p>加 <code>--</code> 会比较好一点，因为如果不幸有个分支名与路径名相同，那么 <code>reset</code> 是不能判断的（报错 <code>ambiguous argument</code>），所以要用 <code>--</code> 指定。</p><blockquote><p>重置文件后，会发现文件的状态变成了 <code>MM</code>，即<strong>暂存区</strong>的文件与 <code>HEAD</code> 和工作目录的文件都不同。这命令其实等价于：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git restore [-s &lt;tree-ish&gt;] --staged 文件路径</span><br></code></pre></td></tr></tbody></table></figure></blockquote></li><li><p>其余情况，会移动 <strong><code>HEAD</code> 指向的分支</strong> 到某一提交。格式为：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git reset [&lt;mode&gt;] [&lt;commit&gt;]</span><br></code></pre></td></tr></tbody></table></figure><p>此时有三种模式 mode：</p><ul><li><code>--soft</code>：只是将 <code>HEAD</code> 及其指向的分支移动到 <code>commit</code>，<strong>不会改变</strong>暂存区和工作目录。</li><li><code>--mixed</code>：不指定 mode 时的<strong>默认</strong>模式，将会改变暂存区与 <code>commit</code> 一致，其余同 <code>--soft</code>，不改变工作目录。</li><li><code>--hard</code>：较为<strong>危险</strong>的选项，将工作目录的<strong>修改全部丢弃</strong>，重置到 <code>commit</code> 一致，其余同 <code>--mixed</code>。</li><li>以上三种模式影响范围递增，形象对比如下：</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">原状态<br>working  index   HEAD   target         <br>   A       B      C       D <br>   <br><span class="hljs-meta">$</span><span class="bash"> git reset mode target</span>   <br>  mode    working    index    HEAD   <br>--soft         A         B        D<br>--mixed        A         D        D<br>--hard         D         D        D<br></code></pre></td></tr></tbody></table></figure><blockquote><p>可以使用 <code>--soft</code> 模式实现所谓「<strong>压缩提交</strong>」的效果：</p><p>假设当前提交历史为 <code>a → b → c</code>，当不想保留 <code>b</code> 提交时，可以在 <code>c</code> 时使用 <code>--soft</code> 的 <code>reset</code>，使 <code>HEAD</code> 和其分支指向 <code>a</code>，同时因为暂存区不变，再提交一次即可，最终历史为：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">a -&gt; b -&gt; c<br>└--&gt; d (HEAD)<br></code></pre></td></tr></tbody></table></figure></blockquote></li></ul></li><li><p>万能的 <code>git checkout</code>：</p><ul><li><p>如果要移动 <code>HEAD</code>，格式为：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 切换到指定分支</span><br>$ git checkout [-q] [-f] [-m] [&lt;branch&gt;]<br><br><span class="hljs-comment"># 切换到 start_point，并在其上建立新分支</span><br>$ git checkout [[-b|-B] &lt;new_branch&gt;] [&lt;start_point&gt;]<br></code></pre></td></tr></tbody></table></figure><ul><li>不同于 <code>reset</code>，<code>checkout</code> <strong>仅会</strong>移动 <code>HEAD</code>，不会移动分支。这使得 <code>HEAD</code> 可能进入 <code>detach</code> <strong>分离</strong>状态，即 <code>HEAD</code> 指向了某个<strong>具体的提交记录</strong>而不是分支名，可以通过新建分支解决。</li><li><code>-B</code> 是强制建立分支，即使同名分支已存在，这会使得原同名分支移动到 <code>start_point</code>。</li><li>切换分支时尽量保持 <code>working tree clean</code>，即三棵树保持一致，否则可能会丢失修改。</li></ul></li><li><p>如果要撤销文件修改，格式为：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git checkout [&lt;tree-ish&gt;] [--] 文件路径</span><br></code></pre></td></tr></tbody></table></figure><p>这会同时修改<strong>暂存区和工作目录</strong>的对应文件，使得与 <code>tree-ish</code> 一致，这会使得修改丢失，属于<strong>危险操作</strong>。</p></li></ul></li></ul><h3 id="Git-标签-🔖"><a href="#Git-标签-🔖" class="headerlink" title="Git 标签 🔖"></a>Git 标签 🔖</h3><ul><li><p>分支很容易被人为移动，并且当有新的提交时，它也会移动，大部分分支还只是<strong>临时</strong>的。所以需要一个永远指向某个<strong>提交记录</strong>的标识，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性。这就需要打<strong>标签</strong>。</p></li><li><p>标签不会随着新的提交而移动，它就像是提交树上的一个锚点，标识了某个特定的位置。</p></li><li><p>列出已有标签：</p><p>​    以<strong>字母顺序</strong>列出标签</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git tag</span><br>v1.0<br>v1.1<br></code></pre></td></tr></tbody></table></figure></li><li><p>轻量标签（lightweight）：</p><ul><li><p>只是某个特定提交的引用，没有注释，只有一个标签号</p></li><li><p>格式：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 没有指定 commit 会默认在当前 HEAD 指向提交上打上标签</span></span><br><span class="hljs-meta">$</span><span class="bash"> git tag &lt;tagname&gt; [&lt;commit&gt;]</span><br></code></pre></td></tr></tbody></table></figure></li></ul></li><li><p>附注标签（annotated）：</p><ul><li>是存储在 Git 数据库中的一个<strong>完整对象</strong>，可以被校验的，包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard（GPG）签名与验证。</li><li>在运行 tag 命令时<strong>指定 -a 选项</strong>，并使用 <code>-m</code> 选项指定了一条将会存储在标签中的<strong>信息</strong>。</li></ul></li><li><p>显示标签对应信息：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git show v1.0</span><br>tag v1.0<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">############################################### 附注标签才有的信息</span></span><br>Tagger: ailanxier &lt;ailanxier@ailanxier.cc&gt;<br>Date:   Sat May 3 20:19:12 2014 -0700<br><br>tag information<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">############################################### 附注标签才有的信息</span></span><br>commit ca82a6dff817ec66f44342007202690a93763949<br>Author: ailanxier &lt;ailanxier@ailanxier.com&gt;<br>Date:   Mon Mar 17 21:52:11 2008 -0700<br><br>    commit information<br></code></pre></td></tr></tbody></table></figure></li><li><p>推送标签到远程：</p><p>​    <strong>默认</strong>情况下，<code>git push</code> 命令并不会传送标签到远程仓库服务器上。在创建完标签后必须<strong>显式</strong>地推送标签到共享服务器上，就像共享远程分支一样。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git push origin &lt;tagname&gt;</span><br><span class="hljs-meta">$</span><span class="bash"> git push origin --tags</span><br></code></pre></td></tr></tbody></table></figure><p>​    通常使用带有 <code>--tags</code> 选项的 <code>git push</code> 命令，会把<strong>所有不在远程仓库上的标签</strong>全部推送，不会区分轻量标签和附注标签。</p></li><li><p>删除标签：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git tag -d &lt;tagname&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>​    这<strong>只会删除本地标签</strong>，如果已经推送到远程仓库了，此时删除标签是一件对别人不太友好的事，可以使用如下命令删除远程仓库的标签：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git push origin -d &lt;tagname&gt;</span><br></code></pre></td></tr></tbody></table></figure></li></ul><div class="note note-warning">            <p>在已经推送标签后，最好不要使用 <code>-f</code> 选项强制替换已有标签，也不要删除标签。</p>          </div><ul><li><p>可以根据标签名，使用 <code>git checkout</code> 切换到标签所在的提交，但是此时通常会处于<strong>分离 <code>HEAD</code> 状态</strong>，即新的修改提交不能被分支记录，要索引到这一提交只能通过校验和。所以如果要进行更改，比如修复旧版本中的错误，那么通常需要创建一个新分支，可以使用切换并新建分支的命令：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git checkout -b      bugFix_v2.0.0     v2.0.0</span><br></code></pre></td></tr></tbody></table></figure></li></ul><h2 id="Git-分支"><a href="#Git-分支" class="headerlink" title="Git 分支"></a>Git 分支</h2><h3 id="分支简单操作"><a href="#分支简单操作" class="headerlink" title="分支简单操作"></a>分支简单操作</h3><ul><li><p>新建分支：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git branch &lt;branchname&gt; [&lt;start-point&gt;]</span><br></code></pre></td></tr></tbody></table></figure><p>如果不指定 <code>&lt;start_point&gt;</code> 则在 <code>HEAD</code> 指向的提交对象上创建一个指针，即为分支，同时在 <code>.git\refs\heads</code> 上新建一个名为 <code>branchname</code> 的文件，这个文件只含有 40 位校验和。所以创建分支是很轻量的一个操作。该命令<strong>不会切换分支</strong>。</p><div class="note note-info">            <p><code>HEAD</code> 是一个特殊的指针，告诉 Git 当前在哪个分支上，且只会指向<strong>本地分支</strong>。当使用 <code>git checkout</code> 到一个远程分支时，会处于 <code>HEAD</code> 分离状态。</p>          </div></li><li><p>删除分支：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git branch [-d | -D] &lt;branchname&gt;</span><br></code></pre></td></tr></tbody></table></figure><p><code>-d</code> 不能删除未合并的分支，<code>-D</code> 可以强制删除这种分支。</p></li><li><p>查看分支：</p><ul><li><p>不带选项和参数的 <code>git branch</code> 命令：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git branch</span><br>* dev   <br>  mynew <br>  new   <br></code></pre></td></tr></tbody></table></figure><p>显示所有本地分支，<code>*</code> 的分支为 <code>HEAD</code> 指向的分支。</p></li><li><p><code>-v</code> 选项：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git branch -v</span><br>* dev   e31e199 [ahead 9] Merge<br>  mynew 6a1cba4 test merge branch<br>  new   6a1cba4 test merge branch<br></code></pre></td></tr></tbody></table></figure><p>显示更详细的信息，如分支指向的提交记录<strong>校验和</strong>，与远程分支的<strong>差异</strong>，提交记录的<strong>描述信息</strong>。</p></li><li><p><code>-vv</code> 选项：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git branch -vv</span><br>* dev   e31e199 [o/dev: ahead 9] Merge<br>  mynew 6a1cba4 [o/new] test merge branch<br>  new   6a1cba4 [o/new] test merge branch<br></code></pre></td></tr></tbody></table></figure><p>显示<strong>跟踪的远程分支</strong>，用的较多。</p></li><li><p><code>-a</code> 选项：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git branch -a</span><br>* dev<br>  mynew<br>  new<br>  remotes/o/dev<br>  remotes/o/new<br></code></pre></td></tr></tbody></table></figure><p>列出所有分支，包括远程分支。</p></li><li><p><code>--merged</code> 和 <code>--no-merged</code> 选项：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git branch [--merged | --no-merged] [&lt;branchname&gt;]</span><br></code></pre></td></tr></tbody></table></figure><p>显示已（未）合并到<strong>当前分支</strong> 或 <code>&lt;branchname&gt;</code>（在有该参数的情况下）的分支。一般已合并的分支，如果其为临时分支，<strong>可以删除</strong>。</p></li></ul></li><li><p><code>git branch -f</code>：</p><p>这可以当做一个新建分支命令，也可以<strong>移动现有分支到指定位置</strong>，格式为：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git branch -f &lt;branchname&gt; [&lt;start-point&gt;]</span><br></code></pre></td></tr></tbody></table></figure></li></ul><h3 id="Git-merge-🏳️‍🌈"><a href="#Git-merge-🏳️‍🌈" class="headerlink" title="Git merge 🏳️‍🌈"></a>Git merge 🏳️‍🌈</h3><ul><li><p>通常使用的格式：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git merge [--squash] [--no-commit] [&lt;commit&gt;]<br></code></pre></td></tr></tbody></table></figure><p>假设分支情况如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">   A---B---C topic<br> /<br>D---E---F---G *master<br></code></pre></td></tr></tbody></table></figure><p>在 <code>master</code> 分支合并 <code>topic</code> 分支，即执行 <code>git merge topic</code> 后，分支情况如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">   A----B----C topic<br> /             \<br>D---E---F---G---H *master<br></code></pre></td></tr></tbody></table></figure><p>会得到一个合并的提交，它有<strong>两个父提交</strong>。</p></li><li><p>解决冲突：</p><ul><li><p>合并时，如果两个分支修改了同一个文件，可能会出现冲突，Git 不能智能合并，只能手动解决冲突，提示如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">CONFLICT (content): Merge conflict in d1.txt<br>Automatic merge failed; fix conflicts and then commit the result.<br></code></pre></td></tr></tbody></table></figure><p>Git 会暂停下来，等待手动解决合并产生的冲突。在合并冲突后的任意时刻使用 <code>git status</code> 命令来查看那些因<strong>包含合并冲突而处于未合并</strong>（unmerged）状态的文件：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch dev<br>You have unmerged paths.<br>  (fix conflicts and run "git commit")<br>  (use "git merge --abort" to abort the merge)<br><br>Unmerged paths:<br>  (use "git add &lt;file&gt;..." to mark resolution)<br>        both modified:   d1.txt<br><br>no changes added to commit (use "git add" and/or "git commit -a")<br></code></pre></td></tr></tbody></table></figure></li><li><p>Git 会在有冲突的文件中加入<strong>标准的冲突解决标记</strong>，他们会包含一些<strong>特殊区段</strong>，格式如下：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>now_change<br>=======<br>new_change<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; new<br></code></pre></td></tr></tbody></table></figure><p>这表示 <code>HEAD</code> 所指示的版本（在运行 <code>merge</code> 命令之前已经切换到这个分支）在这个区段的上半部分（<code>======</code> 之上），而 <code>new</code> 分支所指示的版本在 <code>======</code> 之下。 为了解决冲突，你必须选择使用由<code>======</code> 分割的两部分中的一个，或者也可以自行合并这些内容。 </p><blockquote><p>可以使用 VSCode 打开冲突文件，会有特殊的高亮和提示解决冲突，非常友好。</p></blockquote></li><li><p>在解决了所有文件里的冲突之后，对每个文件使用 <code>git add</code> 命令来将其标记为<strong>冲突已解决</strong>。此时可以使用 <code>git commit</code> 来生成合并提交，完成合并操作。</p></li></ul></li><li><p>快进 <code>Fast-forward</code> 现象：</p><ul><li>当试图合并两个分支时， 如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进，因为这种情况下的合并操作没有需要解决的分歧，所以也叫 <code>Fast-forward</code>。</li><li>例如在 <code>dev</code> 分支成功合并 <code>new</code> 后，若切换回 <code>new</code> 分支再合并 <code>dev</code>，则只会将 <code>new</code> 分支移动到 <code>dev</code> 分支，Git 显示此时发生了 <code>Fast-forward</code>。</li></ul></li><li><p><code>--squash</code> 选项：</p><p>接受被合并的分支上的所有工作，并将其压缩至一个变更集，产生一个<strong>不是合并提交</strong>的提交记录。它<strong>只有一个父提交</strong>，但却引入另一个分支的所有改动，可以在记录一个新提交前做更多的改动。</p><div class="note note-info">            <p>即好像合并了，但是没完全合并，只是把<strong>另一个分支的变动</strong>拿过来合并到工作目录中而已，另一个分支不会发生任何变化。</p>          </div></li><li><p><code>--no-commit</code> 选项：</p><p>即将完成合并前，<strong>强制停下</strong>（否则会直接生成合并提交记录），允许用户进行修改和暂存，最后<strong>手动提交</strong>来结束合并。可以和 <code>--squash</code> 同时使用。</p></li><li><p><code>git merge --abort</code> 结束合并命令：</p><p>当合并因为 <code>--no-commit</code> 或者冲突停下时，可以使用此命令结束合并，恢复到 Git 没执行合并命令之前的状态。</p></li></ul><h3 id="Git-rebase-♐"><a href="#Git-rebase-♐" class="headerlink" title="Git rebase ♐"></a>Git rebase ♐</h3><ul><li><p>常用格式：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git rebase [-i] [--onto &lt;newbase&gt;] [&lt;branch&gt;]</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>演示过程：</p><p>假设分支情况如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">      A---B---C *topic<br>     /<br>D---E---F---G master<br></code></pre></td></tr></tbody></table></figure><p>在 <code>topic</code> 分支处执行 <code>git rebase master</code>，或者在其他任何地方执行 <code>git rebase master topic</code>，会得到一样的结果：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">              A'--B'--C' *topic<br>             /<br>D---E---F---G master<br></code></pre></td></tr></tbody></table></figure><div class="note note-info">            <p><code>git rebase master topic</code> 其实会先切换到 <code>topic</code> 分支，再执行 <code>git rebase master</code>。</p>          </div></li><li><p>上例中 <code>rebase</code> 原理：</p><ul><li>先找到这两个分支（即当前分支 <code>topic</code>、变基操作的目标基底分支 <code>master</code>） 的<strong>最近共同祖先</strong> <code>E</code></li><li>对比当前分支相对于该祖先的历次提交，提取相应的<strong>修改</strong>并存为临时文件，将当前分支指向目标基底 <code>G</code></li><li>最后以临时文件的修改按顺序应用于 <code>G</code> 上，就好像他们是在 <code>G</code> 后完成的修改，他们的校验和会发生改变，所以在图中用带 <code>'</code> 的字母表示。</li><li>原来的提交仍然存在，但是只能通过提交的<strong>校验和</strong>访问，可以<strong>使用 <code>git reflog</code> 查看</strong> <code>HEAD</code> 移动的历史记录，找到已经不在历史中的提交校验和。</li></ul></li><li><p>这样做的好处：</p><ul><li>确保在向远程分支推送时能保持<strong>提交历史的整洁</strong>。</li><li>例如向某个其他人维护的项目贡献代码时，先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到<strong>远程分支</strong>上，然后再向主项目提交修改。 </li><li>这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并（<code>Fast-forward</code>）便可。</li></ul></li><li><p>注意一种特殊情况：</p><ul><li><p>当<strong>目标基底分支</strong>已经包含了<strong>当前分支</strong>所做的<strong>相同修改</strong>（整个提交做的修改<strong>完全相同</strong>，可能是修复了同样的 bug），类似：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">      A---B---C *topic<br>     /<br>D---E---A'---F master<br></code></pre></td></tr></tbody></table></figure><p><code>A</code> 和 <code>A'</code> 所做的修改相同</p></li><li><p>此时运行变基命令，会得到：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">               B'--C' *topic<br>              /<br>D---E---A'---G master<br></code></pre></td></tr></tbody></table></figure><p><code>A</code> 的提交被跳过了，Git 认为 <code>G</code> 已经包含了 <code>A</code> 中的修改，就不会再重新做一次了。</p></li></ul></li><li><p><code>--onto</code> 选项：</p><ul><li><p>个人认为比较危险，容易<strong>丢失修改和新文件</strong>，需要对分支的改变非常熟悉才建议使用。</p></li><li><p>假设当前分支情况如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">o---o---o---o---o  master<br>         \<br>          o---o---o---o---o  next<br>                           \<br>                            o---o---o  topic<br></code></pre></td></tr></tbody></table></figure><p><code>topic</code> 分支依赖实现了某种功能的 <code>next</code> 分支，此时 <code>master</code> 分支的功能逐渐完善，已经可以让 <code>topic</code> 分支基于更稳定的 <code>master</code> 分支了，此时仅想保留 <code>topic</code> 分支中的修改，不需要 <code>next</code> 分支中的修改，则可以使用：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git rebase --onto master next topic</span><br>o---o---o---o---o  master<br>        |        \<br>        |         o'--o'--o'  topic<br>         \<br>          o---o---o---o---o  next<br></code></pre></td></tr></tbody></table></figure><div class="note note-warning">            <p>如果 <code>next</code> 分支中有新文件，且 <code>topic</code> 分支中没有对新文件进行修改，则变基后<strong>新文件将消失</strong>。</p><p>同理如果 <code>topic</code> 中没有对 <code>next</code> 修改过的文件进行修改，变基后修改会消失。</p>          </div></li><li><p>该选项可以用来去掉一段<strong>连续的提交</strong>，但是不太推荐，还是用 <code>-i</code> 选项的 <code>rebase</code> 比较好，也能达到同样的效果，但是更安全。</p></li></ul></li><li><p><strong>非常推荐的交互式变基</strong> <code>-i</code> 选项：</p><ul><li><p>Git 会打开一个文件（如果是 VSCode 打开会有图形操作界面，如下图）并列出将要被复制到目标分支的备选<strong>提交记录</strong>，以及它们的哈希值和<strong>提交说明</strong>，有助于理解这个提交进行了哪些更改。</p><div align="center"><img src="../img/blog/git-note-images/vscode-rebase.png"></div></li><li><p>可以根据意愿调整提交记录：</p><ul><li>调整提交记录的<strong>顺序</strong>（VSCode 通过鼠标拖放来完成）</li><li>删除不想要的提交</li><li>合并提交，有多种合并方式。</li><li>修改提交说明</li></ul></li><li><p><strong>具体选项</strong>如下：</p><ul><li><code>p, pick &lt;commit&gt; = use commit</code> 完整保留提交。</li><li><code>r, reword &lt;commit&gt; = use commit, but edit the commit message</code> 同 <code>p</code>，只是会打开编辑器修改<strong>提交说明</strong>。</li><li><code>e, edit &lt;commit&gt; = use commit, but stop for amending</code> 同 <code>p</code>，同时等待手动 <code>git commit --amend</code>，修改到满意了就会运行 <code>git rebase --continue</code> 继续变基下一个提交。</li><li><code>s, squash &lt;commit&gt; = use commit, but meld into previous commit</code> 合并提交到自己的夫提交，会打开文本编辑器修改<strong>提交说明</strong>。这个选项用的比较多。</li><li><code>f, fixup &lt;commit&gt; = like "squash" but keep only the previous commit's log message</code> 同 <code>s</code>，但是舍弃这次提交的提交说明，其实和 <code>s</code> 的区别就在于它不会打开编辑器。</li><li><code>d, drop remove commit</code> 舍弃提交。</li></ul></li></ul></li><li><p>变基是一个提交一个提交进行处理的。如果中间发生冲突也需要一个一个处理，此时 Git 会停下变基，用户可以打开<strong>冲突文件</strong>进行修改，修改完后用 <strong><code>git add .</code></strong> 添加所有的冲突文件，然后用 <strong><code>git rebase --continue</code></strong> 继续进行变基。</p><div class="note note-info">            <p>Git 全程有命令提示，过程很友好。</p><p>如果想终止变基，在 Git 停下阶段使用 <code>git rebase --abort</code> 恢复到变基前状态。</p>          </div></li><li><p>多次 <code>rebase</code> 实例：</p><ul><li><p>来自 <a href="https://git-scm.com/docs">Git Reference</a> 的 <code>level advanced1</code> 关卡。</p><div class="note note-info">            <p>这个网站很好玩，通过关卡学习 Git 分支常用操作，不涉及暂存区，有命令条数的要求（不严格）。</p><p>一些常用命令：</p><ul><li><code>levels</code> 重新选择关卡</li><li><code>reset</code> 将分支恢复关卡开始前原状</li><li><code>show solution</code> 显示答案，建议不管有没有过关都显示一次答案</li></ul><p>它还提供了「沙盒」功能，可以提供用户使用各种具有破坏性的 Git 命令。</p>          </div></li><li><p>原分支情况：</p><div align="center"><img src="../img/blog/git-note-images/rebase1.png"></div></li><li><p>目标分支情况：</p><div align="center"><img src="../img/blog/git-note-images/rebase2.png"></div></li><li><p>执行过程：</p><ol><li><code>git rebase main bugFix</code>，得到 <code>C3'</code>。</li><li><code>git rebase bugFix side</code>，得到 <code>C4',C5',C6'</code>。</li><li><code>git rebase side another</code>，仅得到 <code>C7'</code>，这里其实对应之前说的特殊情况，<code>C4,C5</code> 和 <code>C4',C5'</code> 所作的修改是一样的，所以 <code>rebase</code> 不会将它们再放到这条提交线上。</li><li><code>git rebase another main</code>，利用快进 <code>Fast-forward</code>，使 <code>main</code> 分支更新到最新版本。</li></ol></li></ul></li></ul><h3 id="Merge-vs-Rebase"><a href="#Merge-vs-Rebase" class="headerlink" title="Merge vs. Rebase"></a>Merge vs. Rebase</h3><ul><li><p>关于使用 <code>merge</code> 和 <code>rebase</code> 的争论一直存在，甚至有人说无脑用 <code>rebase</code> 就行，笔者认为还是看情况用比较好。</p></li><li><p><code>merge</code> 保留了所有提交记录，但是分支错杂，记录树非常乱；<code>rebase</code> 可以任意修改提交记录，记录树很整洁。</p></li><li><p>有一种观点认为，仓库的提交历史即是记录实际发生过什么。它是针对历史的文档，本身就有价值，不能乱改。 从这个角度看来，改变提交历史是一种亵渎，你使用「谎言」掩盖了实际发生过的事情。如果由合并产生的提交历史是一团糟怎么办？既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。</p></li><li><p>另一种观点则正好相反，他们认为提交历史是项目过程中发生的事。 没人会出版一本书的第一版草稿，软件维护手册也是需要反复修订才能方便使用。 持这一观点的人会使用 <code>rebase</code> 及 <code>filter-branch</code> 等工具来编写故事，怎么方便后来的读者就怎么写。</p></li><li><p>书上推荐的原则：</p><p>只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从<strong>不对已推送至别处的提交执行变基</strong>操作。</p><div class="note note-warning">            <p>这一原则极其重要，否则合作者可能会使用到已被变基放弃的旧提交，产生非常混乱的结果</p>          </div></li></ul><h2 id="Git-远程协作"><a href="#Git-远程协作" class="headerlink" title="Git 远程协作"></a>Git 远程协作</h2><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><ul><li><p>显示远程仓库的 URL：</p><p>​    显示需要读写远程仓库的<strong>简写</strong>与其对应的 URL。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git remote -v</span><br>origin  git@github.com:ailanxier/Test.git (fetch)<br>origin  git@github.com:ailanxier/Test.git (push)<br></code></pre></td></tr></tbody></table></figure></li><li><p>添加远程仓库：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git remote add &lt;shortname&gt; &lt;url&gt;</span><br></code></pre></td></tr></tbody></table></figure></li></ul><p>​    之后可以用字符串 <code>shortname</code> 来代替整个 URL。</p><ul><li><p><strong>联网</strong>查看远程仓库的详细信息 🧙‍♂️：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">$ git remote show origin<br>* remote origin<br>  URL: https://github.com/my-org/project<br>  Fetch URL: https://github.com/my-org/project<br>  Push  URL: https://github.com/my-org/project<br>  HEAD branch: master<br>  Remote branches:<br>    master            tracked<br>    dev-branch        tracked<br>    issue             new (<span class="hljs-built_in">next</span> fetch will store <span class="hljs-keyword">in</span> remotes/origin)<br>  Local branches configured <span class="hljs-keyword">for</span> <span class="hljs-string">'git pull'</span>:<br>    dev-branch merges <span class="hljs-keyword">with</span> remote dev-branch<br>    master     merges <span class="hljs-keyword">with</span> remote master<br>  Local refs configured <span class="hljs-keyword">for</span> <span class="hljs-string">'git push'</span>:<br>    dev-branch        pushes to dev-branch             (up to date)<br>    master            pushes to master                 (up to date)<br></code></pre></td></tr></tbody></table></figure><p>​    同样会列出远程仓库的 URL 与<strong>跟踪分支</strong>的信息，在特定的分支上执行 <code>git push</code> 会自动地推送到哪一个远程分支，哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了，还有执行 <code>git pull</code> 时哪些分支会自动合并</p></li><li><p>移除远程仓库：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git remote rm &lt;shortname&gt;</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>重命名远程仓库：</p><p>​    将远程仓库 <code>a</code> 重命名为 <code>b</code>。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git remote rename a b</span><br></code></pre></td></tr></tbody></table></figure></li></ul><h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><ul><li><p>远程分支的<strong>命名格式</strong>为 <code>&lt;remote name&gt;/&lt;branch name&gt;</code>，<code>&lt;remote name&gt;</code> 常见如 <code>origin</code>，<code>&lt;branch name&gt;</code> 常见如 <code>master</code>。</p><div class="note note-info">            <p><code>origin</code> 和 <code>master</code> 并<strong>无特殊含义</strong>，即不是关键词，可以改成任意名字。</p><p><code>master</code> 是运行 <code>git init</code> 时默认的起始分支名字，原因仅仅是它的广泛使用，<code>origin</code> 是当你运行 <code>git clone</code> 时默认的远程仓库名字。</p>          </div></li><li><p>拉取到本地的远程分支，只能通过 <code>git fetch</code>，<code>git pull</code> 和 <code>git push</code> 移动，当 <code>HEAD</code> 切换到远程分支时通常会处于 <code>HEAD</code> 分离状态。</p></li><li><p>本地<strong>跟踪分支</strong>（<strong>上游分支</strong>）：</p><ul><li><p>跟踪分支是与远程分支有直接关系的本地分支。</p></li><li><p>如果在一个<strong>跟踪分支</strong>上输入 <code>git fetch</code>，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。</p><div class="note note-warning">            <p>在一个跟踪分支输入 <code>git push</code>，如果和远程分支<strong>不同名</strong>，不能自动识别出要推送到哪个分支。</p>          </div></li><li><p><strong>新建</strong>跟踪分支的命令：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git checkout -t &lt;remote&gt;/&lt;branch&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>新建一个名为 <code>branch</code> 的分支，跟踪远程分支 <code>&lt;remote&gt;/&lt;branch&gt;</code>。</p><p>如果想<strong>自定义</strong>分支名字，可以使用：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git checkout -b &lt;branchname&gt; &lt;remote&gt;/&lt;branch&gt;</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>为<strong>当前本地分支</strong>设置（修改）上游分支：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git branch -u &lt;remote&gt;/&lt;branch&gt;</span><br></code></pre></td></tr></tbody></table></figure><div class="note note-info">            <p>上游快捷方式：</p><p>当设置好跟踪分支后，可以通过简写 <code>@{u}</code> 来引用它的上游分支。</p><p>例如在 <code>master</code> 分支时并且它正在跟踪 <code>origin/master</code> 时，可以使用 <code>git merge @{u}</code> 来取代 <code>git merge origin/master</code>。</p>          </div></li><li><p>可以使用 <code>git branch -vv</code> 查看本地分支及其跟踪分支，属于<strong>离线操作</strong>，即没有联网。</p></li></ul></li></ul><h3 id="Fetch-Pull-Push-👨🏻‍💻"><a href="#Fetch-Pull-Push-👨🏻‍💻" class="headerlink" title="Fetch,Pull,Push 👨🏻‍💻"></a>Fetch,Pull,Push 👨🏻‍💻</h3><ul><li><p><code>git fetch</code>：</p><ul><li><p>一般格式：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git fetch [&lt;remote&gt;] [&lt;branchname&gt;]</span><br></code></pre></td></tr></tbody></table></figure><p>从远程仓库 <code>&lt;remote&gt;</code> 上抓取本地没有的数据时，它并<strong>不会修改工作目录</strong>中的内容，只会修改远程分支。</p></li><li><p>不指定 <code>remote</code> 和 <code>&lt;branchname&gt;</code>：</p><p>默认从 <code>origin</code> 远程仓库获取数据更新<strong>本地所有分支</strong>。如果一个分支<strong>已经设置了跟踪分支</strong>，则<strong>该分支</strong>从那个跟踪分支所在仓库获取数据。</p></li><li><p>指定 <code>branchname</code>：</p><p>仅更新指定远程分支。</p></li><li><p><code>git fetch --all</code>：</p><p>从<strong>所有远程仓库</strong>下载本地没有的数据。</p></li></ul></li><li><p><code>git pull</code>：</p><ul><li><p>可以理解为 <code>git fetch</code> + <code>git merge</code> 的缩写：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git pull origin foo</span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">############################# 等价于下面两条命令</span></span><br><span class="hljs-meta">$</span><span class="bash"> git fetch origin foo</span><br><span class="hljs-meta">$</span><span class="bash"> git merge origin/foo</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>需要注意最终 <code>merge</code> 的位置，无论执行 <code>git pull</code> 前处于哪个分支，这个命令都会合并到<strong>这个分支</strong>上，这个分支<strong>可能并不跟踪远程分支</strong> <code>foo</code>。所以笔者更推荐<code>git fetch</code> 后手动 <code>git merge</code>。</p></li><li><p><code>git pull</code> 例子：</p><ul><li><p>原分支情况：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">      A---B---C master on origin<br>     /<br>D---E---F---G *master<br>⬆<br>origin/master in your repository<br></code></pre></td></tr></tbody></table></figure></li><li><p>运行 <code>git pull</code> 后，分支情况：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">      A---B---C origin/master<br>     /         \<br>D---E---F---G---H *master<br></code></pre></td></tr></tbody></table></figure></li></ul></li><li><p>使用 <code>--rebase</code> 选项：</p><p>不适用 <code>merge</code> 策略，转而执行 <code>git fetch</code> + <code>git rebase</code>。</p></li></ul></li><li><p><code>git push</code>：</p><ul><li><p>一般格式：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git push &lt;remote&gt; &lt;branch&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>推送本地 <code>branch</code> 的变更到远程仓库 <code>remote</code>，同时<strong>本地的远程分支</strong>会移动到 <code>branch</code> 的位置。</p></li><li><p>神奇的 <code>&lt;refspec&gt;</code> 格式：</p><ul><li>使用 <code>git push origin a</code> 时，Git 自动将 <code>a</code> 分支名字展开为<code>refs/heads/a:refs/heads/a</code>， 那意味着「推送本地的 <code>a</code> 分支来更新远程仓库上的 <code>a</code> 分支」。</li><li>这种带冒号的 <code>&lt;src&gt;:&lt;dst&gt;</code> 格式为 <code>&lt;refspec&gt;</code> 格式，<code>&lt;src&gt;</code> 可以是某个具体的提交的校验和，只要是 Git 能识别的都可以起效。</li><li>这意味着上述语句等价于 <code>git push origin a:a</code>，所以我们完全可以使用 <code>git push origin b:a</code>，即使分支 <code>b</code> 和 <code>origin/a</code> 毫无关联，但是一般不会这样做。</li><li>如果 <code>&lt;dst&gt;</code> 不存在，Git 甚至会在远程仓库新建一个名为 <code>dst</code> 的远程分支。</li><li><strong>如果 <code>&lt;src&gt;</code> 为空</strong>，即使用 <code>git push origin :a</code>，会<strong>删除</strong>远程仓库中的 <code>origin/a</code> 分支</li><li><code>git push</code> 和 <code>git fetch</code> 也可以使用这样的格式，但是觉得用处不大就不提了 👻</li></ul></li><li><p><code>--all</code> 选项：</p><p><code>git push</code> 默认是只推送当前分支，该选项会推送所有分支。</p></li></ul></li></ul><h2 id="Git-杂项"><a href="#Git-杂项" class="headerlink" title="Git 杂项"></a>Git 杂项</h2><h3 id="相对引用"><a href="#相对引用" class="headerlink" title="相对引用"></a>相对引用</h3><ul><li>在 <code>^</code> 后面添加一个数字来指明<strong>哪一个</strong>父提交：<ul><li>通常用于合并提交节点，如果<strong>只有一个父节点</strong>，那么 <code>^</code> 就表示它的父节点。</li><li>对于合并提交节点：<ul><li><strong>第一父提交</strong> <code>^1</code> 是<strong>合并时所在分支</strong></li><li>第二父提交 <code>^2</code> 是所合并的分支</li></ul></li></ul></li><li>另一种相对引用是使用 <code>~</code>，同样是指向<strong>第一父提交</strong>，因此 <code>HEAD~</code> 和 <code>HEAD^</code> 是等价的。而区别在于你在后面加数字的时候，例如 <code>HEAD~2</code> 代表「第一父提交的第一父提交」。下图可以更清晰地反映区别：</li></ul><div align="center"><img src="../img/blog/git-note-images/relative.png"></div><ul><li><code>^</code> 和 <code>~</code> 前可以是<strong>提交校验和</strong>，<strong>分支名</strong>和 <code>HEAD</code> 等。</li></ul><h3 id="交互式暂存"><a href="#交互式暂存" class="headerlink" title="交互式暂存"></a>交互式暂存</h3><ul><li><p>使用 <code>git add -i</code>，发现 Git 新世界。</p></li><li><p>Git 将会进入一个交互式终端模式，显示类似下面的东西：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git add -i</span><br>staged unstaged path<br>1: unchanged +0/-1 TODO<br>2: unchanged +1/-1 index.html<br>3: unchanged +5/-1 lib/simplegit.rb<br><br>*** Commands ***<br>1: [s]tatus  2: [u]pdate  3: [r]evert  4: [a]dd untracked<br>5: [p]atch   6: [d]iff    7: [q]uit    8: [h]elp<br>What now&gt;<br></code></pre></td></tr></tbody></table></figure><p>首先显示 <code>HEAD</code> 和暂存区有差异的文件，将<strong>暂存的修改</strong>列在<strong>左侧</strong> <code>staged</code>，<strong>未暂存的修改</strong>列在<strong>右侧</strong> <code>unstaged</code>。</p><p>同时会进入循环命令状态，直到输入 <code>7</code> 或 <code>q</code> 退出（8 个命令都可以输入<strong>首字母</strong>或数字生效）。</p></li><li><p><code>1 status</code>：</p><ul><li>显示 <code>HEAD</code> 和暂存区有差异的文件，和第一次显示时一样，且是<strong>实时</strong>的，如果你在 <code>git add -i</code> 之后做了修改可以通过 <code>status</code> 得知。</li><li><code>staged</code> 的 <code>unchanged</code> 表示 <code>HEAD</code> 和暂存区的该文件相同，即还<strong>未暂存</strong>该文件。</li><li><code>unstaged</code> 的 <code>nothing</code> 表示暂存区和工作目录的该文件相同，即<strong>已暂存</strong>该文件的全部修改。</li><li>注意，这里不会显示<strong>未跟踪的新文件</strong>。</li></ul></li><li><p><code>2 update</code>：</p><ul><li><p>它会问你想要暂存哪个文件，如果没有要暂存的文件（<strong>全部已暂存</strong>或<strong>未修改</strong>或<strong>未跟踪</strong>），则会直接退出，回到循环，否则显示：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">What now&gt; u<br>staged unstaged path<br>1: unchanged +0/-1 TODO<br>2: unchanged +1/-1 index.html<br>3: unchanged +5/-1 lib/simplegit.rb<br><span class="hljs-meta">Update&gt;</span><span class="bash">&gt;</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>如果要暂存 <code>TODO</code> 和 <code>index.html</code> 文件，可以输入数字或<strong>区间</strong>（本例中等价于输入 <code>1-2</code>），用<strong>空格或逗号</strong>隔开：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">Update&gt;</span><span class="bash">&gt; 1,2</span><br>staged unstaged path<br>   *1: unchanged +0/-1 TODO<br>   *2: unchanged +1/-1 index.html<br>3: unchanged +5/-1 lib/simplegit.rb<br><span class="hljs-meta">Update&gt;</span><span class="bash">&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>每个文件前面的 <code>*</code> 意味着<strong>选中</strong>的文件将会被暂存。</p></li><li><p>如果要取消选中的 <code>TODO</code> 和 <code>index.html</code> ，使用 <code>-1 -2</code> 即可。</p></li><li><p>如果在 <code>Update&gt;&gt;</code> 提示符后不输入任何东西并直接<strong>按回车</strong>，Git 将会暂存选择的文件。</p></li></ul></li><li><p><code>3 revert</code>：</p><ul><li>显示已经<strong>暂存的文件</strong>，操作方式和 <code>2 update</code> 相同，选中并 <code>revert</code> 表示将<strong>暂存区的该文件</strong>恢复到 <code>HEAD</code> 状态，相当于 <code>git restore --staged 文件路径</code>。</li><li>对于加入暂存区的新文件，该操作会将该文件重新变为 <code>untracked</code> 状态。</li></ul></li><li><p><code>4 add untracked</code>：</p><p>显示未跟踪的新文件，操作方式同上，操作相当于 <code>git add 未跟踪文件</code>。</p></li><li><p><code>5 patch</code>：</p><p>高端操作，只暂存<strong>某个文件</strong>的部分修改，看起来挺复杂的，先不记了 🦥</p></li><li><p><code>6 diff</code>：</p><p>显示已暂存的文件，操作方式同上，操作相当于 <code>git diff --cached</code>，比较的是 <code>HEAD</code> 和暂存区文件的差异。</p></li><li><p><code>7 quit</code>：润🏃🏻</p></li></ul><div class="note note-success">            <p>当你在修改了大量文件后，希望这些改动能拆分为若干提交而不是混杂在一起成为一个提交时，交互式暂存会非常有用。</p>          </div><h3 id="Git-stash-💾"><a href="#Git-stash-💾" class="headerlink" title="Git stash 💾"></a>Git stash 💾</h3><ul><li><p>应用背景：</p><p>当你在项目的一部分上已经工作一段时间后，所有东西都进入了混乱的状态，而这时你想要切换到另一个分支做别的事。问题是，Git 可能不允许在已修改的工作目录执行<strong>切换分支</strong>命令，你不想仅仅因为这些不成熟的修改创建一次提交。 针对这个问题的答案是使用 <code>git stash</code> 命令。</p></li><li><p><code>stash</code> 会处理工作目录的脏的状态（即<strong>跟踪文件的修改</strong>与<strong>暂存区的改动</strong>），然后将<strong>未完成的修改</strong>保存到一个栈上，而你可以在任何时候重新应用这些改动（甚至在<strong>不同的分支</strong>上）。</p></li><li><p>执行 <code>git stash</code> 或 <code>git stash push</code>（在不带选项和参数的情况下两者等价），将<strong>工作目录和暂存区</strong>的修改贮藏到栈顶，同时将这两棵树还原到 <code>HEAD</code> 状态。</p></li><li><p><code>git stash -m "描述"</code>，给这个贮藏记录像提交记录一样写描述文字</p></li><li><p><code>git stash -k</code>，在贮藏<strong>工作目录和暂存区</strong>的修改的同时，只还原工作目录到 <code>HEAD</code> 状态，保持暂存区修改不变。</p></li><li><p><code>git stash -u</code>，默认情况下，<code>git stash</code> 只会贮藏<strong>已修改和暂存的已跟踪</strong>文件。如果指定 <code>-u</code> 选项，Git 也会贮藏任何<strong>未跟踪</strong>文件。甚至对于<strong>已忽略</strong>的文件，使用 <code>-a</code> 选项也可以贮藏。</p></li><li><p><code>git stash list</code> 查看贮藏栈中的情况：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">stash@{0}: on master: using git stash -m message<br>stash@{1}: WIP on master: c264051 Revert "added file_size"<br>stash@{2}: WIP on master: 21d80a5 added number to log<br></code></pre></td></tr></tbody></table></figure><p>栈顶为 <code>stash@{0}</code>，它使用了 <code>-m</code> 选项的贮藏命令。</p><p>可以用 <code>stash@{n}</code> 来指代任意贮藏记录，在命令格式中使用 <code>&lt;stash&gt;</code> 表示。</p></li><li><p><code>git stash show [&lt;stash&gt;]</code>：</p><p>显示某条贮藏记录的 <code>diff</code> 差异，不带 <code>&lt;stash&gt;</code> 参数时默认显示栈顶贮藏记录。</p></li><li><p><code>git stash pop [--index] [&lt;stash&gt;]</code>：</p><ul><li>删除栈顶或 <code>&lt;stash&gt;</code> 的贮藏记录，同时应用在当前<strong>工作目录</strong>。</li><li>如果产生<strong>冲突</strong>，则需要在解决冲突后，使用 <code>git add .</code> 并 <code>git commit</code> 解决冲突状态。注意这种情况 Git <strong>不会自动删除</strong>栈中对应贮藏记录。可以使用 <code>drop</code> 删除（后面有讲）。</li><li>使用 <code>--index</code> 选项，会将贮藏记录的修改应用到当前<strong>暂存区</strong>。</li></ul></li><li><p><code>git stash apply [--index] [&lt;stash&gt;]</code>：</p><p>除了<strong>不删除</strong>贮藏记录外，功能完全相同，用得较多。</p></li><li><p><code>git stash drop [&lt;stash&gt;]</code>：</p><p>删除栈顶或 <code>&lt;stash&gt;</code> 的贮藏记录。</p></li><li><p><code>git stash clear</code>：</p><p>删除所有贮藏记录。</p></li><li><p><code>git stash branch &lt;branchname&gt; [&lt;stash&gt;]</code>：</p><ul><li>对于一些会对当前节点<strong>发生冲突</strong>的贮藏记录，可以通过在<strong>贮藏记录原本的提交节点</strong>新建一个分支，应用贮藏的所有修改，进行测试处理。</li><li>因为是在本来的节点上新建分支，所以是<strong>不会发生冲突</strong>的（本来就在这个节点基础上做的修改）。</li><li>该命令会删除栈顶或 <code>&lt;stash&gt;</code> 的贮藏记录，并同时对<strong>暂存区和工作目录</strong>产生影响。</li></ul></li></ul><h3 id="Git-clean-🧹"><a href="#Git-clean-🧹" class="headerlink" title="Git clean 🧹"></a>Git clean 🧹</h3><ul><li><p>常用格式：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git clean [-d] [-x | -X] -i [--] [文件路径]</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>命令可以用于清理不在版本控制范围内的文件，即<strong>未跟踪</strong>的文件，但不清理<strong>已忽略</strong>的文件。</p></li><li><p>命令默认只清理 <code>.git</code> 所知文件夹下的文件，<strong>不清理未跟踪文件夹</strong>下的文件。</p></li><li><p>如果指定了<strong>文件路径</strong>，那么 <code>-d</code> 和 <code>-x | -X</code> 都不生效。 </p></li><li><p><code>-d</code> 选项：</p><p>递归进入<strong>未跟踪的文件夹</strong>下清理文件。</p></li><li><p><code>-x</code> 选项：</p><p>清理范围包括<strong>已忽略</strong>的文件。</p></li><li><p><code>-X</code> 选项：</p><p>清理范围<strong>只包括已忽略</strong>的文件。</p></li><li><p><code>-i</code> 选项：</p><ul><li><p>推荐使用该命令时都加上 <code>-i</code> 选项，使用交互式清理方式，一目了然要清理哪些文件。</p></li><li><p>显示的交互界面如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git clean -i</span><br>Would remove the following item:<br>  a b c<br>*** Commands ***<br>    1: clean                2: filter by pattern    3: select by numbers<br>    4: ask each             5: quit                 6: help<br></code></pre></td></tr></tbody></table></figure></li><li><p><code>1 clean</code>：</p><p>删除 <code>Would remove the following item:</code> 下的文件，并退出交互模式。</p></li><li><p><code>2 filter by pattern</code>：</p><p>列出当前删除范围内的文件，输入 <code>*.txt</code> 等文件类型进行过滤，过滤的文件<strong>移出</strong>删除范围：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git clean -i</span><br>Would remove the following items:<br>  1/1.md   1/1.txt<br>*** Commands ***<br>    1: clean                2: filter by pattern    3: select by numbers<br>    4: ask each             5: quit                 6: help<br>What now&gt; 2<br>  1/1.md   1/1.txt<br>Input ignore patterns&gt;&gt; *.md<br>  1/1.txt<br>Input ignore patterns&gt;&gt;<br>Would remove the following item:<br>  1/1.txt<br>*** Commands ***<br>    1: clean                2: filter by pattern    3: select by numbers<br>    4: ask each             5: quit                 6: help<br>What now&gt;<br></code></pre></td></tr></tbody></table></figure><p>输入 <code>*.md</code>，不删除 <code>1.md</code> 文件。</p></li><li><p><code>3 select by numbers</code>：</p><p>按顺序列出删除范围内的文件，通过数字进行选择哪些文件要删除：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git clean -i</span><br>Would remove the following items:<br>  1/1.md   1/1.txt<br>*** Commands ***<br>    1: clean                2: filter by pattern    3: select by numbers<br>    4: ask each             5: quit                 6: help<br>What now&gt; 3<br>    1: 1/1.md     2: 1/1.txt<br>Select items to delete&gt;&gt; 2<br>    1: 1/1.md   * 2: 1/1.txt<br>Select items to delete&gt;&gt;<br>Would remove the following item:<br>  1/1.txt<br>*** Commands ***<br>    1: clean                2: filter by pattern    3: select by numbers<br>    4: ask each             5: quit                 6: help<br>What now&gt;<br></code></pre></td></tr></tbody></table></figure></li><li><p><code>4 ask each</code>：</p><p>逐个询问在删除范围内的文件，是否要删除，全部询问后退出交互模式：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git clean -i</span><br>Would remove the following items:<br>  1/1.md   1/1.txt<br>*** Commands ***<br>    1: clean                2: filter by pattern    3: select by numbers<br>    4: ask each             5: quit                 6: help<br>What now&gt; 4<br>Remove 1/1.md [y/N]? n<br>Remove 1/1.txt [y/N]? y<br>Removing 1/1.txt<br></code></pre></td></tr></tbody></table></figure></li></ul></li></ul><h3 id="Git-Cherry-pick-🌸"><a href="#Git-Cherry-pick-🌸" class="headerlink" title="Git Cherry-pick 🌸"></a>Git Cherry-pick 🌸</h3><ul><li><p>命令格式很简单：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git cherry-pick [-n] [-m] 可以多个&lt;commit&gt;</span><br><span class="hljs-meta">$</span><span class="bash"> git cherry-pick (--<span class="hljs-built_in">continue</span> | --skip | --abort | --quit)</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>拣选一个或多个提交的修改到 <code>HEAD</code> 下，例如原分支情况如下：</p><div align="center"><img src="../img/blog/git-note-images/cherry1.png"></div><p>​    执行命令 <code>git cherry-pick C3 C4 C7</code> 后，分支变成：</p><div align="center"><img src="../img/blog/git-note-images/cherry2.png"></div></li><li><p>要求执行命令前保持 <code>working tree clean</code>，可能要像 <code>git merge</code> 一样合并冲突，合并后使用 <code>git add</code> 和 <code>git cherry-pick --continue</code> 生成新的提交。</p></li><li><p><code>-n</code> 选项：</p><p>合并后不自动生成提交，并且退出 <code>CHERRY-PICKING</code> 状态，即不能再使用 <code>git cherry-pick [--continue | --skip | --abort | --quit]</code> 等命令，需要手动 <code>git commit</code> 生成提交。</p></li><li><p><code>-m</code> 选项：</p><p>拣选不能选择合并提交的节点，除非使用 <code>-m &lt;parent-number&gt;</code>，<code>&lt;parent-number&gt;</code> 指的是哪个父节点，相当于之前说的相对引用 <code>^&lt;parent-number&gt;</code> </p></li><li><p><code>--continue</code> 都很熟悉了；<code>--skip</code> 跳过当前某个 <code>cherry-pick</code> 的提交；<code>--abort</code> 终止整个 <code>cherry-pick</code> 过程并还原到初始状态；<code>--quit</code> 退出 <code>CHERRY-PICKING</code> 状态，可以中途退出拣选过程，不完成整个过程。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>科技笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库系统笔记</title>
    <link href="/Database_System.html"/>
    <url>/Database_System.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>这是 HITsz 数据库系统笔记，<a href="https://github.com/ailanxier/Database-System-Note">欢迎到我的 GitHub 上查看，有笔记说明和源码，作业和实验报告</a>，希望对你有帮助</p><p><del>因为写笔记的软件为 Typora，对 markdown 的支持较为完善，转移到博客平台可能存在数学公式错误</del></p></blockquote><h2 id="数据库基本概念"><a href="#数据库基本概念" class="headerlink" title="数据库基本概念"></a>数据库基本概念</h2><h3 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h3><blockquote><p>通过抽象来对用户屏蔽复杂性，以简化用户与系统的交互。</p></blockquote><ul><li><p>物理层（或内部层）：</p><p>​    <strong>最低层次</strong>的抽象，描述数据实际上是<strong>怎样存储的</strong>和复杂的底层数据结构（存储路径、存储方式、索引方式）。</p></li><li><p>逻辑层（或概念层）：</p><p>​    比物理层层次稍高的抽象，描述数据库中<strong>存储什么数据</strong>及这些<strong>数据间关系</strong>。</p></li><li><p>视图层（或外部层）：</p><p>​    最高层次的抽象，只描述整个数据库的<strong>某个部分</strong>。用于并不需要关心所有的信息，而只需要访问数据库的一部分的用户。同一数据库有<strong>多个视图</strong>。</p></li><li><p>实例：</p><p>​    特定时刻存储在数据库中的信息的集合称作数据库的一个<strong>实例</strong>。</p></li><li><p>模式：</p><p>​    数据库的总体设计称作数据库<strong>模式</strong>（schema），是对数据库中<strong>数据</strong>所进行的一种<strong>结构性的描述</strong>。</p><blockquote><p>数据库<strong>模式</strong>对应于程序设计语言中的<strong>变量声明</strong>（以及与之关联的类型的定义）。</p><p>每个变量在特定的时刻会有特定的值，程序中变量在<strong>某一时刻的值</strong>对应于数据库模式的一个<strong>实例</strong>。</p></blockquote></li><li><p>在不同抽象层次描述数据库，就可定义出<strong>物理模式，逻辑模式和视图模式</strong>。</p></li><li><p>相同模式有不同名称：</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">视图英文</th><th style="text-align:center"></th><th style="text-align:center">三级模式两层映像结构中的名字</th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">External Schema</td><td style="text-align:center">外模式</td><td style="text-align:center">局部模式🗡</td><td style="text-align:center">视图模式</td><td style="text-align:center">用户模式</td><td style="text-align:center">子模式</td></tr><tr><td style="text-align:center">(Conceptual) Schema</td><td style="text-align:center">概念模式</td><td style="text-align:center">全局模式</td><td style="text-align:center">逻辑模式</td><td style="text-align:center">也可简称「模式」</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Internal Schema</td><td style="text-align:center">内模式</td><td style="text-align:center">物理模式</td><td style="text-align:center">存储模式</td><td style="text-align:center"></td></tr></tbody></table></div><ul><li><p>两层映像：</p><ul><li><p>E-C Mapping（External Schema-Conceptual Schema Mapping）：</p><p>​    将<strong>外模式</strong>映射为<strong>概念模式</strong>，从而支持实现数据概念视图向外部视图的转换，便于用户观察和使用。</p><blockquote><p>逻辑数据独立性🗡</p><p>​    当概念模式变化时，可以不改变外部模式（只需改变 E-C Mapping），从而无需改变应用程序。</p></blockquote></li><li><p>C-I Mapping（Conceptual Schema-Internal Schema Mapping）：</p><p>​    将<strong>概念模式</strong>映射为<strong>内模式</strong>，从而支持实现数据概念视图向内部视图的转换，便于计算机进行存储和处理。</p><blockquote><p>物理数据独立性：</p><p>​    当内部模式（物理模式）变化时，可以不改变概念模式（只需改变 C-I Mapping），从而不改变外部模式。</p></blockquote></li></ul></li></ul><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><blockquote><p>数据库结构的基础是数据模型。</p></blockquote><ul><li><p>PPT 中的分类（往年考过三个模型的优缺点🗡）：</p><ul><li><p>层次模型按树的形式组织数据：</p><p><img src="/img/blog/ds-note-images/image-20211118124141153.png" style="zoom:67%;"></p><ul><li>优点：<ul><li>数据<strong>结构简单清晰</strong>。</li><li><strong>查询效率高</strong>。记录之间的联系用有向边表示，这种联系在 DBMS 中通常使用指针实现。</li><li><strong>性能</strong>优于关系数据库，不低于网状数据库。</li><li>提供了良好的<strong>完整性支持</strong>。</li></ul></li><li>缺点：<ul><li>对于<strong>非层次</strong>的联系（如多对多的联系）不适用。</li><li>一个子节点可能有<strong>多个父节点导致冗余</strong>，操作复杂。</li><li>必须通过父节点才能查找子节点。</li></ul></li></ul></li><li><p>网状模型按图的形式组织数据：</p><p><img src="/img/blog/ds-note-images/image-20211118124756242.png" style="zoom:67%;"></p><ul><li><p>优点：</p><p>​    能够更为直接地表示现实世界，具有良好的性能，<strong>存取效率高</strong>。</p></li><li><p>缺点：</p><ul><li><strong>结构复杂</strong>。</li><li>网状模型的数据定义语言和数据管理<strong>语言复杂</strong>。</li><li>应用<strong>程序编写困难</strong>。</li></ul></li></ul><blockquote><p>层次结构和网状结构共有的缺点：</p><ul><li>数据之间的关联关系由复杂的<strong>指针系统</strong>来维系，结构描述复杂</li><li>数据检索操作依赖于由指针系统指示的<strong>路径</strong></li><li>不能有效支持<strong>记录集合的操作</strong></li></ul></blockquote></li><li><p>关系模型按表的形式组织数据：</p><p>​    优点：</p><ul><li>数据检索操作<strong>不依赖于路径信息</strong>或过程信息，支持<strong>非过程化的数据操作</strong></li><li>有效支持<strong>记录集合</strong>的操作</li><li>较为完善的理论基础</li></ul></li></ul></li><li><p>书上的分类：</p><ul><li><p>关系模型：</p><p>​    用<strong>表</strong>的集合来表示<strong>数据和数据间的联系</strong>。</p></li><li><p>实体 - 联系（E-R，entity-relationship）模型：</p><ul><li>基于对现实世界的认识。</li><li>现实世界由一组称作<strong>实体的基本对象</strong>以及这些<strong>对象间的联系</strong>构成。</li><li><strong>实体</strong>是现实世界中可<strong>区别于其他对象</strong>的一件「事情」或一个「物体」</li></ul><blockquote><p>关系模型是数据模型，而 E-R 模型是概念模型。</p></blockquote></li><li><p>基于对象的数据模型（应该不怎么学）</p></li></ul></li></ul><h3 id="数据库系统和语言"><a href="#数据库系统和语言" class="headerlink" title="数据库系统和语言"></a>数据库系统和语言</h3><ul><li><p>数据库系统：</p><ul><li>数据库（DB，Database） </li><li><strong>数据库管理系统</strong>（DBMS，Database Management System）</li><li>数据库应用（DBAP，DataBaseApplication） </li><li>数据库管理员（DBA，DataBaseAdministrator）</li></ul></li><li><p>数据库语言（DBMS 提供的）：</p><ul><li><p>数据定义语言（DDL，Data Definition Language）：</p><p>​    定义表名，表标题，列名及其结构形式。</p><blockquote><p>新数据插入时（更新数据库时）要检查<strong>完整性约束</strong>，防止不符合规范的数据进入数据库：</p><ul><li><p>域约束：</p><p>​    每个属性都必须对应于一个<strong>所有可能的取值构成的域</strong>（例如，整数型、字符型、日期/时间型）。域约束是完整性约束的最基本形式。</p></li><li><p>参照（引用）完整性：</p><p>​    一个关系中给定属性集上的取值也在另一关系的某一属性集的取值中出现。</p></li><li><p>断言：</p><p>​    一个断言就是数据库需要<strong>始终满足的某一条件</strong>（域约束和参照完整性约束是断言的特殊形式），例如：「每一学期每一个系必须至少开设 $5$ 门课程」只能表达成一个断言。如果断言有效，则以后只有不破坏断言的数据库更新才被允许。</p></li></ul></blockquote></li><li><p>数据操纵语言（DML，Data Manipulation Language）：</p><p>​    对数据库进行<strong>增、删、改、查</strong>等操作。</p></li><li><p>数据控制语言（DCL，Data Control Language）：</p><p>​    对不同操作和用户的约束。</p></li></ul></li></ul><h2 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li><p>表的列，也叫字段/属性/数据项，包括列名和列值。</p></li><li><p>表的行，也叫元组（$n$ 元组就是一个有 $n$ 个值的元组）/记录。</p></li><li><p>域：</p><p>​    对于关系的每个<strong>属性</strong>，都存在一个允许取值的集合（即<strong>域</strong>），这组值具有相同的数据类型。</p><blockquote><p>集合中元素的个数称为域的<strong>基数</strong>。</p></blockquote></li><li><p>域的笛卡尔积：</p><p>​    一组域 $D_1,D_2,\cdots,D_n$ 的笛卡尔积为：$D_1×D_2×\cdots×D_n = \{ (d_1 , d_2 , … , d_n) | d_i∈D_i , i=1,\cdots,n\}$，笛卡尔积每个元素 $(d_1 , d_2 , … , d_n)$ 称作一个 $n$ - 元组。</p></li><li><p>关系：</p><p>​    一组域 $D_1,D_2,\cdots,D_n$ 的笛卡尔积的<strong>子集</strong>。</p></li><li><p><strong>关系模式或表标题</strong>：</p><p>​    用 $R(A_1: D_1, A_2: D_2, \ldots, A_n: D_n)$ 表示，可简记为 $R(A_1, A_2, \ldots,A_n)$ 来描述关系：</p><ul><li>$R$ 是关系的名字。</li><li>$A_i$ 是<strong>属性</strong>。</li><li>$D_i$ 是属性所对应的<strong>域</strong>（属性的类型、长度）。</li><li>$n$ 是关系的<strong>度或目</strong>，即有多少列。</li><li>关系模式中 $A_i (i = 1,\cdots,n)$ 必须是不同的, 而 $D_i(i = 1,\cdots,n)$ 是可以相同的。</li></ul></li></ul><h3 id="关系的特性"><a href="#关系的特性" class="headerlink" title="关系的特性"></a>关系的特性</h3><ul><li><p>列是同质：</p><p>​    每一列中的列值来自同一域，是同一类型的数据。</p></li><li><p>不同的列可来自同一个域</p></li><li><p>列位置互换性：</p><p>​    区分哪一列是靠列名，与列的顺序无关。</p></li><li><p>行位置互换性：</p><p>​    区分哪一行是靠某一或某几列的值（关键字/键字/码字）。</p></li><li><p>任意两个元组不能完全相同</p></li><li><p>属性不可再分特性（关系第一范式）</p></li></ul><h3 id="码（键）"><a href="#码（键）" class="headerlink" title="码（键）"></a>码（键）</h3><ul><li><p>超码（superkey）：</p><p>​    <strong>超码</strong>是一个或多个属性的集合，这些属性的组合可以使我们在一个关系中<strong>唯一地标识一个元组</strong>。</p><blockquote><p>两个不同元组的超码属性的取值不会完全相同。</p></blockquote></li><li><p>候选码：</p><p>​    如果一个超码的任意真子集都不能成为超码，这样的最小超码称为<strong>候选码</strong>。</p></li><li><p>主码：</p><p>​    当有多个候选码时，可以选定一个作为<strong>主码</strong>。</p></li><li><p>主属性与非主属性：</p><p>​    包含在<strong>任何一个候选码</strong>中的属性被称作<strong>主属性</strong>，其他属性被称作<strong>非主属性</strong>。</p><blockquote><p>如果关系的所有属性组是这个关系的候选码，称为<strong>全码</strong>。</p></blockquote></li><li><p>外码：</p><p>​    关系 $R$ 中的一个属性组，它不是 $R$ 的候选码，但它与另一个关系候选码（主码）相对应，则称这个属性组为 $R$ 的<strong>外码</strong>。</p></li></ul><h3 id="关系模型中的完整性"><a href="#关系模型中的完整性" class="headerlink" title="关系模型中的完整性"></a>关系模型中的完整性</h3><ul><li><p><strong>实体完整性</strong>：</p><p>​    关系的<strong>主码</strong>中的属性值不能为<strong>空值</strong>。</p></li><li><p><strong>参照完整性</strong>：</p><p>​    如果关系 $R_1$ 的<strong>外码</strong> $a$ 与关系 $R_2$ 的<strong>主码</strong> $a$ 相对应，则 $R_1$ 中的<strong>每一个元组</strong>的 $a$ 值或者等于 $R_2$ 中<strong>某个元组</strong>的 $a$ 值，或者为<strong>空值</strong>。</p></li><li><p>用户自定义完整性：</p><p>​    用户针对具体的应用环境定义的完整性约束条件。</p></li></ul><blockquote><p>这一章缺少了很关键的关系代数。</p></blockquote><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><h3 id="实体-联系（E-R）模型"><a href="#实体-联系（E-R）模型" class="headerlink" title="实体-联系（E-R）模型"></a>实体-联系（E-R）模型</h3><ul><li><p>E-R 模型的基本观点：</p><p>​    世界是由一组称作<strong>实体的基本对象和这些对象之间的联系</strong>构成的。</p></li><li><p>实体：</p><p>​    <strong>实体</strong>是现实世界中可区别于所有其他对象的一个「事物」或「对象」。每个实体有一组性质（属性），其中一些性质的值可以唯一地标识一个实体。</p></li><li><p>实体集：</p><p>​    <strong>实体集</strong>是相同类型即具有相同性质（或属性）的一个实体集合。</p><blockquote><p>注意：以上是书中的定义，PPT 中的「实体」= 书中的「实体集」，PPT 的「实例」= 书中的「实体」。</p><p>以下采用书本的定义描述。</p></blockquote></li><li><p>联系集：</p><ul><li><p><strong>联系</strong>是指<strong>多个实体间</strong>的相互关联。</p></li><li><p><strong>联系集</strong>是相同类型联系的集合。正规地说，联系集是 $n \geqslant 2$ 个（可能相同的）实体集上的数学关系。如果 $E_1, E_2, \cdots, E_{n}$ 为实体集，那么联系集 $R$ 是</p><script type="math/tex; mode=display">\{(e_1, e_2, \cdots, e_{n}) \mid e_1 \in E_1, e_2 \in E_2, \cdots, e_{n} \in E_{n}\}</script><p>的一个<strong>子集</strong>（相当于实体集笛卡尔积的一个子集），而 $(e_1, e_2, \cdots, e_{n})$ 是一个<strong>联系</strong>，$e_i$ 是 $E_i$ 的属性集合的子集。</p><blockquote><p>实体集之间的联系称为<strong>参与</strong>。实体集 $E_1, E_2, \cdots, E_{n}$ 参与联系集 $R$。</p><p>举例：实体集 $Student,Course$ 参与联系集 $SC$。</p></blockquote></li><li><p>参与联系集的<strong>实体集的数目</strong>称为联系集的<strong>度</strong>。</p></li><li><p>实体在联系中扮演的功能称为实体的<strong>角色</strong>。</p></li></ul></li><li><p>属性：</p><ul><li><p>每个属性都有一个可取值的集合，称为该属性的<strong>域或者值集</strong>。</p></li><li><p>属性的分类：</p><ul><li><p>简单（单一）属性：</p><p>​    它们不能划分为更小的部分。</p></li><li><p>复合属性：</p><p>​    将属性再划分为更小的部分（即其他属性）。</p><blockquote><p>地址细分（省市）</p></blockquote></li><li><p>单值属性：</p><p>​    对一个特定实体，一个属性都只有<strong>单独的一个值</strong>。</p></li><li><p>多值属性：</p><p>​    对某个特定实体而言，一个属性可能对应于<strong>一组值</strong>（即一个属性可以取多个值）。</p><blockquote><p>一个人有多个电话号码</p></blockquote></li></ul></li></ul></li><li><p>联系集的类型：</p><ul><li><p>一对一：</p><p>​    $A$ 中的一个实体<strong>至多</strong>与 $B$ 中的一个实体相关联，并且 $B$ 中的一个实体也至多与 $A$ 中的一个实体相关联。</p></li><li><p>一对多：</p><p>​    $A$ 中的一个实体可以与 $B$ 中的任意数目（零个或多个）实体相关联，而 $B$ 中的一个实体至多与 $A$ 中的一个实体相关联。</p></li><li><p>多对一：</p><p>​    $A$ 中的一个实体至多与 $B$ 中的一个实体相关联，而 $B$ 中的一个实体可以与 $A$ 中任意数目（零个或多个）实体相关联。</p></li><li><p>多对多：</p><p>​    $A$ 中的一个实体可以与 $B$ 中任意数目（零个或多个）实体相关联，而且 $B$ 中的一个实体也可以与 $A$ 中任意数目（零个或多个）实体相关联。</p></li></ul></li><li><p>映射基数（联系的基数🗡）：</p><p>​    实体之间的联系的数量，即<strong>一个实体</strong>通过一个<strong>联系</strong>能与<strong>另一实体集相关联的实体的数目</strong>。</p></li><li><p>实体集和二元联系集之间的一条边，可以有一个关联的<strong>最大和最小的映射基数</strong>。</p><blockquote><p>例如：</p><div align="center"><img src="/img/blog/ds-note-images/image-20211004133238514.png"></div><p>一个 instructor 可以对应 <strong>$0$ 个或多个</strong> student，但一个 student <strong>有且仅有一个</strong> instructor，注意 advisor 是从 instructor 到 student的<strong>一对多</strong>联系。</p><p>笔者注：</p><p>​    PPT 上的基数很多地方是反了，应该是自己的基数写在自己旁边（不知道祖传错误是否已被更正）</p></blockquote></li><li><p>参与约束：</p><ul><li><p>完全参与联系：</p><p>​    如果实体集 $E$ 中的<strong>每个实体</strong>都参与到联系集 $R$ 的<strong>至少一个</strong>联系中，此时最小基数为 $1$。</p></li><li><p>部分参与联系：</p><p>​    如果 $E$ 中只有<strong>部分实体</strong>参与到 $R$ 的联系中，此时最小基数为 $0$。</p></li></ul></li><li><p>弱实体集和强实体集：</p><ul><li>没有<strong>足够的属性以形成主码</strong>的实体集称作<strong>弱实体集</strong>（从属实体集）。</li><li>有<strong>主码</strong>的实体集称作<strong>强实体集</strong>（独立实体集）。</li></ul></li></ul><h3 id="数据库设计-1"><a href="#数据库设计-1" class="headerlink" title="数据库设计"></a>数据库设计</h3><ul><li><p>需求分析：</p><p>​    形成数据库设计的「源」清单和「属性」清单。</p></li><li><p>概念数据库设计：</p><ul><li><p>用统一的表达方法，如 E-R 模型给出描述：</p><ul><li><p>各种实体的发现、划分和定义</p></li><li><p>各种实体属性的发现、分析和定义</p></li><li>各种实体联系的发现、分析和定义</li><li>外部视图（模式）和概念视图（模式）的定义</li></ul></li><li><p>消除冲突：</p><ul><li>属性冲突：<ul><li>属性域的冲突（属性的类型、取值范围不同）</li><li>属性取值单位冲突</li></ul></li><li>结构冲突：<ul><li>同一对象在不同应用中的抽象不同（职工在某应用中是实体，在另一应用中则抽象为属性）</li><li>同一实体在不同 E-R 图中属性组成不同</li><li>实体之间的联系在不同 E-R 图中呈现不同的类型</li></ul></li><li>命名冲突（同名异义，异名同义）</li></ul></li></ul></li><li><p>逻辑数据库设计：</p><ul><li><p>E-R 图转换为关系模式：</p><ul><li><p>复合属性转化：</p><ul><li>拆成多列单一属性。</li><li>或者作为一个新的关系，每个分量为新关系的属性。</li></ul></li><li><p>多值属性转化：</p><ul><li>将<strong>多值属性</strong>与所在实体的<strong>关键字</strong>一起组成一个新的关系。</li><li>也可以像复合属性一样拆成多列。</li></ul></li><li><p>一对一联系：</p><ul><li>若联系双方<strong>均部分参与</strong>，则将<strong>联系</strong>定义为一个<strong>新的关系</strong>，属性为参与双方的关键字（主码）属性。</li><li>若联系<strong>一方全部参与</strong>，则将<strong>另一方关键字</strong>作为<strong>全部参与方</strong>的<strong>属性</strong>（即多一个属性），不需要联系集（感觉是 PPT 说反了）。</li></ul></li><li><p>一对多联系：</p><p>​    将<strong>单方</strong>（如教师和学生关系中的教师）参与实体的关键字，作为<strong>多方</strong>（学生）参与实体对应关系的属性。</p></li><li><p>多对多联系：</p><p>​    将联系定义为<strong>新的关系</strong>，属性为参与<strong>双方实体的关键字</strong>。</p></li></ul></li><li><p>冗余（没懂）：</p><ul><li><p>受控冗余：</p><p>​    有时为了效率和便利，会特意设计冗余数据。</p></li><li><p>非受控冗余：</p><p>​    存在传递函数依赖。</p></li></ul></li></ul></li></ul><h3 id="函数依赖🗡"><a href="#函数依赖🗡" class="headerlink" title="函数依赖🗡"></a>函数依赖🗡</h3><ul><li><p>函数依赖定义：</p><ul><li><p>设 $ R$ 是属性集合 $U=\{A_1, A_2, \ldots, A_{n}\}$ 上的一个关系模式，$X, Y$ 是<strong>属性集</strong> $U$ 上的两个<strong>子集</strong>。</p></li><li><p>若对 $R$ 的任意关系 $r$，$ r$ 中<strong>不可能有两个元组</strong>满足在 $X$ 中的属性值相等而在 $Y$ 中的属性值不等，则称「$X$ 函数决定 $Y$」或「$Y$ 函数依赖于  $X$」，记作 $X \rightarrow Y$，称 $X$ 为决定因素，$Y$ 为依赖因素。</p><blockquote><p>关系模式是在属性集合上的结构化描述，关系是表状结构的。</p><p>函数依赖，顾名思义，$X$ 映射到 $Y$，同一个 $x$ 不会映射到两个 $y$。</p></blockquote></li></ul></li><li><p>函数依赖的特性：</p><ul><li><p>如果 $Y \subset X$，则有 $X\to Y$，这是平凡的函数依赖。</p></li><li><p>对 $ X \rightarrow  Y$，但 $ Y \not \subset  X$，则称 $X\rightarrow  Y$ 为<strong>非平凡的函数依赖</strong>。</p></li><li>若 $X \rightarrow Y, Y \rightarrow X$，则记作 $X \leftrightarrow Y$。</li><li>若 $Y$ 不函数依赖于 $X$. 则记作 $X \not\rightarrow Y$。</li><li>$ X \rightarrow  Y$，若是基于模式 $R$ 的，则对任意的关系 $r$ 成立；若仅基于具体关系 $r$ 的，则可能只对该关系 $r$ 成立。</li><li>如一关系 $r$ 的某属性集 $X$，$r$ 中<strong>没有 $X$ 上相等的两个元组</strong>，则 $ X \rightarrow  Y$ 恒成立。</li></ul></li><li><p>完全函数依赖和部分函数依赖：</p><p>​    在 $R$ 中，若 $X \rightarrow Y$ 并且对于 $X$ 的任何真子集 $X’$ 都有 $X’\not\rightarrow Y$，则称 $Y$ <strong>完全（full）函数依赖</strong>于 $X$，记为$X\stackrel{f}\rightarrow Y$，否则称 $Y$ <strong>部分（partial）函数依赖</strong>于 $X$，记为 $X \stackrel{p}\to Y$。</p><blockquote><p> $R$ 是属性集合 $U$ 上的一个关系模式，若 $X \subset U$ 且 $X\stackrel{f}\rightarrow U$，则称 $X$ 为 $R$ 的<strong>候选键</strong>（候选码）。</p></blockquote></li><li><p>传递函数依赖：</p><p>​    在 $R$ 中，若 $X\to Y,Y \to Z$，其中 <strong>$Y\not\subset X,Z\not\subset Y,Z\not\subset X,Y\not\to X$</strong>（说明都是<strong>非平凡依赖</strong>），则称 $Z$ <strong>传递函数依赖</strong>于 $X$。</p><blockquote><p>传递依赖的判定很严格，仅满足 $X\to Y,Y \to Z$ 是不够的，要特别注意。</p></blockquote></li><li><p>逻辑蕴涵：</p><p>​    设 $F$ 是关系模式 $R$ 的一个<strong>函数依赖集合</strong>，$X,Y$ 是 $R$ 的属性子集，若从 $F$ 的函数依赖能够推导出 $X \rightarrow Y$，则称 $F$ 逻辑蕴涵 $X \rightarrow Y$，记作 $F \models X \rightarrow Y$。</p></li><li><p>闭包：</p><p>​    令 $F$ 为一个函数依赖集，$F$ 的<strong>闭包</strong>是被 $F$ <strong>逻辑蕴涵的所有函数依赖</strong>的集合, 记作 $F^{+}$。若 $F^+=F$，则 $F$ 是一个<strong>全函数依赖族（函数依赖完备集）</strong>。</p><blockquote><p>在下面的规则中去寻找逻辑蕴涵的函数依赖，通过反复应用这些规则，可以找到给定 $F$ 的全部 $F^{+}$。</p><p>用希腊字母 $(\alpha, \beta, \gamma, \cdots)$ 表示属性集，用 $\alpha \beta$ 表示 $\alpha \cup \beta_{\circ}$</p><p>这组规则称为 Armstrong 公理（据说不怎么会考）：</p><ul><li><p>自反律：</p><p>​    若 $\alpha$ 为一属性集且 $\beta \subseteq \alpha$，则 $\alpha \rightarrow \beta$ 成立。</p></li><li><p>增补律：</p><p>​    若 $\alpha \rightarrow \beta$ 成立且 $\gamma$ 为一属性集，则 $\gamma \alpha \rightarrow \gamma \beta$ 和 $\gamma \alpha \rightarrow \beta$ 成立。</p></li><li><p>传递律：</p><p>​    $\alpha \rightarrow \beta$ 和 $\beta \rightarrow \gamma$ 成立，则 $\alpha \rightarrow \gamma$ 成立。</p></li></ul><p>公理可导出的比较好用的引理：</p><ul><li><p><strong>合并律</strong>：</p><p>​    若 $\alpha \rightarrow \beta$ 和 $\alpha \rightarrow \gamma$ 成立, 则 $\alpha \rightarrow \beta \gamma$ 成立。</p></li><li><p><strong>分解律</strong>：</p><p>​    若 $\alpha \rightarrow \beta \gamma$ 成立, 则 $\alpha \rightarrow \beta$ 和 $\alpha \rightarrow \gamma$ 成立。</p></li><li><p>伪传递律：</p><p>​    若 $\alpha \rightarrow \beta$ 和 $\gamma \beta \rightarrow \delta$ 成立, 则 $\alpha \gamma \rightarrow \delta$ 成立（由 $\alpha \rightarrow \beta$ 得到 $\gamma\alpha \rightarrow \gamma\beta$，再由传递律得到结论）。</p></li></ul></blockquote></li><li><p>属性集闭包 🗡</p><p>​    对 $R(U, F), X \subseteq U, U=\{  A_1, A_2, \ldots, A_n\}$，令 $X^+_F=\{ A_i\quad \mid \quad用 \quad \text{Armstrong} \quad 公理可从 \quad F \quad 导出\quad X \rightarrow  A_i\} $，称 $ X^+_F$ 为 $X$ 于 $F$ 的<strong>属性集闭包</strong>。<br>显然 $X \subseteq X^+_F$。</p><blockquote><p>引理：</p><p>​    $ X \rightarrow   Y$, 当且仅当 $  Y \subseteq   X^+_F$。</p></blockquote></li><li><p>求 $X$ 的属性集闭包的算法🗡：</p><ol><li><p>令 $X_0=X$</p></li><li><p>$B=\{A\mid(\exists V)(\exists W)(V\to W)\in F \quad \mathbf{and}\quad V\subseteq X_i\quad \mathbf{and} \quad A\subseteq W\}$（对 $F$ 中的任意元素 $V\to W$ 检查，如果 $V$ 已在 $X_i$ 中，则把 $W$ 的属性加入到 $X_{i+1}$ 中）</p></li><li><p>$X_{i+1}=B\cup X_i$</p></li><li><p>$\mathbf{if~} X_{i+1}\ne X_i \mathbf{~then}$: </p><p>​    $i=i+1$</p><p>​    $\bf goto~ 2$（如果这轮检查仍有新的元素加入，则下一次迭代也可能有未被检查过的元素加入，否则算法结束）</p></li><li><p>$X^+_F=X_i$</p></li></ol></li><li><p>覆盖：</p><p>​    对 $R(U)$ 上的两个函数依赖集合 $F,G$，如果 $F^+= G^+$，则称 $F$ 和 $G$ 是<strong>等价</strong>的，也称 $F$ <strong>覆盖</strong> $G$ 或者 $G$ 覆盖 $F$。</p></li><li><p>最小覆盖：</p><p>​    若 $F$ 满足以下条件，则称 $F$ 为<strong>最小覆盖（最小依赖集，最小等价依赖集）</strong>：</p><ul><li>$F$ 中<strong>每个函数依赖的右部是单个属性</strong>。</li><li>对任何 $\{X\to A\}\in F$，有 $F- \{ X\to A \}$ 不等价于 $F$。</li><li>对任何 $\{X\to A\} \in F$，$Z\subset X$，$(F- \{ X\to A \})\cup\{Z\to A\}$ 不等价于 $F$。</li></ul></li><li><p>求最小覆盖的算法：</p><ol><li><p>通过分解律「若 $\alpha \rightarrow \beta \gamma$ 成立, 则 $\alpha \rightarrow \beta$ 和 $\alpha \rightarrow \gamma$ 成立」，将原函数依赖集抄一遍，右部分解为单属性。</p></li><li><p>对任意 $X\to Y$，求 $X$ 对于 $F$ 剩余部分的属性闭包，若不包含 $Y$，则 $X\to Y$ 是必需的，否则删除。</p><blockquote><p>Tips：</p><p>​    对于<strong>仅在右部中出现一次的属性</strong>的那个依赖一定不会在这一步被删除，因为不可能有其他依赖能推出它了。</p></blockquote></li><li><p>对于任意 $XY\to Z$，考虑能否替换为 $X\to Z$。求 $X$ 在替换前依赖集的属性闭包，如果不包含 $Z$，则替换是不可行的。如果也不能替换成 $Y\to Z$，则$XY\to Z$ 是必需的。</p><blockquote><p>若 $X$ 在替换前依赖集的属性闭包包含 $Z$，说明本来就有依赖 $X\to Z$，又因为 $XY\to X$，所以又可以推出 $XY\to Z$，即 $XY\to Z$ 是多余的，可以用 $X\to Z$ 替换。 </p></blockquote></li></ol></li></ul><h3 id="关系模式范式🗡"><a href="#关系模式范式🗡" class="headerlink" title="关系模式范式🗡"></a>关系模式范式🗡</h3><ul><li><p>第一范式：</p><p>​    如果关系模式 $R$ 所有属性的域都是原子，则称 $R$ 属于第一范式（$1NF$）, 记作 $R \in 1NF$。</p><blockquote><p>$1NF $ 要求关系中不能有复合属性、多值属性及其组合。</p><p>多值属性解决方案：</p><div align="center"><img src="/img/blog/ds-note-images/1.png"></div><ul><li>拆成两个表，原表去掉多值列，然后把多值属性和主码作为一个新的表。</li><li>拆成多行</li><li>拆成多列</li></ul></blockquote></li><li><p>第二范式：</p><p>​    若 $R(U)\in 1NF$ 且 $U$ 中的每一<strong>非主属性完全函数依赖</strong>于<strong>候选键</strong>，则称 $R(U)$ 属于第二范式，记为：$R(U)\in 2NF$。</p><blockquote><p>第二范式消除非主属性对候选键的<strong>部分依赖</strong>。</p><p>将候选键拆成多个表，每个表的<strong>非主属性</strong>完全函数依赖于候选键。</p><p>第二范式只有历史意义，已经不在实际中使用了。</p></blockquote></li><li><p>第三范式：</p><p>​    若 $R(U,F)\in 2NF$, 在 $R$ 中若不存在<strong>候选键</strong> $X$，<strong>属性集</strong> $Y$（不可以是候选键），和<strong>非主属性</strong> $Z$，使得 $X\to Y,Y \to Z$ 成立，其中 $Y\not\subset X,Z\not\subset Y,Z\not\subset X,Y\not\to X$，则称 $R$ 属于第三范式，记为：$R\in 3NF$。</p><blockquote><p>第 $3$ 范式消除了<strong>非主属性对侯选键的传递依赖</strong>。</p><p>如满足第 $3$ 范式，则一定能满足第 $2$ 范式。</p></blockquote></li><li><p>Boyce-Codd 范式：</p><p>​    若 $R(U,F)\in 1NF$, 若对于任何 $X\to Y\in F$（或 $X\to A\in F$），当 $Y\not\subset X$（或 $A\in X$）时，$X$ 必含有<strong>候选键</strong>（即超码），则称 $R(U)$ 属于 Boyce-Codd 范式，记为：$R(U)\in BCNF$。</p><blockquote><p>如满足 Boyce-Codd 范式，则一定能满足第 $3$ 范式。</p></blockquote></li><li><p>多值依赖：</p><p>​    对 $R(U)$，设 $X,Y\subset U$，若对于 $R(U)$ 的任一关系 $r$，若元组 $t\in r, s\in r,t[ X]= s[ X]$，则必有 $ u \in  r,  u \in  r$ 使得：</p><ul><li><p>$u[X]=v[X]=t[X]=s[X]$</p></li><li><p>$ u[ Y]= t[ Y]$ 且 $u[ U- X- Y]= s[ U- X- Y]$</p></li><li><p>$ u[ Y]= s[ Y]$ 且 $v[U- X- Y]= t[ U- X- Y]$</p><p>| $X$  |  $Y$  | $U-X-Y$ |<br>| :—: | :—-: | :——-: |<br>| $x$  | $y_1$ |  $z_1$  |<br>| $x$  | $y_2$ |  $z_2$  |<br>| $x$  | $y_2$ |  $z_1$  |<br>| $x$  | $y_1$ |  $z_2$  |</p></li></ul><p>均成立，则称 $Y$ <strong>多值依赖于</strong> $X$，或说 $X$ <strong>多值决定</strong> $ Y$，记作 $ X \rightarrow \rightarrow  Y$，同时 $X \to\to U-X-Y$。</p><blockquote><p>若 $U=X\cup Y$，则一定有 $X\to\to Y$。</p><p>直观地，若 $ X \rightarrow \rightarrow  Y$，对于 $X$ 给定值，$Y$ 有一组值与之对应（$0$ 或 $n$ 个）且这组 $Y$ 值不以任何方式与 $U-X-Y$ 中属性值相联系。</p></blockquote></li><li><p>第四范式（基于多值依赖的 BCNF 范式，不考）：</p><p>​    函数依赖和多值依赖集为 $F$ 的关系模式 $R(U)$ 属于第四范式 $(4  {NF})$ 的条件是，对 $F^{+}$中所有形如 $\alpha \rightarrow \beta$ 的多值依赖（其中 $\alpha \subseteq     U$ 且 $\beta \subseteq U$），至少有以下之一成立：</p><ul><li>$\alpha \rightarrow \beta$ 是一个平凡的多值依赖。</li><li>$\alpha$ 是 $R$ 的一个超码。</li></ul></li></ul><h3 id="模式分解"><a href="#模式分解" class="headerlink" title="模式分解"></a>模式分解</h3><ul><li><p>模式分解定义：</p><p>​    关系模式 $R(U)$ 的分解是指用 $R$ 的一组子集 $\rho=\{R_1, \ldots,  R_k\}$ 来代替它。其中 $ U= U_1 \cup  U_2 \cup \ldots \cup  U_k,U_i \notin  U_j( i \neq  j)$。对于关系模式 $R$ 的任一关系 $r$，它向 $\rho$ 的投影连接记为 $ m_\rho(R)$ :</p><script type="math/tex; mode=display">m_\rho(R)=\pi_{R_1} (R) \bowtie \ldots \bowtie \pi_{R_k} (R)=\bowtie_{(i=1, \ldots,  k)} \pi_{R_i}(R)</script><p>这里 : $\pi_{R_i}(R)=\{ t[R_i] \mid  t \in  r,  i=1, \ldots,  k\}$。</p><blockquote><p>若对关系模式 $R$ 的任一关系 $r$ 都有 $r = m_\rho(R)$ 成立，则称 $\rho$ 是 $R$ 相对于 $F$ 的一个<strong>无损连接分解</strong>。</p></blockquote></li><li><p>无损连接分解检验算法：</p><ul><li><p>构造一 $k$ 行 $n$ 列的表（$k$ 是分解的集合数，$n$ 是 $R(U)$ 属性数），可称为 $R_\rho$ 表。</p></li><li><p>其中第 $j$ 列对应于 $ A_j$，第 $i$ 行对应于 $ R_i$。</p></li><li><p>若 $ A_j\in  R_i$，则 $R_\rho$ 表中第 $i$ 行第 $j$ 列位置填写符号 $ a_j$，否则填写 $ b_{ij}$。</p></li><li><p>根据 $\forall(X \rightarrow  Y) \in  F$，对 $R_\rho$ 表进行修改：</p><p>给定 $ X \rightarrow  Y$，寻找 <strong>与 $X$ 属性取值相同</strong>的行，用其值重置 $Y$ 属性值。</p></li><li><p>修改后，如果有一行变成 $ a_1,  a_2, \ldots,  a_n$，则 $\rho$ 是无损连接分解，否则为有损连接分解。</p></li></ul><blockquote><p>笔者认为这个算法应该循环，直到不能再修改为止，但是老师说原论文也没有提到做多几次的事情，只需要做一遍就行，遂躺平做一遍就好。</p><p>对于分解成两个子集的情况，可以快速判断的方法：</p><ul><li><p>设 $F$ 是关系模式 $R$ 上的一个函数依赖集合，$\rho=\{ R_1,  R_2\}$ 是 $R$ 的一个分解。</p></li><li><p>则当且仅当 $R_1 \cap R_2 \rightarrow  R_1- R_2$ 或者 $ R_1 \cap  R_2 \rightarrow  R_2- R_1$ 属于 $F^+$ 时，$\rho$ 是关于$F$ 无损连接的。</p></li><li><p>因为 $R_1=(R_1\cap R_2) \cup(R_1-R_2),R_2=(R_1\cap R_2) \cup(R_2-R_1)$，所以有</p><p>|       | $R_1\cap R_2$ | $R_1- R_2$ | $R_2- R_1$ |<br>| :—-: | :—————-: | :————: | :————: |<br>| $R_1$ |     $a_1$     |   $a_2$    |  $b_{13}$  |<br>| $R_2$ |     $a_1$     |  $b_{22}$  |   $a_3$    |</p></li><li><p>此时只要 $ R_1 \cap  R_2 \rightarrow  R_1- R_2$ 或者 $ R_1 \cap  R_2 \rightarrow  R_2- R_1$ 属于 $F^+$ 的一个成立，就能实现有一行变成 $ a_1,  a_2,a_3$。</p></li></ul></blockquote></li><li><p>保持依赖分解的分解🗡：</p><ul><li>对于关系模式 $R( U,  F)$，$U$ 是属性全集，$F$ 是函数依赖集合，$\rho=\{ R_1, \ldots,  R_k\}$ 是 $R$ 的一个分解。</li><li>如在 $\pi_{R_i}( F)$ 中的所有依赖之并集 $( i=1, \ldots,  k)$，<strong>逻辑蕴涵 $F$ 的每个依赖</strong>，则称分解 $\rho$ 保持依赖集 $F$。</li><li>其中 $\pi_{R_i}( F)$ 是 $F$ 在 $ R_i$ 上的投影，即 $F$ 中的任一投影 $ X \rightarrow  Y$，如果 $X,Y\in R_i$，则 $ X \rightarrow  Y \in \pi_{R_i}( F)$。</li></ul></li><li><p>保持依赖分解检测算法：</p><blockquote><p>对 $F$ 中的每一个 $\alpha \rightarrow \beta$，<br><br>$\quad \quad result \leftarrow \alpha$<br><br>$\bf while$<br><br>$\quad \quad\bf foreach$ 分解后包含有 $\alpha$ 的 $R_i:$<br><br>$\quad \quad \quad \quad t\leftarrow ( result \cap R_i)^{+} \cap R_i$<br><br>$\quad \quad \quad \quad result\leftarrow result \cup t$<br><br>$\mathbf{until}$ $(result$ 没有变化 $)$ </p><p>如果 $result$ 含 $\beta$ 中的所有属性，则函数依赖 $\alpha\to \beta$ 保持。</p></blockquote></li><li><p>BCNF 分解 + 无损连接分解：</p><blockquote><p>BCNF 范式要求每个函数依赖的左侧都要是关系模式的<strong>超码</strong>（含有候选键）。</p></blockquote><ul><li><p>仅 BCNF 分解：</p><p>​    将左侧<strong>不含候选键</strong>的函数依赖<strong>单独组成一个关系</strong>，将包含候选键的组成一关系。</p></li><li><p>无损连接分解成 BCNF：</p><blockquote><p>计算 $F^{+}$<br><br>$\mathbf{while} \quad result \not\in BCNF \quad \mathbf{do}$:<br><br>$\quad \quad\mathbf{if}\quad result$ 中存在模式 $R_i$ 不属于 $BCNF\quad \mathbf{then}$： <br><br>$\quad \quad \quad \quad$ 对于 $R_i$ 上所有非平凡函数依赖 $\alpha \rightarrow \beta$ （满足 $\alpha \rightarrow R_i$ 不属于 $F^{+}$，即 $\alpha$ 不是 $R_i$ 的超码）<br><br>$\quad \quad \quad \quad  \quad \quad result=(result-R_i) \cup(R_i-\beta ) \cup (\alpha, \beta)$ </p><p> // 即用两个模式 $(R_i-\beta) \cup(\alpha, \beta)$ 取代原来的 $R_i$，由之前的快速判断的方法可知分解无损 </p></blockquote></li></ul></li><li><p>$3NF$ 分解 + 保持依赖分解（+ 无损连接分解）：</p><ul><li><p>仅 $3NF$ 分解：</p><p>​    将每一个函数依赖单独组成一个关系。</p></li><li><p>保持依赖分解成 $3NF$：</p><ul><li><p>关系模式 $R(U, F)$，$F$ 是函数依赖集<strong>最小覆盖</strong>，求保持依赖的 $3NF$ 分解 $\rho$。</p></li><li><p>若有 $ X \rightarrow  A_1,  X \rightarrow  A_2, \ldots,  X \rightarrow  A_{ m}\in F$，则以 $XA_1  A_2 \ldots  A_m$ 组成一模式 $R_i$，$\rho=\rho\cup R_i$</p><blockquote><p>这样保证 $R_i$ 是 $3NF$ 分解：</p><p>​    因为 $F$ 是最小覆盖，要求对任何 $\{X\to A\}\in F$，有 $F- \{ X\to A \}$ 不等价于 $F$。</p><p>所以一定不会存在 $A_i\to A_j\in F(i\not=j)$ 的情况，否则 $F-\{X\to A_j\}$ 仍等价于 $F$。</p></blockquote></li><li><p>上一步处理完后，把 $R$ 中<strong>不出现在 $F$ 中的属性</strong>去掉并单独组成一模式 $R_{no}$，令 $\rho=\rho\cup R_{no}$。</p><blockquote><p>若要达到无损连接分解：</p><ul><li><p>如果 $R_{no}$ 存在，将在 $R_{no}$ 加入候选键属性，则能使该分解达到无损。</p></li><li><p>如果不存在，则判断所得 $\rho$ 集合中的是否存在一个 $R_i$ 包含了候选键属性集：</p><ul><li><p>存在，算法结束。</p></li><li><p>不存在，$\rho=\rho~\cup$ 候选键属性集。</p></li></ul></li></ul></blockquote></li></ul></li></ul></li></ul><h2 id="数据存储和查询"><a href="#数据存储和查询" class="headerlink" title="数据存储和查询"></a>数据存储和查询</h2><h3 id="存储和文件结构"><a href="#存储和文件结构" class="headerlink" title="存储和文件结构"></a>存储和文件结构</h3><ul><li><p>存储体系：</p><ul><li>将不同性价比的存储器组织在一起，满足高速度、大容量、低价格需求。</li><li>CPU 与内存直接交换信息，按存储单元（存储字）进行访问。</li><li>外存按<strong>存储块</strong>进行访问，其信息需先装入<strong>内存</strong>，才能被 CPU 处理。</li></ul></li><li><p>操作系统对数据的组织：</p><ul><li><p>FAT（文件分配表 - File Allocation Table）- 目录（文件夹）- 磁盘块/簇</p><p><img src="/img/blog/ds-note-images/image-20211012225110095.png" style="zoom:67%;"></p></li><li><p>对于一个文件，用 FAT 找到它在磁盘中的位置。</p></li></ul></li><li><p>内存管理：</p><p>​    一条记录的地址 = 存储单元的地址 = 内存地址 = 页面 ：页内偏移量</p></li><li><p>磁盘结构：</p><p><img src="/img/blog/ds-note-images/image-20211012161544352.png" style="zoom: 67%;"></p><ul><li><strong>盘片</strong>的表面从逻辑上划分为<strong>磁道</strong>（同心圆），磁道又划分为<strong>扇区</strong>。</li><li>扇区是从磁盘读出和写入信息的<strong>最小单位</strong>，系统数据传输的基本单位是磁盘块（几个连续的扇区）。</li><li>一个磁盘的基本信息（假设）：<ul><li>$8$ 个圆盘，$16$ 个盘面</li><li>每个盘面有 $2^{16}$ 或 $65536$ 个磁道</li><li>每个磁道（平均）有 $2^8=256$ 个扇区</li><li>每个扇区有 $2^{12}=4096$ 个字节</li><li>磁盘的容量为 $2^4\times 2^{16} \times 2^8 \times 2^{ 12} = 2^{ 40}$ 字节</li></ul></li></ul></li><li><p>磁盘数据读写时间🗡：</p><ul><li><p>包括寻道时间（约在 $1-20ms$），旋转时间（约 $0-10ms$）和传输时间。</p></li><li><p>磁盘以 $7200$ 转/$min$ 旋转，即 $8.33ms$ 内旋转一周</p></li><li><p>柱面之间移动磁头组合从启动到停止花费 $1 ms$。</p></li><li><p>每移动 $4000$ 个柱面另加 $1ms$，即磁头在 $0.00025 ms$ 内移动一个磁道，从最内圈移动到最外圈，移动 $65536$ 个磁道大约用 $0.00025\times 65536 + 1=17.38ms$。</p></li><li><p>一个磁道中扇区间的空隙大约占 $10 \%$ 的空间 </p></li><li><p>一个磁盘块 $=4$ 个扇区 $=16384$ 个字节</p></li><li><p>最短时间 $=$ 传输时间大约是 $0.13ms$</p></li><li><p>最长时间 $=$ 寻道时间+旋转时间+传输时间 $=17.38+8.33+0.13=25.84 m s$</p></li><li><p>平均时间 $=6.46(16.38/3+1)+4.17(8.33/2)+0.13=10.76 ms$ （括号表示这个数是怎么得到的）</p><blockquote><p>概率论忘掉了，这里可能有算错的地方（这是不会考的，不重要）<span class="">🤐</span></p><p>平均寻道时间要除以 $3$ 是求了一个盘片内径向任意两点之间移动时间的期望（前提假定为平均分布）。</p><p>设盘片半径为 $r$。令 $f(y)=|x-y|$，即表示径向从 $y$ 点到 $x$ 点之间距离。</p><p>当 $x$ 为 $[0,r]$ 上的固定值时，求出 $[0,r]$ 上所有点到 $x$ 的期望距离：</p><script type="math/tex; mode=display">\mathbb{E}f(y)=\int^r_0 |x-y|\frac{1}{r}dy=\frac{x^2}{r}-x+\frac{r}{2}</script><p>对于所有 $x\in[0,r]$，计算期望距离的期望：</p><script type="math/tex; mode=display">\mathbb{E}\mathbb{E}f(y)=\int^r_0 \frac{1}{r}(\frac{x^2}{r}-x+\frac{r}{2})dx=\frac{r}{3}</script><p>即磁头平均会移动 $\begin{aligned}\frac{r}{3}\end{aligned}$。</p></blockquote></li><li><p>物理存取算法考虑的关键：</p><ul><li>降低 I/O 次数。</li><li>降低排队等待时间。</li><li>降低<strong>寻道/旋转</strong>延迟时间：<ul><li>同一<strong>磁道</strong>连续块存储</li><li><strong>同一柱面</strong>不同磁道<strong>并行</strong>块存储</li><li>多个<strong>磁盘</strong>并行块存储</li></ul></li></ul></li></ul></li><li><p>独立磁盘冗余阵列（Redundant Array of Independent Disk，RAID 技术）（理解）：</p><ul><li><p>块级拆分：</p><p>​    一个文件由多个块组成，不同<strong>块</strong>存储于不同磁盘。</p></li><li><p>比特级拆分：</p><p>​    一个字节被拆分成 $8$ 个比特位, 不同<strong>比特位</strong>存储于不同磁盘。</p></li><li><p>RAID $0$ 级：</p><p>​    块级拆分但<strong>没有任何冗余</strong>（例如镜像或奇偶校验位）的磁盘阵列。</p></li><li><p>RAID $1$ 级：</p><p>​    使用块级拆分的磁盘<strong>镜像</strong>，每一个磁盘有一个镜像磁盘。</p></li><li><p>RAID $2$ 级：</p><p>​    <strong>位交叉</strong>纠错处理，$4$ 个磁盘存储 $4$ 位 $+~3$ 个校验盘存储 $3$ 校验位（汉明码）。</p></li><li><p>RAID $3$ 级：</p><p>​    RAID $2$ 级的改进，只用一个校验盘，比 RAID $2$ 级常用。</p></li><li><p>RAID $4$ 级：</p><p>​    <strong>块交叉</strong>的奇偶校验组织结构。它像 RAID $0$ 级一样使用块级拆分，此外在一张<strong>独立的磁盘</strong>上为其他 $N$ 张磁盘上对应的块保留一个<strong>奇偶校验块</strong>。</p></li><li><p>RAID $5$ 级：</p><p>​    块交叉的<strong>分布奇偶校验位</strong>的组织结构，是 RAID $4$ 级的改进，将数据和奇偶校验位都分布到所有的 $N + 1$ 张磁盘中。</p><p><img src="/img/blog/ds-note-images/image-20211013151334886.png" style="zoom:67%;"></p></li></ul></li><li><p>数据存储的映射：</p><p><img src="/img/blog/ds-note-images/image-20211013152301903.png" style="zoom:80%;"></p></li><li><p>数据库记录在磁盘上的存储：</p><ul><li><p>定长记录（根据偏移量区分记录）：</p><p>​    所有字段固定位数（黑色是空着的）。</p><div align="center"><img src="/img/blog/ds-note-images/image-20211013185732990.png"></div></li><li><p>变长记录（靠分隔符区分开始与结束）：</p><div align="center"><img src="/img/blog/ds-note-images/1.png"></div><ul><li><p>块头包括：</p><ul><li>块头中记录条目的个数。</li><li>块中<strong>空闲空间</strong>的末尾处。</li><li>一个由包含记录<strong>位置和大小</strong>的记录条目组成的数组。</li></ul></li><li><p>实际记录从块的<strong>尾部</strong>开始连续排列。</p></li><li><p>块中<strong>空闲空间是连续</strong>的，无论是插入操作还是删除操作都不能改变这一点。</p></li><li><p>如果插入一条记录，在<strong>空闲空间的尾部</strong>给这条记录分配空间，并且将包含这条记录大小和位置的条目添加到块头中。</p></li><li><p>如果一条记录被删除：</p><ul><li>它所占用的空间被释放，并且它的条目被设置成被<strong>删除状态</strong>。</li><li>块中在被删除记录之后的记录将被移动，使得由删除而产生的空闲空间被重用，并且所有空闲空间仍然保持<strong>连续</strong>。</li><li>块头中的空闲空间末尾指针要做适当修改。</li></ul><blockquote><p>移动记录的代价并不高，因为块的大小是有限制的，典型的值为 $4-8$KB。</p></blockquote></li></ul></li></ul></li></ul><ul><li><p>数据库 - 表所占磁盘块的分配方法：</p><ul><li><p>连续分配: </p><p>​    数据块被分配到连续的磁盘块上（会存在<strong>扩展困难</strong>问题）。</p></li><li><p>链接分配: </p><p>​    数据块中包含指向下一数据块的指针（<strong>访问速度</strong>问题），不连续，有空位就放。</p></li><li><p>按簇分配: </p><p>​    按簇分配，簇内连续分配，簇之间靠指针连接，簇有时也称<strong>片段</strong>，结合前面两者优点。</p></li><li><p>索引分配: </p><p>​    索引块中存放指向实际<strong>数据块的指针</strong>（可以不用 FAT）。</p><p><img src="/img/blog/ds-note-images/image-20211013191826059.png" style="zoom:80%;"></p></li></ul></li><li><p><strong>文件组织方法</strong>🗡：</p><blockquote><p>考试重点，注意区分🧐，回答合理即可。</p></blockquote><ul><li><p>无序文件组织：</p><ul><li><p>无序记录文件（堆文件 heap 或 pile file）</p></li><li><p>记录可存储于任意有空间的位置，磁盘上存储的记录是无序的。<strong>更新效率高</strong>，但<strong>检索效率可能低</strong>。</p></li><li><p>一开始新记录总插入到文件尾部。删除记录时，可以直接删除该记录所在位置的内容，也可以在该记录前标记「<strong>删除标记</strong>」，新增记录可以利用那些标记为「删除标记」的记录空间</p></li><li><p>频繁删增记录时会造成空间浪费，所以需要周期性<strong>重新组织数据库</strong>。</p><blockquote><p>数据库重组是通过移走被删除的记录使<strong>有效记录连续存放</strong>，从而回收那些由删除记录而产生的未利用空间（外部碎片）。</p></blockquote></li></ul></li><li><p>有序文件组织</p><ul><li><p>有序记录文件（排序文件 Sequential）</p></li><li><p>记录按某属性或属性组值的顺序插入，磁盘上存储的记录是有序的。<strong>检索效率可能高</strong>，但更新效率低。</p><blockquote><p>当按排序字段进行检索时，速度得到很大提高。但当按非排序字段检索时，速度可能不会提高很多。</p></blockquote></li><li><p>用于存储排序的属性通常称为<strong>排序字段</strong>，可以是关系中的<strong>主码</strong>，所以又称<strong>排序码</strong>。</p></li><li><p>改进办法（使用溢出）：</p><ul><li><p>为将来可能插入元组预留空间（这可能造成空间浪费），或使用一个<strong>临时的无序文件</strong>（被称为<strong>溢出文件</strong>）保留新增的记录。</p></li><li><p>当采取溢出文件措施时，检索操作既要操作主文件，又要<strong>操作溢出文件</strong>。</p></li><li><p>需要周期性<strong>重新组织数据库</strong>，将溢出文件<strong>合并</strong>到主文件，并恢复主文件中的记录顺序。</p></li></ul></li></ul></li><li><p>散列文件组织：</p><ul><li>散列文件（Hash file）</li><li>可以把记录按某属性或属性组的值，依据一个<strong>散列函数</strong>来计算其应存放的<strong>位置（桶号）</strong>，检索效率和更新效率都有一定程度的提高。</li><li>用于进行散列函数计算的属性通常称为<strong>散列字段</strong>，散列字段通常也采用关系中的<strong>主码</strong>，所以又称<strong>散列码</strong>。</li><li>不同记录可能被 hash 成同一桶号，此时需在桶内顺序检索出某一记录。</li><li>答题万金油，读写性能都不错。</li></ul></li><li><p>聚簇文件组织：</p><ul><li><p>聚簇文件（Clustering file）</p></li><li><p><strong>聚簇</strong>：</p><p>​    将具有<strong>相同或相似属性值</strong>的记录存放于<strong>连续</strong>的磁盘簇块中，优化连接代价，在<strong>不用索引</strong>的时候使用。</p></li><li><p>多表聚簇：</p><p>​    将若干个<strong>相互关联</strong>的表存储于一个文件中，可提高多表情况下的查询速度。</p></li><li><p>何时使用多表聚簇依赖于数据库设计者所认为的<strong>最频繁的查询类型</strong>。</p></li></ul></li></ul></li></ul><h3 id="索引概念和分类🗡"><a href="#索引概念和分类🗡" class="headerlink" title="索引概念和分类🗡"></a>索引概念和分类🗡</h3><ul><li><p>索引定义：</p><ul><li><p>定义在存储表基础上，无需检查所有记录，快速定位所需记录的一种辅助存储结构，由<strong>一系列</strong>存储在<strong>磁盘</strong>上的<strong>索引项</strong>组成，每一索引项又由两部分构成:</p><ul><li><p><strong>索引字段</strong>：</p><p>​    由表中<strong>某些列</strong>中的值串接而成，类似于词典中的词条。索引中<strong>通常</strong>存储了索引字段的每一个值。</p></li><li><p>行指针：</p><p>​    指向表中包含索引字段值的记录在磁盘上的<strong>存储位置</strong>，类似于词条在书籍、词典中出现的页码。</p></li></ul></li><li><p>有索引时，更新操作必须<strong>同步更新</strong>索引文件和主文件。</p></li><li><p>对经常出现在<strong>检索条件、连接条件和分组</strong>计算条件中的属性可建立索引。</p></li></ul><blockquote><p>存储<strong>索引项</strong>的文件为<strong>索引文件</strong>，存储表称为<strong>主文件</strong>。</p></blockquote></li><li><p>索引文件组织方式有两种🗡：</p><ul><li><p><strong>排序索引文件</strong>：</p><p>​    按<strong>索引字段值</strong>的某一种<strong>顺序</strong>组织存储。</p></li><li><p><strong>散列索引文件</strong>：</p><p>​    依据<strong>索引字段值</strong>使用<strong>散列函数</strong>分配散列桶的方式存储。</p></li></ul><blockquote><p><strong>主文件组织</strong>有堆文件、排序文件、散列文件、 聚簇文件等多种方式，和<strong>索引文件组织方式</strong>区分。</p></blockquote></li><li><p>索引应用的评价：</p><ul><li><p>访问时间：</p><p>​    在查询中使用该技术找到一个特定数据项或数据项集所需的时间</p></li><li><p>插入时间：</p><p>​    插入一个新数据项所需的时间。该值包括<strong>找到</strong>插入这个新数据项的正确位置所需的时间，以及<strong>更新</strong>索引结构所需的时间。</p></li><li><p>删除时间：</p><p>​    删除一个数据项所需的时间。该值包括找到待删除项所需的时间，以及更新索引结构所需的时间。</p></li><li><p>空间开销：</p><p>​    索引结构所占用的额外存储空间。倘若存储索引结构的额外空间大小适度，通常牺牲一定的空间代价来换取性能的提高是值得的。</p></li></ul></li><li><p>码的区分（😢不太能区分）：</p><ul><li><p>排序码：</p><p>​    对主文件进行排序存储的那些属性或属性组。</p></li><li><p>索引码：</p><p>​    即索引字段，<strong>不一定具有唯一性</strong>。</p></li><li><p>搜索码：</p><p>​    在文件中查找记录的属性或属性集称为<strong>搜索码</strong>。</p></li></ul></li><li><p>稠密索引：</p><ul><li><p>主文件中每一个<strong>搜索码值</strong>（索引字段值）都有一个索引项和它对应。</p></li><li><p>对<strong>候选键</strong>建稠密索引：</p><p>​    主文件不用排序，直接可以定位。</p></li><li><p><strong>非候选键</strong>建稠密索引：</p><ul><li><p><strong>索引文件</strong>中索引字段值是<strong>不重复的</strong>，<strong>主文件</strong>按索引字段<strong>排序</strong>。</p><p><img src="/img/blog/ds-note-images/image-20211119134744510.png" style="zoom:60%;"></p></li><li><p><strong>索引文件</strong>中索引字段值是有<strong>重复</strong>的，主文件<strong>不排序</strong>。</p><div align="center"><img src="/img/blog/ds-note-images/6fda6106a92bb6123bb84b5bf951d39e.jpg"></div></li><li><p>引入<strong>指针桶</strong>处理非候选键索引的多记录情况，<strong>索引文件</strong>中索引字段值是<strong>不重复的</strong>，主文件<strong>不排序</strong>。</p><p><img src="/img/blog/ds-note-images/eec1c49cea791f862e00000e00158704.jpg" style="zoom:100%;"></p><blockquote><p>索引文件通常要排序。</p></blockquote></li></ul></li></ul></li></ul><ul><li><p>稀疏索引：</p><p>​    稀疏索引只为主文件<strong>部分搜索码值</strong>（索引字段值）建立索引记录，<strong>主文件</strong>按索引字段<strong>排序</strong>。</p></li><li><p>主索引：</p><ul><li>如果包含记录的文件按照某个<strong>搜索码</strong>指定的顺序<strong>排序</strong>，那么该搜索码对应的索引称为<strong>聚集索引</strong>，也称为<strong>主索引</strong>。</li><li>主索引对每一<strong>存储块</strong>有一个<strong>索引项</strong>，索引项的总数和<strong>存储表所占的存储块数目</strong>相同。</li><li>存储表的每一存储块的第一条记录，又称为<strong>锚记录</strong>，或简称为块锚。</li><li>主索引的索引字段值为块锚的索引字段值（通常为<strong>主码值或排序码值</strong>），而指针指向其所在的存储块。</li><li>主索引（可以）是<strong>稀疏索引</strong>。</li></ul></li><li><p>辅助索引：</p><ul><li>辅助索引定义在<strong>主文件</strong>的任一或多个<strong>非排序字段</strong>上的辅助存储结构。</li><li>辅助索引一定是稠密索引。</li></ul><blockquote><p>主索引和辅助索引的区别：</p><ul><li>一个主文件仅可以有一个<strong>主索引</strong>（只按主索引的搜索码排序），但可以有多个辅助索引。</li><li>主索引通常建立于主码/排序码上面，辅助索引建立于其他属性上面。</li><li>可以利用主索引重新组织主文件数据，辅助索引不能改变主文件数据。</li><li>主索引是稀疏索引，辅助索引是稠密索引</li></ul></blockquote></li><li><p>聚簇索引：</p><ul><li><p>聚簇<strong>索引</strong>定义：</p><p>​    聚簇索引是指<strong>索引中邻近</strong>的记录在<strong>主文件</strong>中也是临近存储的。</p></li><li><p>聚簇<strong>字段</strong>定义：</p><p>​    如果主文件的某一<strong>排序</strong>字段<strong>不是主码</strong>，则该字段上每个记录取值便不唯一，此时该字段被称为<strong>聚簇字段</strong>。聚簇索引通常是定义在聚簇字段上。</p><p><img src="/img/blog/ds-note-images/image-20211119141551035.png" style="zoom:80%;"></p></li></ul></li><li><p>非聚簇索引：</p><p>​    指索引中邻近的记录在主文件中不一定是邻近存储的。</p><blockquote><p>聚簇索引和非聚簇索引的区别：</p><ul><li>一个主文件只能有一个聚簇索引文件，但可以有多个非聚簇索引文件。</li><li>主索引通常是聚簇索引（但其<strong>索引项</strong>总数<strong>不一定</strong>和主文件中<strong>聚簇字段</strong>上不同值的数目相同，其和<strong>主文件存储块数目</strong>相同）。</li><li>辅助索引通常是非聚簇索引。</li><li>主索引/聚簇索引是能够<strong>决定记录存储位置</strong>的索引，而辅助索引/非聚簇索引则只能用于<strong>查询</strong>，指出已存储记录的位置。</li></ul></blockquote></li></ul><h3 id="多级索引（B-树）🗡"><a href="#多级索引（B-树）🗡" class="headerlink" title="多级索引（B+ 树）🗡"></a>多级索引（B+ 树）🗡</h3><blockquote><p>必考内容<span class="">🌲</span></p><p>当索引项比较多时，可以对索引再建立索引，依此类推，形成多级索引。</p></blockquote><ul><li><p>B+ 树节点：</p><div align="center"><img src="/img/blog/ds-note-images/image-20211014210434101.png"></div><ul><li><p>$K_i$：</p><p>​    索引字段值</p></li><li><p>$P_i$​：</p><ul><li>是指向 <strong>索引块</strong>或<strong>数据块</strong>或数据块中记录 的指针：<ul><li>非叶结点指针指向<strong>索引块</strong>。</li><li>叶结点指针指向主文件的数据块（稀疏索引）或数据记录（稠密索引）。</li></ul></li><li>每个索引块的<strong>指针利用率</strong>（书上是说索引字段值的利用率🥲）都在 <strong>$50\%-100\%$</strong> 之间（根节点可以不满足）。</li><li>索引字段值 $x$ 在 $K_{i-1}\le x&lt;K_i$ 的由 $P_i$ 指向（设 $K_0=0$），而 $K_i\le x&lt;K_{i+1}$ 的由 $P_{i+1}$ 指向。</li><li>叶节点的 $P_n$ 指向下一个叶节点。</li></ul></li><li><p>共有 $n-1$ 个索引字段值和 $n$ 个指针。</p></li></ul></li><li><p>B 树和 B+ 树比较：</p><ul><li>B 树索引字段值<strong>仅出现一次</strong>，可以在叶结点或者在非叶结点；B+ 树有<strong>重复</strong>索引字段值。</li><li>B 树指向主文件的<strong>指针</strong>出现于<strong>叶结点或非叶结点</strong>，另一个指针指向结点；B+ 树只有叶子结点有指向主文件的指针。</li><li>B 树<strong>所有结点才能覆盖</strong>所有键值的<strong>索引</strong>；B+ 树叶子结点就能覆盖。</li><li>B 书叶节点和 B+ 数叶节点结构相同。</li></ul></li><li><p>B+ 树插入：</p><ul><li><p>在原树的叶子节点中找到应该插入的位置：</p><ul><li><p>当索引块满时，需要分裂，分裂后也要保证指针利用率不低于一半（平均分）。</p><blockquote><p>将这 $n$ 个搜索码值（叶结点中原有的 $n-1$ 个值再加上新插入的值）分为两组，前 $\lceil n/2\rceil$ 个放在原来的结点中，剩下的放在一个新结点中。</p></blockquote></li><li><p>否则直接插入，如果插入位置在叶子索引块最左边（即小于该块的其他索引块，要修改父节点的值）。</p></li></ul></li><li><p>分裂可能引发连锁反应，由<strong>叶结点直至根结点</strong>判断。</p></li><li><p>分裂后需要仔细调整索引<strong>键值及指针</strong>。</p></li><li><p>注意<strong>叶子结点之间</strong>链接关系的调整。</p></li></ul></li><li><p>B+ 树删除：</p><ul><li>当删除后指针利用率低于一半，先考虑从<strong>相邻叶子结点借索引项</strong>，如果不能借就合并。</li><li>合并可能引发连锁反应，由叶结点直至根结点（父节点索引值少了一个）。</li><li>合并后需要仔细调整索引键值及指针。</li><li>注意叶子结点之间链接关系的调整。</li></ul></li></ul><h3 id="散列索引"><a href="#散列索引" class="headerlink" title="散列索引"></a>散列索引</h3><ul><li><p>桶：</p><p>​    表示能存储一条或多条记录的一个存储单位，一个桶可以是一个或者若干个连续的存储块。</p></li><li><p>散列函数：</p><p>​    $K$ 表示所有搜索码值的集合，$B$ 表示所有桶地址的集合，散列函数 $h$ 是一个从 $K\to B$ 的函数。</p><blockquote><p>散列函数要满足分布是<strong>均匀的</strong>和随机的。</p></blockquote></li><li><p>溢出桶：</p><p>​    如果一条记录必须插入桶 $b$ 中，而桶 $b$ 已满，系统会为桶 $b$ 提供一个<strong>溢出桶</strong>，并将此记录插入到这个溢出桶中。</p></li><li><p>静态散列索引的缺点：</p><p>​    如果桶的数目 $M$ 不变，过大则<strong>浪费</strong>，过小则将产生更多的<strong>溢出桶</strong>，增加散列索引检索的时间。</p><blockquote><p>以下为两种动态散列索引🗡，考选择题，注意区别和名字。</p></blockquote></li><li><p><strong>可扩展散列索引</strong>：</p><ul><li><p>有一个附加的间接层（<strong>指针数组</strong>），系统在访问桶本身之前必须先访问指针数组表。</p></li><li><p>指针数组能增长，其长度总是 $2$ 的幂。因而数组每增长一次，桶的数目就翻倍。</p></li><li><p>多个桶可能共享一个数据块（即多个指针数组指向同一个数据库）。</p><div align="center"><img src="/img/blog/ds-note-images/image-20211119162510134.png"></div></li><li><p>参数 $k$ 表示散列函数所可能使用的<strong>最多位数</strong>。</p></li><li><p>散列函数：</p><p>​    散列函数 $h$ 为每个键计算出一个 <strong>$k$ 位二进制序列</strong>（散列函数值）。</p></li><li><p>$i$ 为散列函数当前已经使用到的最多位数。取散列函数值的前 $i$ 位（散列前缀）为作为要插入桶的编号。</p></li><li><p>插入某个桶时发现已满，则需要扩展散列桶，进行分裂：</p><ul><li><p>$i$ 增 $1$，重新散列该块的数据到<strong>两个块</strong>中。</p></li><li><p>其他的桶按照散列前缀重新指向对应数据块，会出现多个桶共享一个块的情况（因为在后面加 $0/1$ 指向不变）。</p><div align="center"><img src="/img/blog/ds-note-images/image-20211119162911341.png"></div></li></ul></li></ul><blockquote><p>缺点：</p><ul><li>翻倍要处理的工作量很大。</li><li>桶数翻倍后，主存可能装不下。</li><li>可能产生大量空间浪费，因为一个数据块满了得翻倍，其他块可能都没有存多少数据。</li></ul></blockquote></li><li><p><strong>线性散列索引</strong>：</p><ul><li><p>桶数的选择：</p><p>​    保持与存储块所能容纳的记录总数成一个<strong>固定的比例</strong>，例如 $80\%$。超过此比例，则桶数<strong>仅增长 $1$ 块</strong>。不超过这个比例时允许有溢出桶。</p></li><li><p>假定散列函数值的 $i$ 位为桶数组项编号。现在要插入一个键值为 $K$ 的记录：</p><ul><li><p>通过散列函数得知要插入编号为 $a_1 a_2 \ldots a_i$ 的桶中，即 $a_1 a_2 \ldots a_i$ 是 $h(K) $ 的后 $i$ 位。设 $m=a_1 a_2 \ldots a_i$，$n$ 为当前的桶数。</p></li><li><p>如果 $m&lt;n$，则编号为 $m$ 的桶存在，并把记录存入该桶中。</p></li><li><p>如果 $n \leq m&lt;2^i$，那么桶还不存在，因此我们把记录存入桶 $m-2^{i-1}$，也就是当我们<strong>把 $a_1$（它现在是 $1$)改为 $0$ 时对应的桶</strong>。</p></li><li><p>如果插入后不满足比例时，要分裂一个桶成两个，这个要分裂的桶的编号是这样确定的：</p><p>​    设当前 $n$ 已增一，则分裂与 $n$ <strong>低位相同</strong>而<strong>最高位不同</strong>的那一个桶，即假设当前为 $n=1a_2a_3\cdots a_i$，则就从 $0a_2a_3\cdots a_i$ 对应的桶分裂而来。</p><blockquote><p>因为当时有些记录是强行插入桶中的（上面 $n \leq m&lt;2^i$ 的情况，那时还没有 $1a_2a_3\cdots a_i$ 这个桶，也得硬插），插入的桶号就是 $0a_2a_3\cdots a_i$，现在分裂了，就可以插入对应正确的桶中了。</p></blockquote></li><li><p>分裂只会影响分裂之后的两个桶的记录，其他保持不变。</p></li><li><p>当桶数超过 $2^i$ 个桶时，则使 $i$ 增 $1$。</p></li></ul></li></ul></li></ul><h2 id="数据库查询实现算法"><a href="#数据库查询实现算法" class="headerlink" title="数据库查询实现算法"></a>数据库查询实现算法</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><p>查询优化：</p><p>​    构造具有最小查询执行代价的查询执行计划应当是系统的责任，这项工作叫作查询优化：</p><ul><li>利用模型的语义及完整性规则，优化查询。</li><li>去掉无关的表</li><li>去掉无关的属性</li><li>改写成等价的效果更好的语句</li></ul></li><li><p>逻辑层优化：</p><p>​    优化关系代数操作执行次序，<a href="#语法优化技术">后面会详细讲</a>。</p></li><li><p>物理层优化：</p><p>​    优化关系代数操作实现算法，存取路径与执行次序。</p><blockquote><p>为每一个关系代数操作选择优化的执行<strong>例行程序</strong>，形成<strong>物理查询计划</strong>。</p></blockquote></li><li><p>物理层优化的查询实现：</p><ul><li>DBA 获取数据库的相关信息（<strong>定期统计</strong>）。</li><li>选择相应操作的例行程序</li><li>依据相关信息进行<strong>代价估算</strong>，并选择代价最少的例行程序及确定相应的参数。</li><li>形成查询计划，以基本的例行程序为基本步骤，确定这些例行程序的执行顺序。</li></ul></li><li><p>一次单一元组的一元操作（选择和投影）：</p><ul><li>选择 $\sigma_F(R)$</li><li>投影 $\pi_{\alpha}(R)$</li></ul></li><li><p>整个关系的一元操作：</p><ul><li>去重 $\delta(R),\rm DISTINCT$</li><li>聚集 $\gamma(R),\rm GROUP BY$</li><li>排序 $\tau(R),\rm SORTING$</li></ul></li><li><p>整个关系的二元操作：</p><ul><li><p>集合上的操作: </p><p>​    $\cup_S, \cap_S,-S$</p></li><li><p>包（允许重复的集合）上的操作：</p><p>​    $\cup_B, \cap_B,-B$</p></li><li><p>笛卡尔积，连接：</p><p>​    $\rm PRODUCT,JOIN$</p></li></ul></li></ul><h3 id="连接操作的实现算法"><a href="#连接操作的实现算法" class="headerlink" title="连接操作的实现算法"></a>连接操作的实现算法</h3><ul><li><p>关系的物理存储相关的参数：</p><blockquote><p>关系是存储在<strong>磁盘</strong>上的，磁盘是以<strong>磁盘块为操作单位</strong>，首先要被装载进<strong>内存</strong>（I/O 操作），然后再进行元组的处理。</p></blockquote><ul><li><p>$T_R$：</p><p>​    关系 R 的<strong>元组数目</strong>。</p></li><li><p>$B_R$：</p><p>​    关系 R 的<strong>磁盘块</strong>数目。</p></li><li><p>$ M$：</p><p>​    <strong>主存</strong>缓冲区的页数（主存每页容量等于一个磁盘块的容量）。</p></li><li><p>$I_R$：</p><p>​    关系 R 的每个<strong>元组的字节数</strong>。</p></li><li><p>$b$：</p><p>​    每个<strong>磁盘块的字节数</strong>。</p><script type="math/tex; mode=display">B_{R\times S}=T_R T_S(I_R+I_S) / b</script></li></ul><blockquote><p>下面讨论各种连接操作的实现算法🗡：</p><ul><li>因为 I/O 操作所需时间远大于内存操作，下面仅考虑 I/O 用时（次数）。</li><li>忽略写回结果所需时间（也就是说只考虑 I(input) 没有 O(output)），因为很难估计。</li></ul></blockquote></li><li><p>连接操作算法 $P_1$（主存利用率低）：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* I/O 操作 */</span><br>For i = <span class="hljs-number">1</span> to BR<br>read i-th block of R       <span class="hljs-comment">// 执行 BR 次</span><br>For j = <span class="hljs-number">1</span> to BS<br>read j-th block of S   <span class="hljs-comment">// 执行 BR * BS 次</span><br>    <br>    <span class="hljs-comment">/* 内存操作 */</span><br>For p = <span class="hljs-number">1</span> to b/IR      <span class="hljs-comment">// 取元组，b/IR 表示一个磁盘块有多少个关系 R 的元组</span><br>read p-th record of R<br>For q = <span class="hljs-number">1</span> to b/IS<br>read q-th record of S<br>                <span class="hljs-keyword">if</span> R.A 关系 S.B then<br>                    串接 p-th record of R和q-th record of S;<br>                    存入结果关系;<br></code></pre></td></tr></tbody></table></figure><p>I/O 次数估计为 $B_R + B_R\times B_S$</p></li><li><p>连接操作的全主存实现算法 $P_2$：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* 算法假定内存大小 M &gt;= BR + BS，即只需要读一遍关系 R 和 S 的磁盘块 */</span><br>For i = <span class="hljs-number">1</span> to BR <br>read i-th block of R<br>For j = <span class="hljs-number">1</span> to BS <br>read j-th block of S<br><span class="hljs-comment">/* 内存操作稍有不同，不是重点 */</span><br></code></pre></td></tr></tbody></table></figure><p>I/O 次数估计为 $B_R + B_S$</p></li><li><p>连接操作的半主存实现算法 $P_3$：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 算法假定内存大小min(BR,BS) &lt; M &lt; BR + BS，这里假设较小的是 BR，读一次 R 的磁盘块放内存，S 的每次读就处理，不用全部放入内存再处理 */</span><br>For i = <span class="hljs-number">1</span> to BR <br>read i-th block of R<br>For j = <span class="hljs-number">1</span> to BS <span class="hljs-comment">//一次读入一块关系 S 的磁盘块</span><br>read j-th block of S<br><span class="hljs-comment">/* 内存操作稍有不同，不是重点 */</span><br></code></pre></td></tr></tbody></table></figure><p>I/O 次数估计为 $B_R + B_S$</p></li><li><p>连接操作的大关系实现算法 $P_4$（将主存充分利用）：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 把关系 R 划分为 BR/(M-2) 个子集合，每个子集合具有 M-2 块。令 MR 为 M-2 块容量的主存缓冲区，</span><br><span class="hljs-comment">* MS 为 1 块容量的 S 的主存缓冲区，还有 1 块作为输出缓冲区。</span><br><span class="hljs-comment">*/</span><br>For i = <span class="hljs-number">1</span> to BR/(M<span class="hljs-number">-2</span>) <span class="hljs-comment">//一次读入M-2块</span><br>read i-th Sub-<span class="hljs-built_in">set</span> of R into MR      <span class="hljs-comment">// 执行 BR/(M-2) 次,总共 BR 次 I/O   </span><br>For j = <span class="hljs-number">1</span> to BS <span class="hljs-comment">//一次读入一块</span><br>read j-th block of S into MS    <span class="hljs-comment">// 执行 BR/(M-2) * BS 次</span><br>For p = <span class="hljs-number">1</span> to (M<span class="hljs-number">-2</span>)b/IR<br><span class="hljs-comment">/* 内存操作稍有不同，不是重点 */</span><br></code></pre></td></tr></tbody></table></figure><p>I/O 次数估计为 $B_S(B_R /(M-2)) + B_R$</p><blockquote><p>迭代器不考。</p></blockquote></li></ul><h3 id="一趟扫描算法"><a href="#一趟扫描算法" class="headerlink" title="一趟扫描算法"></a>一趟扫描算法</h3><ul><li><p>关系 $R$ 数据读取：</p><blockquote><p>$B(R)$ 是 $R$ 的<strong>存储块</strong>（磁盘块）数目</p><p>$T(R)$ 是 $R$ 的<strong>元组</strong>数目</p><p>忽略写回代价</p></blockquote><ul><li><p>聚簇关系：</p><blockquote><p>指关系的元组集中存放（一个块中仅是一个关系中的元组）。</p></blockquote><ul><li><p>TableScan(R) 为表空间扫描算法：</p><p>​    扫描结果未排序 $B(R)$</p></li><li><p>SortTableScan(R)：</p><p>​    扫描结果<strong>排序</strong> $B(R)\quad or\quad 3B(R)$</p><blockquote><p>内存装得下 $R$ 就只需要 $B(R)$，否则需要 $3B(R)$：</p><ul><li>先读一遍 $R$，做第一趟排序。</li><li>写回磁盘一次，因为还需要第二趟排序。</li><li>再多路读 $R$，做归并排序。</li><li>不考虑写回，上面共 $3B(R)$。</li></ul></blockquote></li><li><p>IndexScan(R) 为索引扫描算法：</p><p>​    扫描结果未排序 $B(R)$</p></li><li><p>SortIndexScan(R)：</p><p>​    扫描结果排序 $B(R)\quad or\quad 3B(R)$</p></li></ul></li><li><p>非聚簇关系：</p><blockquote><p>关系的元组不一定集中存放（一个块中不仅是一个关系中的元组）。最坏情况下就是相邻的元组都不在同一磁盘块，每次都要读一个新磁盘。</p></blockquote><ul><li>扫描结果未排序为 $T(R)$</li><li>扫描结果排序为 $T(R) + 2B(R)$</li></ul></li></ul></li><li><p>去重复 $\&amp;(R)$：</p><ul><li>在<strong>内存中保存</strong>已处理过的元组。</li><li>当新元组到达时，需与之前处理过的元组进行比较。</li><li>建立不同的<strong>内存数据结构</strong>（排序结构/散列结构/B+ 树），来保存之前处理过的数据，以便快速判断是否重复。</li><li>算法复杂性为 $B(R)$</li><li>应用条件为 $B(\&amp;(R))\le M$</li></ul></li><li><p>分组聚集 $\gamma _L(R)$</p><ul><li><p>需要在内存中保存所有的分组，保存每个分组上的聚集信息。</p></li><li><p>建立不同的内存数据结构（排序结构/散列结构/B+ 树），来保存之前处理过的数据，以便快速处理整个关系上的操作。</p></li><li>算法复杂性为 $B(R)$</li><li>应用条件为<strong>所有分组的数量应能在内存中完整保存</strong>。</li></ul></li><li><p>集合或者包上的二元运算：</p><ul><li><strong>扫描一个关系</strong> $R$，然后<strong>再扫描另一个关系</strong> $S$。</li><li>集合的操作需要去重复。包的操作需要做计数每个元组的<strong>出现次数</strong>（具体操作还需具体分析）。</li><li>算法复杂性为 $B(R)+B(S)$</li><li>应用条件为 $min(B(R), B(S))\le M$（只要用一个能放入内存就行）。</li></ul></li><li><p>连接操作实现算法 $P_4$ 的改进：</p><ul><li>主要思想就是把内存操作的两重循环通过散列的方式，压缩到一重循环就行。</li><li>散列函数可取连接条件中的相应属性，使得<strong>散列结果相同说明这两个属性满足连接条件</strong>。</li></ul></li></ul><h3 id="基于索引的选择算法"><a href="#基于索引的选择算法" class="headerlink" title="基于索引的选择算法"></a>基于索引的选择算法</h3><ul><li><p><strong>选择</strong>条件中有涉及到<strong>索引属性</strong>时，可以使用索引，辅助快速检索。</p></li><li><p>聚簇和非聚簇索引，使用时其效率是不一样的。</p></li><li><p>案例分析🗡：</p><ul><li><p>假设 $B(R)=1000, T(R)=20000$，即 $R$ 有 $20000$ 个元组存放到 $1000$ 个块中。</p></li><li><p>$a$ 是 $R$ 的一个属性，在 $a$ 上有一个索引，并且考虑 $\sigma_{a=0}(R)$ 操作：</p><ul><li><p>如果 $R$ 是<strong>聚簇</strong>的，且<strong>不使用索引</strong>，查询代价 $=~1000$ 个 I/O。</p><blockquote><p>一个块中仅是一个关系中的元组，所以最多遍历 $1000$ 次磁盘块就能找到所以元组。</p></blockquote></li><li><p>如果 $R$ <strong>不是聚簇</strong>的，且<strong>不使用索引</strong>，查询代价 $=~20000$ 个 I/O。</p><blockquote><p>一个块中不仅是一个关系中的元组，可能含有其他数据，必须通过元组的指针进行遍历，所以要访问 $20000$ 个元组，考虑最坏情况，相邻元组都不在同一个块，那么就要访问 $20000$ 个块。</p><p>$V(A, R)$ 表示 $R$ 中属性 $A$ 出现不同值的数目，即 $\Pi_A(R)$ 的数目。</p><p>PPT 中 $A,R$ 的顺序时常发生改变，询问老师说都可以。书上是属性在前，关系名在后。为了统一写法，下面全部采用书本的形式，因此和 PPT 几乎都是相反的。</p></blockquote></li><li><p>如果 $V(a,R)=100$ 且索引是聚簇的，查询代价估计 $=1000/100=10$ 个 I/O。</p><blockquote><p>有索引的帮助，可以快速定位到这个元组，再加上是聚簇的，所以相同值的也是相邻的。</p><p>因为有 $100$ 个不同的值，所以在最坏情况下平均分散到 $10$ 个块里面。</p></blockquote></li><li><p>如果 $V(a,R)=100$ 且索引是非聚簇的，查询代价 $=~20000/100=200$ 个 I/O。</p></li><li><p>如果 $V(a,R)=20000$，即 $a$ 是关键字，主键索引，查询代价 $=~20000/20000=1$ 个 I/O，不管是否是聚簇的。</p></li></ul></li></ul></li><li><p>基于有序索引的连接算法（Zig-Zag 连接算法）:</p><ul><li>以 $R$ 和 $S$ 做等值连接为例。</li><li>$R$ 和 $S$ 都有在 $Y$ 属性上的 B+ 树索引。</li><li>$R$ 和 $S$ 均从左至右读取索引树的叶子结点：<ol><li>读 $R$ 的第一个索引项赋予 $a$，再读 $S$ 的第一个索引项赋予 $b$；</li><li>如果 $a\not=b$，则：<ul><li>如果 $a&lt;b$，则将 $R$ 的下一个索引项赋予 $a$，继续执行 $2$。</li><li>如果 $a&gt;b$，则将 $S$ 的下一个索引项赋予 $b$，继续执行 $2$。</li></ul></li><li>如果 $a=b$，则将 $R$ 和 $S$ 关系中对应的元组读出并进行连接，直到 $R$ 的所有相等的 $a$ 值和 $S$ 的所有相等的 $b$ 值对应的元组都处理完毕，将 $R$ 的下一个索引项赋予 $a$，将 $S$ 的下一个索引项赋予 $b$，继续执行 $2$。</li></ol></li></ul></li></ul><h3 id="两阶段多路归并排序-TPMMS"><a href="#两阶段多路归并排序-TPMMS" class="headerlink" title="两阶段多路归并排序 TPMMS"></a>两阶段多路归并排序 TPMMS</h3><blockquote><p>实验做，考试老师说不会考。</p></blockquote><ul><li><p>基本思路：</p><ul><li><p>第一趟：</p><p>​    划分子集，并使子集具有某种特性，如有序或相同散列值等。</p></li><li><p>第二趟：</p><p>​    处理全局性内容的操作，形成<strong>结果</strong>关系。如<strong>多子集间的归并排序</strong>，相同散列值子集的操作等。</p></li></ul></li><li><p>内排序：</p><p>​    待排序的数据可一次性地装入内存中，即排序者可以完整地看到和操纵所有数据。内存中数据的排序算法有插入排序、选择排序、冒泡排序等。</p></li><li><p>外排序：</p><p>​    待排序的数据不能一次性装入内存，即排序者不能一次完整地看到和操纵所有数据，需要将数据分批装入内存分批处理的排序问题。</p></li><li><p>多路归并的过程（仅简单分析）：</p><ul><li><p>设内存块数为 $B_{memory}$，待排序数据块数为 $B_{problem}$。</p></li><li><p>第一趟划分子集并排序，这里要求每个子集的块数要小于等于内存块数 $B_{memory}$，I/O 次数为 $2B_{problem}$。</p></li><li><p>第二趟各子集间的归并排序，这里要求子集的数目要小于内存块数 $B_{memory}$，I/O 次数为 $2B_{problem}$。</p><blockquote><p>这两个限制说明大数据集块数 $\le B^2_{memory}$。</p><p>同时内存的块中得有一块用来输出（第一趟不需要输出块），一块用来比较（老师说可以没有）。</p></blockquote></li><li><p>算法的效率：</p><p>​    读写磁盘块的次数，即 I/O 数 $=4B_{problem}$。</p></li></ul></li></ul><h3 id="语法优化技术"><a href="#语法优化技术" class="headerlink" title="语法优化技术"></a>语法优化技术</h3><blockquote><p>必考，估计选择填空题🗡。</p></blockquote><ul><li><p>通过语法树，表达和分析关系代数表达式：</p><ul><li>长这样：</li></ul><p><img src="/img/blog/ds-note-images/image-20211021164943547.png" style="zoom:67%;"></p><p>从叶子到树根执行。</p><ul><li><p>策略：</p><ul><li><p>尽可能<strong>提前</strong>选择和投影（相当于这两个运算在语法树上尽量下放）：</p><p>​    可使中间结果变小，节省几个数量级的执行时间。</p></li><li><p><strong>选择与投影</strong>尽量一起做：</p><p>​    投影或选择后，下一个投影或选择操作通过中间结果进行操作，这样就不需要再从磁盘读数据。</p></li><li><p>投影与其前后的二元运算结合：</p><p>​    通过投影，去掉关系的<strong>无关属性</strong>（不参与二元运算的属性），可以避免多次扫描整个关系。</p><blockquote><p>PPT 似乎只使用了以上三个策略，后面 MOOC 中有使用，还是按 PPT 来吧。</p></blockquote></li><li><p>笛卡尔积转连接运算（把选择与其前的笛卡尔积合并成一个连接）：</p><p>​    当 $R\times S$ 前有选择运算且其中<strong>存在条件</strong>是 $R,S$ 属性间比较的运算时，可将其转化为<strong>连接</strong>运算可节省时间。</p></li><li><p>执行连接运算前对关系做适当预处理：</p><p>​    文件排序、建立临时索引等，可使两关系公共值高效联接。</p></li><li><p>找出表达式里的公共子表达式：</p><p>​    若公共子表达式结果不大，则预先计算，以后可读入此结果，节时多，尤当视图情况下有用。</p></li></ul></li></ul></li><li><p>关系代数操作次序交换的等价性：</p><ul><li><p>$L_1$，<strong>连接与积</strong>（并交）的<strong>交换</strong>律：</p><p>​    设 $E_1, E_2$ 是关系代数表达式，$F$ 是 $E_1, E_2$ 中属性的附加限制条件，则有：</p></li></ul></li></ul><script type="math/tex; mode=display">\begin{aligned}E_1 \bowtie E_2 &\equiv E_2 \bowtie E_1 \\E_1 \underset{F}\bowtie E_2 &\equiv E_2 \underset{F}\bowtie E_1 \\E_1 \times E_2 &\equiv E_2 \times E_1\end{aligned}</script><blockquote><p>通过交换，可以将 $E_1, E_2,\cdots ,E_n$ 中结果小集合小的放入内存，进行连接或者积操作，可以减小中间结果。</p></blockquote><ul><li><p>$L_2$，<strong>连接与积</strong>（并交）的<strong>结合</strong>律:</p><p>​    若 $E_1, E_2, E_3$ 是关系代数表达式，$F_1, {~F}_2$ 是条件，则有:</p><script type="math/tex; mode=display">\begin{aligned}(E_1 \underset{F_1}\bowtie E_2) \underset{F_2}\bowtie E_3 \equiv E_1 \underset{F_1}\bowtie (E_2\underset{F_2}\bowtie E_3)\\(E_1 \bowtie E_2) \bowtie E_3 \equiv E_1 \bowtie(E_2 \bowtie E_3)\\(E_1 \times E_2) \times E_3 \equiv E_1 \times(E_2 \times E_3)\end{aligned}</script><blockquote><p>结合律和交换律说明结果与运算顺序无关，可以将 $E_1, E_2,\cdots ,E_n$ 中结果集合排序，升序放入内存，进行连接或者积操作，可以减小中间结果。</p></blockquote></li><li><p>$L_3$，<strong>投影</strong>串接律（双向使用）：</p><p>​    设属性集 $\{A_1,\cdots, A_{n}\} \subseteq \{B_1, \cdots, B_m\}$，$ E$ 是表达式，则有:</p><script type="math/tex; mode=display">\Pi_{A_1, \cdots, A_{n}}\left(\Pi_{B_1, \cdots, B_m}(E)\right) \equiv \Pi_{A_1, \cdots, A_{n}}(E)</script><blockquote><p>从左往右使用，两遍扫描变为一遍扫描，减少 IO 次数。</p><p>从右到左使用，可以用于扩充，便于将投影在语法树中下放，减少无关属性。</p></blockquote></li><li><p>$L_4$，<strong>选择</strong>串接律（双向使用）：</p><p>​    若 $E$ 是关系代数表达式，$F_1, ~F_2$ 是条件，则有:</p><script type="math/tex; mode=display">\sigma_{F_1}\left(\sigma_{F_2}(E)\right) \equiv \sigma_{F_1 \wedge F_2}(E)</script><blockquote><p>理由其实同上，只是扩充的时候是选择下放。</p></blockquote></li><li><p>$L_5$，<strong>选择和投影</strong>的<strong>交换</strong>律：</p><ul><li>设条件 $F$ 只涉及属性 $\{A_1, \ldots, A_{n}\}$，$E$是关系表达式，则有:</li></ul><script type="math/tex; mode=display">\Pi_{A_1, \cdots, A_{n}}\left(\sigma_F(E)\right) \equiv \sigma_F\left(\Pi_{A_1,\cdots, A_{n}}(E)\right)</script><ul><li>更一般地，若 $F$ 还涉及不属于 $\{A_1, . ., A_n\}$ 的属性 $\{B_1, . ., B_m\}$，则：</li></ul><script type="math/tex; mode=display">\Pi_{A_1, \cdots, A_{n}}\left(\sigma_F(E)\right) \equiv \Pi_{A_1, \cdots, A_{n}}\left(\sigma_F\left(\pi_{A_1,\cdots, A_{n}, B_1, \cdots, B_m}(E)\right)\right)</script></li><li><p>$L_6$，<strong>选择和积</strong>的<strong>交换</strong>律：</p><p>​    设 $E_1, E_2$ 是关系代数表达式：</p><ul><li>若条件 $F$ 只涉及 $E_1$ 中的属性，则有：</li></ul><script type="math/tex; mode=display">\sigma_F\left(E_1 \times E_2\right) \equiv \sigma_F\left(E_1\right) \times E_2</script><ul><li>若 $F=F_1 \wedge F_2, F_1, F_2$ 分别只涉及 $E_1, E_2$ 中属性, 则有：</li></ul><script type="math/tex; mode=display">\sigma_F\left(E_1 \times E_2\right) \equiv \sigma_{F_1}\left(E_1\right) \times \sigma_{F_2}\left(E_2\right)</script><ul><li>若 $F=F_1 \wedge F_2, {~F}_1$ 只涉及 $E_1$ 中属性，而 $F_2$ 涉及 $E_1,E_2$ 中属性，则有：</li></ul><script type="math/tex; mode=display">\sigma_F\left(E_1 \times E_2\right) \equiv \sigma_{F_2}\left(\sigma_{F_1}\left(E_1\right) \times E_2\right)</script></li><li><p>$L_7$，<strong>投影和积</strong>的<strong>交换</strong>律：</p><p>​    设 $E_1, E_2$ 为两关系代数表达式，$A_1, \cdots, A_{n}$ 是出现在 $E_1$ 或 $E_2$ 中的一些属性，其中 $B_1, \cdots, B_m$ 出现在 $E_1$ 中，<strong>剩余的属性</strong> $C_1, \cdots, C_k$ 出现在 $E_2$ 中，则有:</p><script type="math/tex; mode=display">\Pi_{A_1, \cdots, A_{n}}\left(E_1 \times E_2\right) \equiv \Pi_{B_1, \cdots, B_m}\left(E_1\right) \times \Pi_{C_1, \cdots, C_k}\left(E_2\right)</script></li><li><p>$L_8$，<strong>选择和并</strong>的<strong>交换</strong>律：</p><p>​    设关系代数表达式 $E=E_1 \cup E_2, F$ 是条件，则有:</p><script type="math/tex; mode=display">\sigma_F\left(E_1 \cup E_2\right) \equiv \sigma_F\left(E_1\right) \cup \sigma_F\left(E_2\right)</script><blockquote><p>此定理要求 $E_1, E_2$ 是<strong>并相容</strong>的。</p></blockquote></li><li><p>$L_9$，<strong>选择和差</strong>的<strong>交换</strong>律：</p><p>​    设关系代数表达式 $E=E_1-E_2, F$ 是条件，则有:</p><script type="math/tex; mode=display">\sigma_F\left(E_1-E_2\right) \equiv \sigma_F\left(E_1\right)-\sigma_F\left(E_2\right)</script></li><li><p>$L_{10}$，<strong>投影和并</strong>的<strong>交换</strong>律：</p><p>​    设关系代数表达式 $E=E_1 \cup E_2, A_1, \cdots, A_{n}$ 是 $E$ 中的一些属性，则有:</p><script type="math/tex; mode=display">\Pi_{A_1, \cdots, A_{n}}\left(E_1 \cup E_2\right) \equiv \Pi_{A_1, \cdots, A_{n}}\left(E_1\right) \cup \pi_{A_1, \cdots, A_{n}}\left(E_2\right)</script><blockquote><p>因为投影会去重，<strong>投影和差</strong>的<strong>交换</strong>律是不成立的，即：</p><script type="math/tex; mode=display">\Pi_{A_1, \cdots, A_{n}}\left(E_1 - E_2\right) \not\equiv \Pi_{A_1, \cdots, A_{n}}\left(E_1\right) - \pi_{A_1, \cdots, A_{n}}\left(E_2\right)</script><p>一个大概的例子：</p><p>​    假设 $E_1$ 只有 $3$ 个元组，在属性 ${A_1, \cdots, A_{n}}$ 上都相等，$E_2$ 只有一个元组，与 $E_1$ 的 $3$ 个元组之一相等。</p><ul><li><p>先差后投影：</p><p>​    $E_1-E_2$ 有两个元组，去重后有 $1$ 个元组。</p></li><li><p>先投影后差：</p><p>​    投影后 $E_1,E_2$ 都只有一个元组，差运算后结果为空，与前者不等价。</p></li></ul></blockquote></li></ul><ul><li><p>优化算法执行流程：</p><ul><li><p>依据选择串接律 $\sigma_{F_1}\left(\sigma_{F_2}(E)\right) \equiv \sigma_{F_1 \wedge F_2}(E)$，对于右边形式的关系表达式，转为左边串接形式。</p></li><li><p>对每个选择和投影，依据定理 $L_4$ 至 $L_9$，尽可能把它下放（如果一个投影是对某表达式所有属性进行的，相当于 <code>select *</code>，则去掉）</p></li><li><p>依据选择串接律和投影串接律把串接的选择和投影组合为单个选择、单个投影。</p><blockquote><p>笔者感觉以上修改要多次使用，直到不能再应用为止。</p></blockquote></li><li><p>对修改后的语法树，将其内结点按以下方式<strong>分组</strong>：</p><ul><li>每个二元运算结点（积、并、差、连接等）和其所有<strong>一元运算直接祖先结点</strong>放在 一组</li><li>对于其后代结点，若后代结点是一串<strong>一元运算</strong>且<strong>以树叶为终点</strong>，则将这些一元运算结点放在该组中。</li><li>若后代节点有二元运算结点<strong>笛卡儿积</strong>，则不能将后代结点归入该组。</li><li>笔者认为可能是从叶子节点向上分组，这样遇到一个二元运算节点就做判断，这个二元节点向上的一元运算归为一组，向下到叶子节点的运算也归为这组，然后整个组就独立执行，输出一个结果集合，相当于一个叶子节点了。重复这个过程直到执行完毕。</li></ul></li><li><p>语法树执行顺序为：</p><p>​    以每组结点为一步，后代先执行，从叶子执行到根。</p></li></ul></li></ul><h3 id="代价估计🗡"><a href="#代价估计🗡" class="headerlink" title="代价估计🗡"></a>代价估计🗡</h3><ul><li><p>统计信息：</p><ul><li><p>$T_R$ 或 $T(R)$：</p><p>​    关系 $R$ 的元组数目。</p></li><li><p>$V(A, R)$：</p><p>​    $R$ 中属性 $A$ 出现不同值的数目，即 $\Pi_A(R)$ 的数目。</p><blockquote><p>PPT 中 $A,R$ 的顺序时常发生改变，询问老师说都可以。书上是属性在前，关系名在后。为了统一写法，下面全部采用书本的形式，因此和 PPT 几乎都是相反的。</p></blockquote></li></ul></li><li><p>估计的目标：</p><p>​    给定一个表达式 $E$，如何估计 $E$ 的元组数目 $T(E)$。</p></li><li><p>估算 $\pi_A(R)$ 的大小：</p><blockquote><p>PPT：</p><p>​    $T(\pi_A(R))=T(R)$</p><p>笔者认为应该是：</p><p>​    $T(\pi_A(R))=V(A,R)$</p><p>投影运算并末减少行数，但可能有效地减少了存储结果关系的<strong>块数</strong>（每个元组所占的大小减少）。</p></blockquote></li><li><p>估算选择运算 $S= \sigma_{ A=c} (R)$ 的大小：</p><blockquote><p>严谨：</p><p>​    $T(S)$ 介于 $[0,T(R)-V(A, R)+1]$ 之间</p><p>原因分析：</p><ul><li>最小值为 $0$，因为可能关系 $R$ 中的 $A$ 属性不存在值为 $c$ 的元组。</li><li>最大值为 $T(R)-V(A, R)+1$，即关系 $R$ 中的 $A$ 属性值不为 $c$ 的元组数目都是 $1$，共有 $V(A,R)$。</li></ul><p>估计：</p><p>​    $T(S)=T(R) / V(A, R)$，即 $A$ 属性不同值的元组数相等。</p><p>暴力估计：</p><p>​    不知道 $V(R,A)$ 时，默认为 $10$，即 $T(S) = T(R)/10$。</p></blockquote></li><li><p>估算选择运算 $S=\sigma_{A&lt;c}(R)$ 的大小：</p><blockquote><p>严谨：</p><p>​    $T(S)$ 介于 $0$ to $T(R)$ 之间</p><p>分析：</p><ul><li>最小值 $0$ 即不存在这样的元组。</li><li>最多 $T(R)$ 即所有元组都满足条件。</li></ul><p>估计：</p><p>​    $T(S)=T(R) / 2$，应有一半的元组满足条件。</p><p>实际常用估计：    </p><p>​    $T(S)=T(R) / 3$</p></blockquote></li><li><p>估算选择运算 $S=\sigma_{A=10\quad and\quad B&lt;20}(R)$ 的大小</p><blockquote><p>估计：</p><p>​    $T(S)=T(R) /(V(R, A)^{*} 3)$</p><p>分析：</p><ul><li>$\sigma_{A=10\quad and\quad B&lt;20}(R)=\sigma_{B&lt;20}(\sigma_{A=10}(R))$</li><li>$A=10$，得出 $T(S)=T(R) / V(R, A)$</li><li>$B&lt;20$，得出 $T(S)=T(S) / 3$</li></ul></blockquote></li><li><p>估算选择运算 $S = \sigma_{C_1\quad or\quad C_2}(R)$ 的大小：</p><blockquote><p>估计：</p><p>​    $\begin{aligned}T(S)={n}(1-(1-\frac{m_1}{n})(1-\frac{m_2}{n}))\end{aligned}$</p><p>分析：</p><ul><li>$R$ 有 $n$ 个元组，其中有 $m_1$ 个满足 $C_1$，有 $m_2$ 个满足 $C_2$。</li><li>$\begin{aligned}(1-\frac{m_1}{n})\end{aligned}$ 是不满足 $C_1$ 的那些元组，$\begin{aligned}(1-\frac{m_2}{n})\end{aligned}$ 是不满足 $C_2$ 的那些元组。</li><li>两数之积是不满足条件的元组概率（这里并不严谨），$1$ 减去这个积就是满足条件元组出现的概率。</li></ul></blockquote></li><li><p>前一种类型的举例，估计选择运算 $S=\sigma_{A=10\quad or\quad B&lt;20} (R)$ 的大小：</p><blockquote><p>分析：</p><script type="math/tex; mode=display">\begin{gathered}n=T(R)=10000\\ V(R, A)=50 \\m_1=T(R) / V(R, A)=10000 / 50=200\\m_2=T(R) / 3=10000 / 3 \approx 3333\end{gathered}</script><p>即有 $m_1$ 个满足 $C_1$，有 $m_2$ 个满足 $C_ 2$，$\begin{aligned}(1-\frac{m_1}{n})(1-\frac{m_2}{n})\end{aligned}$ 是不满足这个条件的元组的概率，计算如下：</p><script type="math/tex; mode=display">T(S)=10000^{\star}(1-(1-200 / 10000)(1-3333 / 10000)) \approx 3466</script><p>也可以简单估计为 $T(S)=T(R) / 3=10000 / 3 \approx 3333$</p></blockquote></li><li><p>估算连接运算 $S’=R(X, Y)\quad \text{Natural Join}\quad S(Y, Z)$ 的大小：</p><blockquote><p>估计：</p><p>​    $\begin{aligned}T({S’})=\frac{T(R)T(S) }{\max(V(Y, R), V(Y, S))}\end{aligned}$</p><p>分析：</p><ul><li><p>假定 $V(Y, R)\ge V(Y, S), R$ 中元组 $r$ 和 $S$ 中元组有相同 $Y$ 值的概率 $=1 / V(Y,R)$</p></li><li><p>假定 $V(Y, R)&lt;V(Y, S), R$ 中元组 $r$ 和 $S$ 中元组有相同 $Y$ 值的概率 $=1 / V(Y, S)$</p></li><li><p>则笛卡尔积后的关系在 $Y$ 上相等的概率 $=1 / \max (V(R, Y), V(S, Y))$</p></li><li><p>笔者尝试解释：</p><ul><li><p>首先假设数据是均匀分布，即假设一个关系 $U$ 的 $Y$ 属性中，具有相同属性值的元组数均为 $x$ 个，这样总元组数是 $x\times V(Y,U)$。</p></li><li><p>$R$ 关系的总元组数为 $x_R\times V(Y,R)$，$S$ 关系的总元组数为 $x_S\times V(Y,S)$。</p></li><li><p>假设 $R.Y\subseteq S.Y,V(Y, R)&lt;V(Y,S)$，即 $R$ 的 $Y$ 属性值在 $S$ 中均存在。这使得 $R$ 的每个元组，都能等值连接 $x_S$ 个 $S$ 的元组。</p></li><li><p>所以 $R\times S$ 中，满足 $R.Y=S.Y$ 的元组数为 $x_R\times V(Y,R)\times x_S$。然后除以总元组数即可得到概率（其实分子就是估计值 $T(S’)$）：</p><script type="math/tex; mode=display">\frac{x_R\times V(Y,R)\times x_S}{x_R\times V(Y,R)\times x_S \times V(Y,S)}=\frac{1}{V(Y,S)}</script></li></ul></li><li><p>PPT 上的例子 $T(R)=10000, T(S)=50000, V(R, Y)=500, V(S, Y)=1000$，</p><p>估计为 $T(S’)=10000 * 50000 / 1000=500000$</p></li></ul></blockquote></li></ul><h2 id="数据库事务处理技术"><a href="#数据库事务处理技术" class="headerlink" title="数据库事务处理技术"></a>数据库事务处理技术</h2><h3 id="事务（纯复制）"><a href="#事务（纯复制）" class="headerlink" title="事务（纯复制）"></a>事务（纯复制）</h3><ul><li><p>事务的定义：</p><ul><li>事务是数据库管理系统提供的控制数据操作的一种手段。</li><li>通过这一手段，应用程序员将一系列的数据库操作组合在一起作为一个整体进行操作和控制，以便数据库管理系统能够提供一致性状态转换的保证。</li></ul></li><li><p>事务的宏观性（应用程序员看到的事务）：</p><p>​    一个存取或改变数据库内容的程序的一次执行，或者说一条或多条 SQL 语句的一次执行被看作一个事务。</p><blockquote><p>事务一般是由应用程序员提出，因此有开始和结束，结束前需要<strong>提交或撤消</strong>（通过 commit 或 rollback 确认的）。</p></blockquote></li><li><p>事务的微观性（DBMS 看到的事务）：</p><p>​    对数据库的一系列基本操作（读、写）的一个整体性执行。</p></li><li><p>事务的并发执行：</p><p>​    多个事务从宏观上看是并行执行的，但其微观上的基本操作（读、写）则可以是交叉执行的。</p><blockquote><p>并发控制就是通过事务微观交错执行次序的正确安排，保证事务宏观的独立性、完整性和正确性。</p></blockquote></li><li><p>事务的特性（ACID 特性🗡）：</p><ul><li><p><strong>原子性</strong>（atomicity）：</p><p>​    事务的所有操作在数据库中<strong>要么全部正确反映出来，要么完全不反映</strong>。</p></li><li><p><strong>一致性</strong>（consistency）：</p><p>​    保证事务的操作状态是正确的，不能出现「<strong>丢失修改，不可重复读，脏读</strong>」三类错误，由隔离性保证。</p><blockquote><ul><li><p>丢失修改：</p><p>​    操作顺序是 $T_1$ 读，$T_2$ 读，$T_1$ 写，$T_2$ 写。$T_1$ 的修改就被  $T_2$ 所覆盖了，即丢失了修改。</p></li><li><p>不可重复读（理应能够重复读，但是现在不能重复读了，同一事务两次读期间未作修改，但读到的内容却不同）：</p><p>​    操作顺序是 $T_1$ 读，$T_2$ 读，$T_2$ 写，$T_1$ 再读，发现与第一次读的数据不一致。</p></li><li><p>脏读：</p><p>​    操作顺序是 $T_2$ 读，$T_2$ 写，$T_1$ 读，$T_2$ 回滚，此时 $T_1$ 读到的是其他事务未提交的数据，回滚后这个数据已经无效了，称为脏数据。</p></li></ul></blockquote></li><li><p><strong>隔离性</strong>（isolation）：</p><p>​    尽管多个事务可能并发执行，但系统保证，对于任何一对事务 $T_i$ 和 $T_j$，在 $T_i$ 看来，$T_j$ 或者在 $T_i$ 开始之前已经完成执行，或者在 $T_i$ 完成之后开始执行。因此，每个事务都感觉不到系统中有其他事务在并发地执行。</p></li><li><p><strong>持久性</strong>（durability）：</p><p>​    一个事务成功完成后，它对数据库的改变必须是<strong>永久</strong>的，即使出现系统故障。</p></li></ul><blockquote><p>可以说具有 ACID 特性的若干数据库基本操作的组合体被称为事务。</p></blockquote></li></ul><h3 id="事务调度"><a href="#事务调度" class="headerlink" title="事务调度"></a>事务调度</h3><ul><li><p>事务调度概念：</p><p>​    一组事务的基本步骤（读、写、其他控制操作如加锁、解锁等）的一种执行顺序称为对这组事务的一个调度。</p></li><li><p>并发调度的正确性：</p><p>​    并发调度下所得到的新数据库<strong>结果</strong>与分别串行地运行这些事务所得的新数据库完全一致，调度才是正确的，是结果意义上的正确。</p></li><li><p>可串行性：</p><p>​    如果不管数据库初始状态如何，一个调度对数据库状态的影响都和某个<strong>串行调度</strong>相同，则我们说这个调度是可串行化的或具有可串行性。</p><blockquote><p>可串行化调度一定是正确的并行调度，但正确的并行调度，却未必都是可串行化的调度。</p><p>因为并行调度的正确性是指<strong>内容上</strong>结果正确性（结果对就对了），而可串行性是指<strong>形式上</strong>结果正确性，便于操作。</p></blockquote></li><li><p>一种简单的事务调度的标记模型：</p><ul><li><p>$r_T(A)$： </p><p>​    事务 $T$ 读 $A$。</p></li><li><p>$w_T(A)$：</p><p>​    事务 $T$ 写 $A$。</p></li></ul></li><li><p>冲突：</p><ul><li><p>如果调度中两个动作的顺序交换，若涉及的事务中至少有一个事务的行为会改变，则称这两个动作<strong>冲突</strong>。</p></li><li><p>有冲突的两个操作是不能交换次序的，没有冲突的两个事务是可交换的</p></li><li><p>几种冲突的情况：</p><ul><li><strong>同一事务</strong>的<strong>任何两个操作</strong>都是冲突的：<script type="math/tex; mode=display">r_i(X) ; w_i(Y) \quad w_i(X) ; r_i(Y)</script></li><li><strong>不同事务</strong>对<strong>同一元素</strong>的两个<strong>写</strong>操作是冲突的：<script type="math/tex; mode=display">w_i(X) ; w_j(X)</script></li><li><strong>不同事务</strong>对<strong>同一元素</strong>的<strong>一读一写</strong>操作是冲突的：<script type="math/tex; mode=display">w_i(X) ; r_j(X) \quad r_i(X) ; w_j(X)</script></li></ul></li></ul></li><li><p>冲突可串行性： </p><p>​    一个调度，如果通过<strong>交换</strong>相邻两个<strong>无冲突</strong>的操作能够转换到某一个<strong>串行</strong>的调度（注意不是可串行），则称此调度为<strong>冲突可串行化</strong>的调度。</p><blockquote><p><strong>冲突可串行性</strong>是比<strong>可串行性</strong>更严格的概念，即<strong>冲突可串行性</strong>是<strong>可串行性</strong>的充分不必要条件。</p><p>例子：</p><p>​    $w_1(Y) ; w_2(Y) ; w_2(X) ; w_1(X) ; w_3(X)$ 是一个<strong>可串行化</strong>的调度，因为它与串行调度 $w_1(Y) ; w_1(X) ; w_2(Y) ; w_2(X) ; w_3(X)$ 的结果等价。</p><p>​    但是它相邻动作都是冲突的，不能交换形成串行调度，所以不是<strong>冲突可串行性</strong>的调度。</p></blockquote></li><li><p>冲突可串行性判别算法：</p><ul><li>构造一个有向图，结点是每一个事务 $T_i$。</li><li>如果 $T_i$ 的一个操作与 $T_j$ 的一个操作发生冲突，且 $T_i$ 在 $T_j$ 前执行，则绘制一条由 $T_j$ 指向 $T_j$ 的有向边，表示 $T_i$ 要在 $T_j$ 前执行。</li><li>如果此有向图没有环，则是冲突可串行化的。</li></ul><blockquote><p>例子：</p><div align="center"><img src="/img/blog/ds-note-images/image-20211116223739408.png"></div><p>与边上的元素无关，只要存在环就是不满足冲突可串行的。</p></blockquote></li></ul><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul><li><p>锁的类型：</p><ul><li><p>排他锁 X：</p><p>​    只有一个事务能读、写，其他任何事务都不能读、写。</p></li><li><p>共享锁 S：</p><p>​    所有事务都可以读，但任何事务都不能写。</p></li><li><p>更新锁 U：</p><p>​    初始读，以后可升级为写。</p></li><li><p>增量锁 I（后面不涉及）：</p><p>​    增量更新（例如 $A=A+x$）区分增量更新和其他类型的更新。</p></li></ul></li><li><p>相容性矩阵：</p><ul><li><p>当某事务对一数据对象<strong>持有一种锁</strong>时，<strong>另一事务</strong>再申请对该对象加某一类型的锁，是允许（填「是」）还是不允许（填「否」）。</p></li><li><p>有更新锁的情况：</p><p>|              |          |  申请锁  |  申请锁  |  申请锁  |<br>| :—————: | :———: | :———: | :———: | :———: |<br>|              |          | 共享锁 S | 排他锁 X | 更新锁 U |<br>| 持有锁的模式 | 共享锁 S |    是    |    否    |    是    |<br>| 持有锁的模式 | 排他锁 X |    否    |    否    |    否    |<br>| 持有锁的模式 | 更新锁 U |    否    |    否    |    否    |</p></li></ul></li><li><p><strong>锁协议</strong>：</p><blockquote><p>🗡重难点，PPT 更改了很多次，也特意问了老师和同学，希望下面理解是正确的，考试大题问使用哪种锁协议，并说明理由。</p></blockquote><ul><li><p>背景：</p><p>​    一开始并发控制的时候，读写完全没有锁，如果不是可串行化调度就会出错。</p></li><li><p>$0$ 级协议：</p><ul><li><p>所有写操作都要加排他锁，但排他锁是写完就释放，而不是直到提交事务才释放。</p><div align="center"><img src="/img/blog/ds-note-images/image-20211117001704015.png"></div><blockquote><p>注意在排他锁期间是可以读的，读操作并没有要求上锁，也就不会因为申请有关读的锁而阻塞。</p></blockquote></li><li><p><strong>不能防止丢失修改，不可重复读，脏读</strong>三种不一致错误，<del>完全没用属于是</del>。</p><blockquote><p>分析：</p><ul><li><p>丢失修改：</p><div align="center"><img src="/img/blog/ds-note-images/image-20211117000600586.png"></div></li><li><p>不可重复读：</p><p></p><div align="center"><img src="/img/blog/ds-note-images/image-20211117000728378.png"><p></p></div></li><li><p>脏读：</p><p></p><div align="center"><img src="/img/blog/ds-note-images/image-20211117000704174.png"><p></p></div></li></ul></blockquote></li></ul></li><li><p>$1$ 级协议：</p><ul><li><p>所有写操作都要加排他锁，排他锁直到提交事务才释放。</p><p></p><div align="center"><img src="/img/blog/ds-note-images/image-20211117001725343.png"><p></p></div></li><li><p>可以<strong>防止丢失修改</strong>，因为在别人不能在你提交前进行修改（有写排他锁），这样你的修改将可以一直保留到提交。</p></li><li><p>不能防止不可重复读和脏读，理由完全同 $0$ 级协议的图，因为对读没有任何限制，你排他锁关我读操作什么事。</p></li></ul></li><li><p>$2$ 级协议：</p><ul><li><p>所有写操作同 $1$ 级协议，读操作要加<strong>共享锁</strong>，但共享锁是读完就释放，而不是直到提交事务才释放。</p><div align="center"><img src="/img/blog/ds-note-images/image-20211117001833104.png"></div></li><li><p>可以<strong>防止丢失修改</strong>，理由同 $1$ 级协议。</p></li><li><p>可以<strong>防止脏读</strong>，因为读操作需要申请<strong>共享锁</strong>，你能申请到共享锁，是因为这个元素没有被上<strong>排他锁</strong>，所以就不会有对该元素的写操作，那么即使有回滚也和该元素无关。</p></li><li><p><strong>不能防止不可重复读</strong>，理由见下图：</p><div align="center"><img src="/img/blog/ds-note-images/image-20211117002237934.png"></div></li></ul></li><li><p>$3$ 级协议：</p><ul><li><p>所有写操作同 $1$ 级协议，读操作要加<strong>共享锁</strong>，直到提交事务才释放。</p><div align="center"><img src="/img/blog/ds-note-images/image-20211117002930381.png"></div></li><li><p><strong>防止丢失修改，不可重复读，脏读</strong>。</p><blockquote><p>不可重复读现象不会发生，因为不会出现上图的共享锁释放后还可以被别人修改，且我再读的现象。</p></blockquote></li></ul></li></ul></li><li><p>封锁粒度：</p><ul><li><p>定义：</p><p>​    封锁粒度是指封锁数据对象的大小。</p></li><li><p>粒度单位：</p><p>​    属性值 $&lt;$ 元组 $&lt;$ 元组集合 $&lt;$ 整个关系 $&lt;$ 整个 DB</p></li><li><p>由前往后：</p><p>​    <strong>并发度小，封锁开销小</strong>。</p></li></ul></li><li><p>两段封锁协议：</p><ul><li><p>每个事务分两个阶段提出加锁和解锁申请。</p><ol><li><p>增长阶段：</p><p>​    事务可以获得锁，但不能释放锁。</p></li><li><p>缩减阶段：</p><p>​    事务可以释放锁，但不能获得新锁。</p></li></ol><blockquote><p>等价于 PPT 中的加锁段中不能有解锁操作，解锁段中不能有加锁操作。</p><p>每个事务中所有<strong>封锁</strong>请求<strong>先于</strong>任何一个<strong>解锁</strong>请求。</p><div align="center"><img src="/img/blog/ds-note-images/image-20211117100646462.png"></div></blockquote></li><li><p>可以保证<strong>冲突可串行性</strong>的，但是可能产生<strong>死锁</strong>。</p></li></ul></li></ul><h3 id="基于时间戳的并发控制方法🗡"><a href="#基于时间戳的并发控制方法🗡" class="headerlink" title="基于时间戳的并发控制方法🗡"></a>基于时间戳的并发控制方法🗡</h3><ul><li><p>不用锁实现并发控制。</p></li><li><p>时间戳定义：</p><p>​    <strong>时间戳</strong>是一种基于时间的标志，将某一时刻转换成的一个数值，具有<strong>唯一性和递增性</strong>。</p></li><li><p>基本思想：</p><ul><li><p>事务 $T$ 启动时，系统将该时刻作为 $T$ 的时间戳。</p></li><li><p>时间戳可以表征一系列事务执行的<strong>先后</strong>次序，时间戳小的事务先执行，时间戳大的事务后执行（但是实际上是交叉执行的）。</p></li><li><p>强制事务调度<strong>等价</strong>于一个特定顺序（即时间戳升序）的<strong>串行</strong>调度。</p></li><li><p>对于每个动作都要判断是否存在时间戳上的冲突（保证时间戳小的先操作，大的后操作）：</p><ul><li><p>如无冲突，予以执行；</p></li><li><p>如有冲突，则撤销这个动作对应的事务，并重启该事务，此时该事务获得了一个<strong>更大</strong>的时间戳，对应的动作位置会发生改变，重新做冲突判断。</p><blockquote><p>回滚 = 撤销 + 重启</p></blockquote></li></ul></li><li><p>冲突类型：</p><ol><li>时间戳大的先写（读），时间戳小的后读（写）</li><li>时间戳大的先写，时间戳小的后写</li></ol></li></ul></li><li><p>简单调度：</p><ul><li><p>对 DB 中的每个数据元素 $x$，系统保留其上的最大时间戳：</p><ul><li><p>$RT(x)$：</p><pre><code class="hljs">**读**过 $x$ 的事务中**最大的时间戳**。</code></pre></li><li><p>$WT(x)$：</p><p>​    <strong>写</strong>过 $x$ 的事务中最大的时间戳。</p></li></ul></li><li><p>事务的时间戳 $TS(T)$</p></li><li><p>读 - 写并发（对应解决冲突类型 $1$）：</p><ul><li><p>若 $T$ 事务读 $x$，则比较 $TS(T)$ 与 $WT(x)$：</p><ul><li>若 $TS(T) \ge WT(x)$（$T$ 后进行），则允许 $T$ 操作，更改 $RT(x)$ 为 $\max\{RT(x),TS(T)\}$</li><li>否则有冲突，$T$ 回滚。</li></ul></li><li><p>若 $T$ 事务写 $x$，则比较 $TS(T)$ 与 $RT(x)$，其实同时要考虑「写 - 写」并发：</p><ul><li><p>若 $TS(T) \ge RT(x)$（$T$ 后进行），则允许 $T$ 操作，更改 $WT(x)$ 为 $TS(T)$</p><blockquote><p>这里与 PPT 不同，笔者认为 $TS(T)$ 不会比 $WT(x)$ 小（即前者一定更大），否则会发生写 - 写冲突。</p></blockquote></li><li><p>否则有冲突，$T$ 回滚。</p></li></ul></li></ul></li><li><p>写 - 写并发（对应解决冲突类型 $2$）：</p><ul><li>若 $T$ 事务写 $x$，则比较 $TS(T)$ 与 $WT(x)$：</li><li>若 $TS(T) \ge WT(x)$，则允许 $T$ 写，并且更改 $WT(x)$ 为 $TS(T)$ ；</li><li>否则有冲突，$T$ 回滚（或者采用所谓的<strong>托马斯写</strong>规则，直接<strong>忽略</strong>这个写而不是回滚整个事务，反正它已经被时间戳大的写覆盖了）。</li></ul></li><li><p>以上简单调度会产生两种不一致错误（即时间戳并没有对这两种错误加以限制，只是消除了<strong>不可重复读</strong>错误）：</p><ul><li><p>脏读：</p><div align="center"><img src="/img/blog/ds-note-images/image-20211117151647520.png"></div><p>​    事务 $T$ 读取了事务 $U$ 没提交的数据，在 $U$ 回滚后就变成了脏数据。</p></li><li><p>类似丢失修改的错误：</p><div align="center"><img src="/img/blog/ds-note-images/image-20211117152026245.png"></div><p>$T$ 的写在<strong>托马斯写</strong>规则下，会被忽略，但是 $U$ 终止了，导致谁都没用写成 $x$。这种情况下理应<strong>保留 $T$ 的写</strong>。</p></li></ul></li></ul></li><li><p>优化后的时间戳调度：</p><ul><li><p>$WT(x),RT(x),TS(T)$ 与简单调度定义相同。</p></li><li><p>增加<strong>提交位</strong> $C(x)$：</p><ul><li>$C(x)=1$ 表明最近写 $x$ 的事务（时间戳较大）已经<strong>提交</strong>，就不会发生<strong>回滚</strong>现象。</li><li>$C(x)$ 的意义：将一些可能导致脏读和丢失修改的操作，<strong>延迟</strong>到确定提交（或回滚）后再处理。</li></ul></li><li><p>对来自事务 $T$ 的读写请求，调度器可以：</p><ul><li>同意请求</li><li>回滚</li><li><strong>推迟</strong>，并在以后决定是回滚还是要重新判断（简单调度无此项选择）</li></ul></li><li><p>若 $T$ 事务读 $x$，则比较 $TS(T)$ 与 $WT(x)$：</p><ul><li><p>若 $TS(T) \ge WT(x)$（$T$ 后进行），理论上应该允许 $T$ 操作，但要判断最近的写是否提交：</p><ul><li><p>$C(x)=1$，说明已提交，不会回滚，同意请求，可以放心的读，不会是脏数据。更改 $RT(x)$ 为 $\max\{RT(x),TS(T)\}$</p></li><li><p>推迟 $T$ 直到 $C(x)=1$ 或写 $x$ 的事务终止</p><blockquote><p>前一种情况仍可以放心读，后一种情况就不能读了，需要回滚。</p></blockquote></li></ul></li><li><p>否则有冲突，$T$ 回滚。</p></li></ul></li><li><p>若 $T$ 事务写 $x$，则比较 $TS(T),RT(x),WT(x)$，即同时要考虑「写 - 读」和 「写 - 写」并发：</p><ul><li><p>若 $TS(T) \ge RT(x)$ 且 $TS(T) \ge WT(x)$，则允许 $T$ 操作，更改 $WT(x)$ 为 $TS(T)$。</p></li><li><p>如果 $TS(T)\ge RT(x)$，但是 $TS(T)&lt;WT(x)$，就要判断是否已提交</p><ul><li><p>$C(x)=1$，那么前一个 $x$ 的写已提交，则忽略 $T$ 的写（托马斯写规则）。</p></li><li><p>否则推迟 $T$ 直到 $C(x)=1$ 或写 $x$ 的事务终止。</p><blockquote><p>如果是前一种情况就会忽略 $T$ 的写。后一种情况比较复杂，我觉得不能简单地通过 $T$ 的写请求：</p><ul><li>假设现在有事务 $S_1,S_2,T$，时间戳排序为 $T&lt;S_1&lt;S_2$，写 $x$ 的顺序为 $S_1,S_2,T$。此时 $WT(x)=TS(S_2)$，且 $S_1$ 已提交，$S_2$ 未提交。</li><li>$T$ 的写请求会进入推迟判断，即使最后 $S_2$ 回滚了，但是由于 $S_1$ 的写已经提交，也应该忽略 $T$ 的写。</li><li>PPT 对这种情况没有处理办法（如何感知 $S_1$ 的存在），所以这只是笔者的一种疑惑。</li></ul></blockquote></li></ul></li><li><p>否则有冲突，$T$ 回滚。</p></li></ul></li><li><p>假设调度器收到提交 $T$ 的请求：</p><ul><li>它必须找到 $T$ 所写的所有数据库元素 $x$, 并置 $C(x)=1$。</li><li>等待 $x$ 被提交的读动作可以继续读，写动作要被忽略。</li></ul></li><li><p>假设调度器收到终止 $T$ 的请求：</p><p>​    任何等待 $T$ 所写元素 $x$ 的事务判断这一动作在 $T$ 的写被终止后是否合法。</p><blockquote><p>具体怎么判断就像上面说的一样还缺少一些信息作为判断依据。</p></blockquote></li></ul></li></ul><h3 id="基于有效性确认的并发控制方法"><a href="#基于有效性确认的并发控制方法" class="headerlink" title="基于有效性确认的并发控制方法"></a>基于有效性确认的并发控制方法</h3><ul><li><p>基本思想：</p><ul><li><p>事务在启动时刻被赋予唯一的时间戳，以示其启动顺序。</p></li><li><p>RS(T)：</p><p>​    事务 T 读数据的集合。</p></li><li><p>WS(T)：</p><p>​    事务 T 写数据的集合。</p></li><li><p>事务分三个阶段进行：</p><ul><li><p>读阶段：</p><p>​    事务从数据库中读取读集合中的<strong>所有元素</strong>，在其局部地址空间<strong>计算</strong>它将要<strong>写</strong>的所有值。</p></li><li><p>有效性确认阶段：</p><p>​    调度器通过比较该事务与<strong>其它事务的读写集合</strong>来确认该事务的有效性。</p></li><li><p>写阶段：</p><p>​    通过有效性确认后，该事务立刻往数据库中写入其写集合中元素的值（这个过程要判断「读 - 写」和「写 - 写」冲突）。</p></li></ul></li><li><p>并发事务串行的顺序即事务有效性确认的顺序。</p></li></ul></li><li><p>集合定义：</p><ul><li>START 集合：<ul><li>已经开始但<strong>尚未完成有效性确认</strong>的事务集合。</li><li>对此集合中的事务，调度器维护 START(T)，即 T 开始的时间。</li></ul></li><li>VAL 集合：<ul><li>已经<strong>确认有效性</strong>但<strong>尚未完成写阶段</strong>写的事务。</li><li>对此集合中的事务，调度器维护 START(T) 和 VAL(T)，即 T 确认的时间。</li></ul></li><li>FIN 集合：<ul><li>已经<strong>完成写阶段</strong>的事务。</li><li>对此集合中的事务，调度器记录 START(T)，VAL(T) 和 FIN(T)，即 T 完成的时间。</li></ul></li></ul></li><li><p>有效性确认规则</p><ul><li><p>读 - 写并发：</p><p>​    对于所有<strong>已经过有效性确认</strong>，且在 T 开始前<strong>没有完成</strong>的 U，即对于满足 FIN(U)&gt;START(T) 的 U，检测 RS(T) $\cap$ WS(U) 是否为空：</p><ul><li>若为空，则确认 T。</li><li>否则，不予确认 T。</li></ul></li><li><p>写 - 写并发：</p><p>​    对于所有已经过有效性确认，且在 T 有效性确认前没有完成的 U，即对于满足 FIN(U)&gt;VAL(T) 的 U，检测 WS(T) $\cap$ WS(U) 是否为空：</p><ul><li>若为空，则确认 T。</li><li>否则，不予确认 T。</li></ul></li></ul></li><li><p>例子：</p><div align="center"><img src="/img/blog/ds-note-images/image-20211117183843703.png"></div></li></ul><h2 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h2><h3 id="故障恢复的宏观思路"><a href="#故障恢复的宏观思路" class="headerlink" title="故障恢复的宏观思路"></a>故障恢复的宏观思路</h3><ul><li><p>故障类型：</p><ul><li><p>事务故障：</p><p>​    某一个程序（事务）自身运行错误所引起的故障，影响该程序（事务）本身，只需要撤销事务和重做事务来进行恢复。</p></li><li><p>系统故障：</p><p>​    由于掉电、非正常关机等所引起的故障。影响<strong>正在运行的事务</strong>以及数据库<strong>缓冲区</strong>（数据库缓冲区涉及正在运行和已经运行的事务）。</p></li><li><p>介质故障：</p><p>​    由于介质（数据库）损坏等所引起的故障。影响是全面的，既影响内存中的数据, 又影响介质中存储的数据。</p></li></ul></li><li><p>故障会破坏事务的原子性，一致性和持久性。</p><blockquote><p>隔离性因为故障发生后不能执行事务，事务肯定是越少越不容易破坏隔离性。</p></blockquote></li><li><p>故障恢复意义：</p><p>​    把 DB 由<strong>当前不正确状态</strong>恢复到<strong>已知正确</strong>的某一状态。</p></li><li><p>需要保证事务的：</p><ul><li><p>原子性：</p><p>​    事务的所有操作，要么全都执行，要么全都不执行。</p></li><li><p>持久性：</p><p>​    已提交的事务对数据库产生的影响是持久的（缓冲区内容保证写回磁盘），未提交的事务对数据库不应有影响（缓冲区内容不能影响磁盘）。</p></li></ul></li><li><p>运行日志：</p><ul><li><p>运行日志是 DBMS 维护的一个文件，该文件以流水方式记录了每一个事务对数据库的每一次操作及操作顺序。</p><blockquote><p>MOOC 上题目说「日志文件是用于记录对数据的所有更新操作」。</p></blockquote></li><li><p>运行日志直接写入介质存储上，会保持正确性。</p></li><li><p>当事务对数据库进行操作时，<strong>先写运行日志</strong>。写成功后，再与数据库缓冲区进行信息交换。</p><div align="center"><img src="/img/blog/ds-note-images/image-20211117190515585.png"></div></li><li><p>保存信息：</p><ul><li>&lt; Start T &gt;，表示事务 T 已经开始</li><li>&lt; Commit T &gt;，表示事务 T 成功完成</li><li>&lt; Abort T &gt;，事务 T 未成功，被中止</li><li>&lt; T, X, $v_1$ &gt; 或者 &lt; T, X, $v_2$ &gt; 或者 &lt; T, X, $v_1$, $v_2$ &gt;（对应 Undo 型日志，Redo 型日志，Undo/Redo 型日志）</li><li>表示事务 T 改变了数据库元素 X，X 原来的值为 $v_1$（X 的旧值），X 新的值为 $v_2$。</li></ul></li></ul></li><li><p>事务故障的恢复：</p><ul><li><p>事务故障可通过重做事务（Redo）和撤消事务（Undo）来恢复。</p></li><li><p>重做事务可保证<strong>已提交事务的持久性</strong>，而撤销事务则消除<strong>未提交事务</strong>的影响。</p><blockquote><p>已提交事务的写数据，可能只是放在缓冲区中，还没有写入磁盘，当发生故障时将丢失修改。所以必须通过 Redo 重新把修改写磁盘。</p></blockquote></li><li><p>DBMS 在运行日志中定期设置及更新<strong>检查点</strong>（checkpoint）：</p><ul><li>在检查点时，DBMS 强制使 DB 缓冲区中的内容与 DB 中的内容保持一致，即将 DB 缓冲区更新的所有内容写回 DB 中。</li><li>保证在检查点之前内存中数据与 DB 中数据是<strong>保持一致</strong>的，即检查点<strong>之前结束</strong>的事务不需要恢复（已经写回 DB）。</li><li>检查点之后<strong>结束或发生</strong>的事务需要依据<strong>运行日志</strong>进行恢复（不能确定是否写回 DB）：<strong>故障点前结束的重做，故障点时刻未结束的撤消</strong>。</li></ul><div align="center"><img src="/img/blog/ds-note-images/image-20211117200855482.png"></div></li><li><p>通过副本实现<strong>介质故障</strong>恢复：</p><ul><li>在某一时刻（转储点），对数据库在其他介质存储上产生的另一份等同记录，即副本。</li><li>当 DB 发生故障时用副本替换，且由于介质故障影响很大，替换后还需要依据<strong>运行日志</strong>进行恢复。</li><li>转储点的设置：<ul><li>过频会影响系统工作效率。</li><li>过疏会造成运行日志过大，也影响系统运行性能（转储点前的日志不需要保存）。</li><li>备份转储周期与运行日志的大小密切相关，合理设置。</li></ul></li></ul></li></ul></li></ul><h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><ul><li><p>事务和缓冲区的操作：</p><ul><li><p>READ(X,t)：</p><p>​    将元素 X 读到事务的<strong>局部变量</strong> t 中。</p></li><li><p>WRITE(X,t)：</p><p>​    将事务局部变量 t 写回元素 X。</p></li><li><p>INPUT(X)：</p><p>​    将元素 X 从磁盘读入到内存缓冲区中。</p></li><li><p>OUTPUT(X)：</p><p>​    将元素 X 从缓冲区写<strong>回到磁盘</strong>中。</p></li><li><p>COMMIT：</p><p>​    事务提交。</p></li><li><p>ABORT：</p><p>​    事务撤销。</p></li></ul></li><li><p><strong>缓冲区策略</strong>🤏🗡：</p><ul><li><p>Force：</p><p>​    缓冲区中的数据最晚在 commit 的时候写入磁盘。</p></li><li><p>No Force：</p><p>​    缓冲区中的数据可以一直保留，在 commit 之后过一段时间再写入磁盘。</p><blockquote><p>如果在系统崩溃的时候还没写入到磁盘，需要 Redo。</p></blockquote></li><li><p>Steal：</p><p>​    允许在事务 commit 之前把缓冲区中的数据写入磁盘（先偷偷写一点）。</p><blockquote><p>此时若系统在 commit 之前崩溃时，已经有数据写入到磁盘了，要恢复到崩溃前的状态，需要 Undo。</p></blockquote></li><li><p>No Steal：</p><p>​    不允许在事务 commit 之前把缓冲区中的数据写入磁盘。</p><blockquote><p>Steal/No Steal 关心的缓冲区的数据最早什么时候开始写磁盘。</p><p>Force/No Force 关心的缓冲区的数据最晚什么时候要写回磁盘。</p></blockquote></li><li><p>各种搭配的效率和策略比较：</p><p>​    最灵活且常用 Steal + No Force</p><div align="center"><img src="/img/blog/ds-note-images/image-20211117201057674.png"></div></li></ul></li></ul><h3 id="三种日志类型"><a href="#三种日志类型" class="headerlink" title="三种日志类型"></a>三种日志类型</h3><blockquote><p>这一节老师讲的很快，很多地方存在疑惑（为什么要执行到哪个地方，检查点实际的作用）都不太清楚，只能盲目搬运 PPT 了😫。</p></blockquote><ul><li><p>判断确定每一个事务是否已完成：</p><ul><li><p>已完成（Redo 关注的）：</p><p>​    &lt; START T &gt;$\cdots$&lt; COMMIT T &gt;</p></li><li><p>未完成（Undo 关注的）：</p><ul><li>&lt; START T &gt;$\cdots$&lt; ABORT T &gt;  </li><li>&lt; START T &gt;$\cdots$              </li></ul></li></ul></li><li><p>检查点类型：</p><ul><li>静止检查点：<ul><li>周期性地对日志设置检查点。</li><li><strong>停止接受</strong>新的事务，等到所有当前活跃事务提交或终止，并在日志中写入了 COMMIT 或 ABORT 记录。</li><li>最后将日志刷新到磁盘，写入日志记录 &lt; CKPT &gt;，并再次刷新日志。</li></ul></li><li>非静止检查点：<ul><li>在设置检查点时不必关闭系统，<strong>允许新事务</strong>进入。</li><li>写入一条 &lt; START CKPT($T_1,\cdots,T_k$) &gt;，其中 $T_1,\cdots,T_k$ 是所有<strong>活跃的未结束</strong>的事务。</li><li>继续正常的操作，直到 $T_1,\cdots,T_k$ 都完成时，写入 &lt; END CKPT &gt;。</li></ul></li></ul></li><li><p>Undo 型日志：</p><ul><li><p>对应 Steal + Force 策略</p></li><li><p>对于任一事务 T，按下列顺序向磁盘输出 T 的日志信息：</p><ul><li><p>首先，&lt; T, X, $v$ &gt; 被写到日志中，$v$ 为 X 的旧值。</p></li><li><p>其次，OUTPUT(X)</p></li><li><p>最后，&lt; COMMIT T &gt; 或 &lt; ABORT T &gt;被写到日志中</p><blockquote><p>将事务改变的<strong>所有数据写到磁盘前</strong>不能<strong>提交</strong>该事务。    </p></blockquote></li></ul></li><li><p>🗡从日志的尾部开始按日志记录的反序，处理每一日志记录，撤销<strong>未完成事务</strong>的所有修改，处理到检查点为止。</p></li><li><p>如果是在 &lt; COMMIT T &gt; 后发生故障，无需对 T 做任何处理，因为 T 已经完成它要做的所有动作了，满足原子性。</p></li><li><p>反之，T 所有动作带来的影响都要撤销掉，通过 &lt; T, X, $v$ &gt; 还原。</p></li><li><p>可能频繁地写磁盘，导致性能下降。</p></li></ul></li><li><p>Redo 型日志：</p><ul><li><p>对应 No Steal + No Force 策略</p></li><li><p>对于任一事务 T，按下列顺序向磁盘输出 T 的日志信息：</p><ul><li><p>首先，&lt; T, X, $v$ &gt; 被写到日志中，$v$ 为 X 的新值。</p></li><li><p>其次，&lt; COMMIT T &gt; 或 &lt; ABORT T &gt;被写到日志中</p></li><li><p>最后，OUTPUT(X)</p><blockquote><p>与 Undo 写入日志的顺序不一样。              </p></blockquote></li></ul></li><li><p>从日志的起始位置（检查点）开始按日志记录的正序处理每一日志记录，重做<strong>已提交事务</strong>的所有修改。</p><blockquote><p>在检查点处，要将之前所有已提交的事务写回磁盘（Undo 不用是因为它的 OUTPUT 在提交前做完）。</p></blockquote></li><li><p>如果是在 &lt; COMMIT T &gt; 前发生故障，无需对 T 做任何处理，因为 T 并没有将影响写入数据库（OUTPUT 还没执行）。</p></li><li><p>反之，通过 &lt; T, X, $v$ &gt; 更新数据库。</p></li><li><p>数据必须在 Commit 后才可见，灵活性差。</p></li></ul></li><li><p>Undo/Redo 型日志：</p><ul><li><p>对应 Steal + No Force 策略</p></li><li><p>对于任一事务 T，按下列顺序向磁盘输出 T 的日志信息：</p><ul><li><p>首先，&lt; T, X, $u$, $v$ &gt; 被写到日志中，$u$ 为 X 的旧值，$v$ 为 X 的新值。</p></li><li><p>（&lt; COMMIT T &gt; 或 &lt; ABORT T &gt;）或 OUTPUT(X) 被写到日志中</p></li><li><p>OUTPUT(X) 或（&lt; COMMIT T &gt; 或 &lt; ABORT T &gt;）被写到日志中</p><blockquote><p>无所谓 OUTPUT 和 COMMIT 谁先写，很灵活。</p></blockquote></li></ul></li><li><p>先<strong>自后向前</strong>地<strong>撤销</strong>所有<strong>未提交</strong>的事务，再<strong>自前向后</strong>地<strong>重做</strong>所有<strong>已提交</strong>的事务。</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hitsz</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统笔记</title>
    <link href="/Operating_System.html"/>
    <url>/Operating_System.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>这是 HITsz 操作系统笔记，<a href="https://github.com/ailanxier/Operating-System-Note">欢迎到我的 GitHub 上查看，有笔记说明和源码，作业和实验报告</a>，希望对你有帮助</p></blockquote><h2 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h2><blockquote><p>整理自《王道》</p></blockquote><h3 id="操作系统基本概念"><a href="#操作系统基本概念" class="headerlink" title="操作系统基本概念"></a>操作系统基本概念</h3><ul><li><p>操作系统定义：</p><p>​    操作系统是指控制和管理整个计算机系统的<strong>硬件与软件资源</strong>，合理地组织、调度计算机的<strong>工作与资源的分配</strong>，进而为用户和其他软件提供方便<strong>接口与环境</strong>的<strong>程序集合</strong>。操作系统是计算机系统中<strong>最基本的系统软件</strong>。</p></li><li><p>操作系统的<strong>基本特征</strong>：</p><ul><li><p>并发：</p><ul><li><strong>并发</strong>是指两个或多个事件<strong>在同一时间间隔内发生</strong>。</li><li>操作系统的并发性是指计算机系统中同时存在多个运行的程序，因此它具有处理和调度多个程序同时执行的能力。</li><li><strong>引入进程的目的是使程序能并发执行</strong>。</li></ul><blockquote><p>注意同一时间间隔（并发）和<strong>同一时刻</strong>（并行）的区别：</p><ul><li><p>并发：</p><ul><li>在多道程序环境下，一段时间内，<strong>宏观上</strong>有多道程序在同时执行。</li><li>而在每个时刻，单处理机环境下实际仅能有一道程序执行。</li><li>因此微观上这些程序仍是<strong>分时交替执行</strong>的。操作系统的并发性是通过<strong>分时</strong>得以实现的。</li></ul></li><li><p>并行：</p><ul><li>并行性是指系统具有同时进行运算或操作的特性，在同一时刻能完成两种或两种以上的工作。</li><li>并行性需要有相关硬件的支持，如多<strong>流水线或多处理机</strong>硬件环境。</li></ul></li></ul></blockquote></li><li><p>共享：</p><p>​    <strong>共享</strong>是指系统中的资源可供内存中多个<strong>并发</strong>执行的进程共同使用，分为两类：</p><ul><li><p>互斥共享方式：</p><p>​    仅当进程 A 访问完并释放该资源后，才允许另一个进程 B 对该资源进行访问。即在一段时间内只允许一个进程访问该资源，这种资源称为<strong>临界资源或独占资源</strong>。</p></li><li><p>同时访问方式：</p><p>​    <strong>宏观上</strong>在一段时间内允许多个进程「同时」访问某些资源，<strong>微观上</strong>「轮流」（交替）访问。同时访问的典型资源是<strong>磁盘设备</strong>。</p></li></ul><blockquote><p>操作系统<strong>最基本的特征</strong>是<strong>并发和共享</strong>，两者互为存在条件。</p></blockquote></li><li><p>虚拟：</p><p>​    <strong>虚拟</strong>是指把一个物理上的实体变为若干逻辑上的对应物，有以下应用：</p><ul><li><p><strong>时分复用</strong>技术：</p><p>​    虚拟处理器技术是通过多道程序设计技术，采用让多道程序<strong>并发</strong>执行的方法，来分时使用一个处理器的。</p></li><li><p><strong>空分复用</strong>技术：</p><p>​    虚拟存储器技术将一台机器的物理存储器变为虚拟存储器，以便从逻辑上扩充存储器的容量。</p></li></ul></li><li><p>异步：</p><p>​    多道程序环境允许多个程序<strong>并发</strong>执行，但由于资源有限（资源竞争），进程的执行以<strong>不可预知</strong>的速度向前推进，这就是<strong>进程的异步性</strong>。</p></li></ul></li><li><p>操作系统作为<strong>计算机系统资源</strong>的管理者的功能：</p><ul><li>处理机管理：<ul><li>在多道程序环境下，<strong>处理机的分配和运行都以进程（或线程）为基本单位</strong>，因而对处理机的管理可归结为对进程的管理。</li><li>并发是指在计算机内同时运行多个进程，因此<strong>进程何时创建、何时撤销、如何管理、如何避免冲突、合理共享</strong>就是进程管理的最主要的任务。</li><li>进程管理的主要功能包括<strong>进程控制、进程同步、进程通信、死锁处理、处理机调度</strong>等。</li></ul></li><li>存储器管理：<ul><li>存储器管理是为了给多道程序的运行提供良好的环境，方便用户使用及提高内存的利用率。</li><li>主要包括<strong>内存分配与回收、地址映射、内存保护与共享和内存扩充</strong>等功能。</li></ul></li><li>文件管理：<ul><li>计算机中的信息都是以文件的形式存在的，操作系统中负责文件管理的部分称为文件系统。</li><li>文件管理包括<strong>文件存储空间的管理、目录管理及文件读写管理和保护</strong>等，但不关心文件具体内容，如：源代码、编译器。</li></ul></li><li>设备管理：<ul><li>设备管理的主要任务是完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。</li><li>主要包括<strong>缓冲管理、设备分配、设备处理和虚拟设备</strong>等功能。</li></ul></li></ul></li><li><p>操作系统作为用户与计算机硬件系统之间的<strong>接口</strong>（了解）：</p><ul><li><p>命令接口：</p><p>​    用户利用这些操作命令来组织和控制作业的执行，分为两类：</p><ul><li><p>联机命令接口：</p><p>​    「雇主」说一句话，「工人」做一件事，并做出反馈，这就强调了交互性。</p></li><li><p>脱机命令接口：</p><p>​    「雇主」把要「工人」做 的事写在清单上，「工人」按照清单命令逐条完成这些事。用户不能直接干预作业的运行。</p></li></ul></li><li><p>程序接口：</p><p>​    程序接口由一组<strong>系统调用（也称广义指令）</strong>组成。用户通过在程序中使用这些<strong>系统调用</strong>来请求操作系统为其提供服务，如使用各种外部设备、申请分配和回收内存及其他各种要求。</p><blockquote><p>当前最为流行的是图形用户界面（GUI），即图形接口。GUI 最终是通过调用<strong>程序接口</strong>实现的，所调用的系统调用命令是操作系统的一部分。</p></blockquote></li></ul></li></ul><h3 id="操作系统的发展与分类（理解）"><a href="#操作系统的发展与分类（理解）" class="headerlink" title="操作系统的发展与分类（理解）"></a>操作系统的发展与分类（理解）</h3><ol><li><p>手工操作阶段（此阶段无操作系统）：</p><ul><li><p>用户在计算机上算题的所有工作都要人工干预，如程序的装入、运行、结果的输出等。</p></li><li><p>随着计算机硬件的发展，人机矛盾（速度和资源利用）越来越大</p></li></ul></li></ol><ol><li><p>批处理阶段（操作系统开始出现）：</p><blockquote><p>批处理系统是实现作业自动控制而<strong>无须人工干预</strong>的系统。</p></blockquote><ul><li><p><strong>单道批处理</strong>系统：</p><ul><li><p>系统对作业的处理是成批进行的，但内存中始终保持一道作业。</p></li><li><p>目的是为了解决人机矛盾及 CPU 和 I/O 设备速率不匹配的矛盾</p></li><li><p>主要特征：</p><ul><li><p>自动性：</p><p>​    在顺利的情况下，磁带上的一批作业能自动地逐个运行，而<strong>无须人工干预</strong>。</p></li><li><p>顺序性：</p><p>​    磁带上的各道作业<strong>顺序</strong>地进入内存，各道作业的完成顺序与它们进入内存的顺序在正常情况下应完全相同。</p></li><li><p>单道性：</p><p>​    内存中仅有<strong>一道</strong>程序运行，即监督程序每次从磁带上只调入一道程序进入内存。</p></li></ul></li></ul></li><li><p><strong>多道批处理</strong>系统：</p><ul><li><p>多道程序设计技术允许多个程序同时进入内存并允许它们在 CPU 中交替地运行，这些程序共享系统中的各种硬/软件资源。</p></li><li><p>多道程序设计的特点：</p><ul><li><p>多道：</p><p>​    计算机内存中同时存放多道相互独立的程序。</p></li><li><p>宏观上并行：</p><p>​    同时进入系统的多道程序都处于运行过程中，即它们先后开始各自的运行，但都未运行完毕。</p></li><li><p>微观上串行：</p><p>​    内存中的多道程序轮流占有 CPU，<strong>交替执行</strong>。</p></li></ul></li></ul><blockquote><p>优点：</p><ul><li><strong>资源利用率高</strong>，多道程序共享计算机资源，从而使各种资源得到充分利用。</li><li><p>系统<strong>吞吐量大</strong>，CPU 和其他资源保持「忙碌」状态。</p></li><li><p>缺点：</p><ul><li>用户响应的时间较长。</li><li>不提供人机交互能力，用户既不能了解自己的程序的运行情况，又不能控制计算机。</li></ul></li></ul></blockquote></li></ul></li><li><p><strong>分时</strong>操作系统：</p><ul><li><p>分时技术指把处理器的运行时间分成<strong>很短的时间片</strong>，按时间片轮流把 CPU 分配给各联机作业使用。</p></li><li><p>若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时停止运行，把处理器让给其他作业使用，等待下一轮再继续运行。</p></li><li><p>由于计算机速度很快，作业运行轮转得也很快，因此给每个用户的感觉就像是自己<strong>独占</strong>一台计算机。</p></li><li><p>多道批处理是实现作业自动控制而无须人工干预的系统，而分时系统是实现<strong>人机交互</strong>的系统。</p></li><li><p>分时系统的主要特征如下： </p><ul><li><p><strong>同时性（多路性）</strong>：</p><p>​    指允许多个终端用户同时使用一台计算机，即一台计算机与若干台终端相连接，终端上的这些用户可以同时或基本同时使用计算机。</p></li><li><p><strong>交互性</strong>：</p><p>​    用户能够方便地与系统进行人机对话，即用户通过终端采用人机对话的方式直接控制程序运行，与同程序进行交互。</p></li><li><p><strong>独立性</strong>：</p><p>​    系统中多个用户可以彼此独立地进行操作，<strong>互不干扰</strong>，单个用户感觉不到别人 也在使用这台计算机，好像只有自己单独使用这台计算机一样。</p></li><li><p><strong>及时性</strong>：</p><p>​    用户请求能在很短时间内获得响应。分时系统采用时间片轮转方式使一台计算机同时为多个终端服务，使用户能够对系统的及时响应感到满意。</p></li></ul></li></ul></li><li><p>实时操作系统：</p><ul><li><p>为了能在某个时间限制内完成某些紧急任务而<strong>不需要时间片排队</strong>，诞生了实时操作系统。</p></li><li><p>这里的时间限制可以分为两种情况：</p><ul><li>若某个动作必须<strong>绝对地在规定的时刻</strong>（或规定的时间范围）发生，则称为<strong>硬实时</strong>系统，如飞行器的飞行自动<strong>控制</strong>系统，这类系统必须提供绝对保证，让某个特定的动作在规定的时间内完成。</li><li>若能够接受<strong>偶尔</strong>违反时间规定且不会引起任何永久性的损害，则称为<strong>软实时</strong>系统，如<strong>飞机订票系统</strong>、银行管理系统。</li></ul></li><li><p>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并在严格的时限内处理完接收的事件。</p><blockquote><p>实时系统必须能足够及时地处理某些紧急的外部事件，因此普遍用高优先级，并用「可抢占」来确保实时处理。</p></blockquote></li><li><p>实时操作系统的主要特点是<strong>及时性和可靠性</strong>，允许以「浪费」一些资源为代价。</p></li></ul></li><li><p>网络操作系统和分布式计算机系统</p></li><li><p>个人计算机操作系统</p></li></ol><h3 id="操作系统运行环境"><a href="#操作系统运行环境" class="headerlink" title="操作系统运行环境"></a>操作系统运行环境</h3><h4 id="内核态和用户态"><a href="#内核态和用户态" class="headerlink" title="内核态和用户态"></a>内核态和用户态</h4><ul><li><p>计算机系统中，通常 CPU 执行两种不同性质的程序：</p><ul><li>操作系统<strong>内核程序</strong></li><li>用户自编程序（ 简称「<strong>应用程序</strong>」）</li><li>前者是后者的管理者</li></ul></li><li><p>因此「管理程序」（即内核程序）可以执行一些<strong>特权指令</strong>，而「被管理程序」（即用户自编程序）出于安全考虑不能执行这些指令。</p></li><li><p>特权指令是指计算机中不允许用户直接使用的指令，如 <strong>I/O 指令，置中断指令，存取用于内存保护的寄存器，送程序状态字到程序状态字寄存器</strong>等的指令。</p></li><li><p>在具体实现上，将 CPU 的状态划分为<strong>用户态（目态）和核心态（又称管态、内核态）</strong>。</p></li><li><p>操作系统的内核构成：</p><ul><li>与<strong>硬件</strong>关联较紧密的模块，如<strong>时钟管理、中断处理、设备驱动</strong>等处于最低层</li><li>与<strong>运行频率</strong>较高的程序，如<strong>进程管理、存储器管理和设备管理</strong>。</li><li>这两部分内容的指令操作工作在<strong>核心态</strong>。</li></ul><blockquote><p>注意选择题中「执行」和「发生」的区别。</p><div align="center"><img src=" /img/blog/os-note-images/image-20211210220654769.png" alt="image-20211210220654769" style="zoom:100%;"></div><div align="center"><img src=" /img/blog/os-note-images/image-20211210224855348.png"></div></blockquote></li><li><p>操作系统的内核的内容：</p><ul><li><p><strong>时钟管理</strong>：</p><ul><li>在计算机的各种部件中，时钟是最关键的设备。</li><li>时钟的第一功能是计时。</li><li>第二功能是通过时钟中断的管理，可以实现<strong>进程的切换</strong>。</li></ul><blockquote><p>例如：</p><ul><li>在分时操作系统中采用时间片轮转调度，在实时系统中按截止时间控制运行。</li></ul><ul><li><p>在批处理系统中通过时钟管理来衡量一个作业的运行程度。</p><div align="center"><img src=" /img/blog/os-note-images/image-20211210232945020.png"></div></li></ul></blockquote></li><li><p><strong>中断机制</strong>：</p><ul><li>引入中断技术的初衷是<strong>提高多道程序运行环境中 CPU 的利用率</strong>，而且主要是针对外部设备的。</li><li>后来逐步成为操作系统各项操作的基础。例如，键盘或鼠标信息的输入、进程的管理和调度、系统功能的调用、设备驱动、文件访问等。</li><li>可以说，现代操作系统是靠中断驱动的软件。</li><li>中断机制中，只有一小部分功能属于<strong>内核</strong>，它们<strong>负责保护和恢复中断现场的信息</strong>，转移控制权到相关的处理程序。</li><li>这样可以减少中断的处理时间，提高系统的并行处理能力。</li></ul></li><li><p><strong>原语</strong>：</p><ul><li><p>原语定义：</p><p>​    按层次结构设计的操作系统，底层是一些可被调用的公用小程序，它们各自完成一个规定的操作，特点如下：</p><ul><li>处于操作系统的<strong>最低层</strong>，是最接近硬件的部分。</li><li>这些程序的运行具有<strong>原子性</strong>，其操作只能一气呵成（主要从系统安全性和便于管理考虑）。</li><li>这些程序的运行时间都较短，而且调用频繁。</li></ul><p>通常把具有这些特点的<strong>程序</strong>称为<strong>原语（Atomic Operation）</strong>。</p><blockquote><p>定义原语的直接方法是<strong>关闭中断</strong>，让其所有动作不可分割地完成后再<strong>打开中断</strong>。</p><p>系统中的<strong>设备驱动、CPU 切换、进程通信</strong>等功能中的部分操作都可定义为原语，使它们成为内核的组成部分。</p></blockquote></li></ul></li><li><p><strong>系统控制的数据结构及处理</strong>：</p><p>​    系统中用来登记状态信息的数据结构很多，如<strong>作业控制块、进程控制块（PCB）、设备控制块、各类链表、消息队列、缓冲区、空闲区登记表、内存分配表</strong>等。为了实现有效的管理，系统需要一些基本的操作，常见的操作有以下 3 种：</p><ul><li><p><strong>进程</strong>管理：</p><p>​    进程状态管理、进程调度和分派、创建与撤销进程控制块等。</p></li><li><p><strong>存储器</strong>管理：</p><p>​    存储器的空间分配和回收、内存信息保护程序、代码对换程序等。</p></li><li><p><strong>设备</strong>管理：</p><p>​    缓冲区管理、设备分配和回收等。</p></li></ul></li></ul><blockquote><p>核心态指令实际上包括<strong>系统调用类指令和一些针对时钟、中断和原语</strong>的操作指令。</p></blockquote></li></ul><h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><ul><li><p>中断（外中断）和异常（内中断）概念：</p><ul><li><p>系统不允许用户程序实现核心态的功能，而它们又必须使用这些功能，就得通过中断或异常实现。</p></li><li><p>中断（Interruption）也称<strong>外中断</strong>，指来自 CPU <strong>执行指令以外</strong>的事件的发生，如<strong>外设请求或人为干预</strong>。</p></li><li><p>异常（Exception）也称<strong>内中断</strong>、例外或陷入（trap），指源自 CPU <strong>执行指令内部</strong>的事件，如程序的非法操作码<strong>地址越界、算术溢出、虚存系统的缺页及专门的陷入指令</strong>等引起的事件。</p></li></ul><blockquote><p>对异常的处理一般要依赖于当前程序的运行现场，而且<strong>异常不能被屏蔽</strong>，一旦出现应立即处理。</p><p>所谓「缺页中断」属于<strong>异常</strong>，在考研题中，认为『「访存时缺页」属于中断』这句话是错误的。</p></blockquote></li><li><p>中断处理过程：</p><ul><li><p><strong>关中断</strong>：</p><ul><li>CPU 响应中断后，首先要保护程序的现场状态，在<strong>保护现场</strong>的过程中，CPU <strong>不应响应更高级中断源的中断请求</strong>。</li><li>若现场保存不完整，在中断服务程序结束后，也就不能正确地恢复并继续执行现行程序。</li></ul></li><li><p><strong>保存断点</strong>：</p><p>​    为保证中断服务程序执行完毕后能正确地返回到原来的程序，必须将原来的程序的断点（即<strong>程序计数器 PC</strong>）保存起来。</p></li><li><p><strong>中断服务程序寻址</strong>：</p><p>​    其实质是取出<strong>中断服务程序的入口地址</strong>送入程序计数器 PC。</p><blockquote><p>上面三步是在 CPU 进入中断周期后，由<strong>硬件自动（中断隐指令）</strong>完成的。</p><p>下面几步由中断服务程序完成。</p></blockquote></li><li><p><strong>保存现场和屏蔽字</strong>：</p><p>​    进入中断服务程序后，首先要保存现场，现场信息一般是指<strong>程序状态字寄存器 PSWR</strong> 和某些通用寄存器的内容。</p></li><li><p><strong>开中断</strong>：</p><p>​    允许<strong>更高级中断</strong>请求得到响应。</p></li><li><p>执行中断服务程序：</p><p>​    这是中断请求的目的。</p></li><li><p><strong>关中断</strong>：</p><p>​    保证在<strong>恢复现场和屏蔽字时不被中断</strong>。</p></li><li><p><strong>恢复现场和屏蔽字</strong>：</p><p>​    将现场和屏蔽字恢复到原来的状态。</p></li><li><p><strong>开中断、中断返回</strong>：</p><p>​    中断服务程序的<strong>最后一条指令通常是一条中断返回指令</strong>，使其返回到原程序的<strong>断点</strong>处，以便继续执行原程序。</p></li></ul><div align="center"><img src=" /img/blog/os-note-images/image-20210914134821154.png"></div><blockquote><p>​    易错点：</p><p>​        由<strong>硬件</strong>自动保存被中断程序的断点（即程序计数器 PC）。</p><div align="center"><img src=" /img/blog/os-note-images/image-20211210233357503.png"></div></blockquote></li></ul><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><ul><li><p>系统调用是指用户在程序中<strong>调用</strong>操作系统所提供的一些<strong>子功能</strong>，系统调用可视为特殊的公共子程序。</p></li><li><p>系统中的各种<strong>共享资源</strong>都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如<strong>存储分配、进行 I/O 传输及管理文件</strong>等），都必须通过系统调用方式向操作系统<strong>提出服务请求</strong>，并由操作系统<strong>代</strong>为完成。</p></li><li><p>这些系统调用按功能大致可分为如下几类。</p><ul><li><p>设备管理：</p><p>​    完成<strong>设备的请求或释放，以及设备启动</strong>等功能。</p></li><li><p>文件管理：</p><p>​    完成文件的<strong>读、写、创建及删除</strong>等功能。</p></li><li><p>进程控制：</p><p>​    完成进程的<strong>创建、撤销、阻塞及唤醒</strong>等功能。</p></li><li><p>进程通信：</p><p>​    完成<strong>进程之间的消息传递或信号传递</strong>等功能。</p></li><li><p>内存管理：</p><p>​    完成内存的<strong>分配、回收以及获取作业占用内存区大小及始址</strong>等功能。</p></li></ul></li></ul><blockquote><p>操作系统的<strong>运行环境</strong>就可以理解为：</p><ul><li>用户通过操作系统运行<strong>上层程序</strong>（如系统提供的命令解释程序或用户自编程序），而这个上层程序的运行依赖于操作系统的底层管理程序提供服务支持。</li><li>当需要管理程序服务时，系统则通过<strong>硬件中断机制进入核心态</strong>，运行管理程序</li><li>当程序运行出现<strong>异常</strong>情况时，也会被动地需要管理程序的服务，这时就通过<strong>异常处理</strong>来进入核心态（<strong>trap 指令在用户态执行</strong>）。管理程序运行结束时，用户程序需要继续运行，此时通过相应的保存的程序现场，退出中断处理程序或异常处理程序，返回断点处继续执行。</li></ul><p>一些由<strong>用户态</strong>转向<strong>核心态</strong>的例子：</p><ul><li>用户程序要求操作系统的服务，即<strong>系统调用</strong>。</li><li>发生一次<strong>中断</strong>。</li><li>用户程序中产生了一个错误状态。</li><li>用户程序中企图执行一条特权指令（需要<strong>访管中断</strong>，访管指令不是特权指令）。</li><li>从核心态转向用户态由一条指令实现，这条指令是<strong>特权命令</strong>，一般是中断返回指令。</li></ul><p>执行系统调用的<strong>过程</strong>如下：</p><ol><li>正在运行的进程先传递系统调用参数</li><li>在<strong>用户态</strong>执行<strong>陷入指令</strong>，将用户态转换为内核态，并将返回地址压入堆栈以备后用</li><li>CPU 执行相应的内核态服务程序</li><li>最后返回用户态</li></ol></blockquote><h3 id="大内核（宏内核）和微内核"><a href="#大内核（宏内核）和微内核" class="headerlink" title="大内核（宏内核）和微内核"></a>大内核（宏内核）和微内核</h3><ul><li><strong>大内核</strong>系统将操作系统的<strong>主要功能模块</strong>都作为一个紧密联系的整体运行在<strong>核心态</strong>，从而为应用提供<strong>高性能</strong>的系统服务。</li><li>因为各管理模块之间<strong>共享信息</strong>，能有效利用相互之间的有效特性，所以具有无可比拟的性能优势。</li><li>为解决操作系统的内核代码难以维护的问题，提出了<strong>微内核</strong>的体系结构。它将内核中<strong>最基本的功能（如进程管理等）保留在内核</strong>，而将那些不需要在核心态执行的功能移到<strong>用户态</strong>执行，从而降低了内核的<strong>设计复杂性</strong>。</li><li>那些移出内核的操作系统代码根据分层的原则被划分成若干服务程序，它们的执行相互独立，<strong>交互则都借助于微内核进行通信</strong>。</li><li>微内核结构有效地分离了内核与服务、服务与服务，使得它们之间的接口更加清晰，维护的代价大大降低，各部分可以独立地优化和演进，从而保证了操作系统的<strong>可靠性</strong>。</li><li>微内核结构的最大问题是<strong>性能问题</strong>，因为需要频繁地在核心态和用户态之间进行切换，操作系统的执行开销偏大。</li></ul><div align="center"><img src=" /img/blog/os-note-images/image-20210914200748917.png" alt="image-20210914200748917" style="zoom:100%;"></div><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程的概念和特征"><a href="#进程的概念和特征" class="headerlink" title="进程的概念和特征"></a>进程的概念和特征</h3><blockquote><p>来自《王道》</p></blockquote><ul><li><p>进程的概念：</p><ul><li><p>在多道程序环境下，允许多个<strong>程序</strong>并发执行，此时它们将<strong>失去封闭性，并具有间断性及不可再现性</strong>的特征。</p></li><li><p>为此引入了<strong>进程</strong>（Process）的概念，以便更好地描述和控制程序的并发执行，实现操作系统的<strong>并发性和共享性</strong>（最基本的两个特性）。</p></li><li><p>为了使参与并发执行的程序（含数据）能<strong>独立地运行</strong>，必须为之配置一个专门的数据结构，称为<strong>进程控制块</strong>（Process Control Block，PCB）。</p></li><li><p>系统利用 PCB 来描述进程的<strong>基本情况和运行状态</strong>，进而控制和管理进程。</p></li><li><p>相应地，由<strong>程序段、相关数据段和 PCB </strong>三部分构成了<strong>进程映像（进程实体）</strong>。</p></li><li><p>所谓创建进程，<strong>实质上是创建进程映像中的 PCB</strong>；而撤销进程，实质上是撤销进程的 PCB。</p><blockquote><p>值得注意的是，<strong>进程映像是静态的，进程则是动态的</strong>。</p><p>注意：PCB 是<strong>进程存在的唯一标志</strong>。</p></blockquote></li></ul></li><li><p>进程的典型定义：</p><ul><li><p>进程是<strong>程序的一次执行过程</strong>。</p></li><li><p>进程是<strong>一个程序及其数据在处理机上顺序执行</strong>时所发生的活动。</p></li><li><p>进程是具有独立功能的<strong>程序</strong>在一个<strong>数据</strong>集合上运行的过程，它是系统进行<strong>资源分配和调度的一个独立单位</strong>。</p><blockquote><p>进程是<strong>进程实体的运行过程</strong>，是系统进行资源分配和调度的一个独立单位（基本单位）。</p><p>进程是由多道程序的并发执行而引出的，它和程序是两个截然不同的概念。</p></blockquote></li></ul></li><li><p>进程的特征（理解）：</p><blockquote><p>进程的基本特征是对比<strong>单个程序的顺序执行</strong>提出的，也是对进程管理提出的基本要求。</p></blockquote><ul><li><p><strong>动态性</strong>：</p><p>​    进程是程序的一次执行，它有着创建、活动、暂停、终止等过程，具有一定的生命周期，是<strong>动态地产生、变化和消亡</strong>的。</p><blockquote><p>动态性是进程<strong>最基本</strong>的特征。</p></blockquote></li><li><p><strong>并发性</strong>：</p><p>​    指<strong>多个进程实体</strong>同时存于内存中，能在一段时间内同时运行。</p><blockquote><p>并发性是进程的重要特征，同时也是操作系统的重要特征。引入进程的目的就是使程序能与其他进程的程序并发执行，以提高<strong>资源利用率</strong>。</p></blockquote></li><li><p><strong>独立性</strong>：</p><p>​    指进程实体是一个能独立运行、独立获得资源和独立接受调度的<strong>基本单位</strong>。凡未建立 PCB 的程序，都不能作为一个独立的单位参与运行。</p></li><li><p><strong>异步性</strong>：</p><p>​    由于进程的相互<strong>制约</strong>，使得进程具有执行的<strong>间断性</strong>，即进程按<strong>各自独立的、不可预知</strong>的速度向前推进。</p><blockquote><p>异步性会导致执行结果的<strong>不可再现性</strong>，为此在操作系统中必须配置相应的进程同步机制。</p></blockquote></li><li><p><strong>结构性</strong>：</p><p>​    每个进程都配置一个进程控制块 PCB 对其进行描述。</p><blockquote><p>从结构上看，<strong>进程实体</strong>（也可以说是进程）是由<strong>程序段、数据段和 PCB</strong> 三部分组成的。</p></blockquote></li></ul></li><li><p><strong>进程和程序</strong>的区别：</p><ul><li><p><strong>本质区别</strong>：</p><ul><li>进程是<strong>动态</strong>的；程序是<strong>静态</strong>的。</li><li>进程是程序及其数据在计算机上的一次运行活动，是一个动态的概念。</li></ul></li><li><p>定义不同：</p><p>​    进程是程序处理数据的<strong>过程</strong>；程序是一组<strong>指令的有序集合</strong>。</p><blockquote><p>进程的运行实体是程序，离开程序的进程没有存在的意义。</p></blockquote></li><li><p>组成不同：</p><p>​    从静态角度看，进程是由程序、数据和进程控制块（PCB）三部分组成的；程序则是一组代码的集合。</p></li><li><p>生命周期不同：</p><p>​    进程是动态地创建和消亡的，具有<strong>一定的生命周期</strong>，是暂时存在的；程序则是一组代码的集合，是永久存在的，可长期保存。</p></li><li><p>对应关系不同：</p><p>​    一个进程可以执行一个或几个程序，一个程序也可构成多个进程。进程可创建进程，而程序不可能形成新的程序。</p></li></ul><blockquote><p>以下三点来自 CSAPP</p></blockquote></li><li><p>逻辑控制流：</p><ul><li><p>即使在系统中通常有许多其他程序在运行，进程也可以向每个程序提供一种假象，好像它在<strong>独占</strong>地使用处理器。</p></li><li><p>用调试器单步执行程序，会得到一系列的<strong>程序计数器</strong>（PC）的值，这些值唯一地对应于包含在程序的可执行目标文件中的指令，或是包含在运行时动态链接到程序的共享对象中的指令。这个 PC 值的序列叫做<strong>逻辑控制流</strong>，或者简称逻辑流。</p><blockquote><p>考虑一个运行着三个进程的系统，如图所示。处理器的一个物理控制流被分成了三个逻辑流，每个进程一个。每个竖直的条表示一个进程的逻辑流的一部分。在这个例子中，三个逻辑流的的关系是：</p><ul><li>A 和 B 是<strong>并发</strong>执行的，A 和 C 也是并发执行的（如果两个逻辑流在<strong>宏观时间上有重叠</strong>，则称这两个进程是并发的）。</li><li>B 和 C 是<strong>顺序</strong>执行的。</li></ul><div align="center"><img src=" /img/blog/os-note-images/image-20210923133153304.png" alt="image-20210923133153304" style="zoom:100%;"></div></blockquote></li></ul></li><li><p>私有地址空间：</p><ul><li><p><strong>进程</strong>也为每个<strong>程序</strong>提供一种假象，好像它<strong>独占</strong>地使用<strong>系统地址空间</strong>。</p></li><li><p>进程为每个程序提供它自己的私有地址空间。一般而言，和这个空间中某个地址相关联的那个内存字节是不能被其他进程读或者写的，从这个意义上说，这个地址空间是私有的。</p></li><li><p>尽管和每个私有地址空间相关联的内存的内容一般是不同的，但是每个这样的空间都有相同的通用结构。</p><div align="center"><img src=" /img/blog/os-note-images/image-20210923134902422.png"></div></li></ul></li><li><p>上下文切换：</p><ul><li>操作系统内核使用一种称为<strong>上下文切换</strong>的较高层形式的<strong>异常控制流</strong>来实现多任务</li><li>内核为每个进程维持一个上下文（context），上下文就是<strong>内核重新启动一个被抢占的进程</strong>所需的状态。</li><li>它由一些<strong>对象的值</strong>组成，这些对象包括<strong>通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构</strong>，比如描述地址空间的<strong>页表</strong>、包含有关当前进程信息的<strong>进程表</strong>，以及包含进程已打开<strong>文件的信息的文件表</strong>。</li><li>在进程执行的某些时刻，内核可以决定<strong>抢占当前进程</strong>，并重启一个先前被抢占了的进程。这种决策就叫做<strong>调度</strong>，是由内核中称为<strong>调度器</strong>的代码处理的。</li><li>在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为<strong>上下文切换的机制</strong>来将<strong>控制</strong>转移到新的进程：<ul><li><strong>保存</strong>当前进程的上下文。</li><li><strong>恢复</strong>某个先前被抢占的进程被保存的上下文。</li><li>将控制传递给这个新恢复的进程。</li></ul></li><li>当内核代表用户执行<strong>系统调用</strong>时，可能会发生上下文切换。如果系统调用因为等待某个事件发生而阻塞，那么内核可以让当前进程休眠，切换到另一个进程。</li></ul></li></ul><h3 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h3><blockquote><p>来自《王道》</p></blockquote><ul><li><p>状态描述：</p><p>​        进程在其生命周期内，由于系统中各进程之间的<strong>相互制约关系</strong>及系统的运行环境的变化，使得进程的状态也在不断地发生变化（<strong>一个进程会经历若干不同状态</strong>）。通常进程有以下 $5$ 种状态，前 $3$ 种是进程的基本状态。</p><ul><li><p>运行态：</p><p>​    进程正在处理机上运行。在<strong>单处理机环境</strong>下，每个时刻最多只有<strong>一个</strong>进程处于运行态。</p></li><li><p>就绪态：</p><p>​    进程获得了<strong>除处理机外的一切所需资源</strong>，一旦得到处理机，便可立即运行。系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。</p><blockquote><p>不可能所有进程都处于就绪态</p></blockquote></li><li><p>阻塞态（等待态）：</p><p>​    进程正在<strong>等待某一事件</strong>而暂停运行，如等待<strong>某资源为可用</strong>（不包括处理机）或等待<strong>输入/输出完成</strong>。即使处理机空闲，该进程也不能运行。</p></li><li><p>创建态：</p><p>​    进程正在被创建，尚未转到就绪态。</p><blockquote><p>创建进程通常需要多个步骤：</p><ol><li><strong>申请一个空白的 PCB</strong>，<strong>并向 PCB 中填写一些控制和管理进程的信息</strong></li><li>由系统为该进程<strong>分配运行时所必需的资源</strong></li><li>把该进程转入就绪态</li></ol></blockquote></li><li><p>结束态：</p><p>​    进程正从系统中消失，可能是<strong>进程正常结束或其他原因中断退出运行</strong>。进程需要结束运行时，系统首先必须将该进程置为结束态，然后进一步处理资源释放和回收等工作。</p></li></ul></li><li><p>状态转换：</p><ul><li><p>就绪态 $\to$ 运行态：</p><p>​    处于就绪态的进程被调度后，获得<strong>处理机资源（分派处理机时间片）</strong>，于是进程由就绪态转换为运行态。</p></li><li><p>运行态 $\to$ 就绪态：</p><ul><li>处于运行态的进程在<strong>时间片</strong>用完后，不得不让出处理机，从而进程由运行态转换为就绪态。</li><li>在<strong>可抢占</strong>的操作系统中，当有更高优先级的进程就绪时，程序将正在执行的进程转换为就绪态，让更高优先级的进程执行。</li></ul></li><li><p>运行态 $\to$ 阻塞态：</p><p>​    进程请求<strong>某一资源（如外设）的使用和分配或等待某一事件的发生（如 I/O 操作的完成）</strong>时，它就从运行态转换为阻塞态。</p></li><li><p>阻塞态 $\to$ 就绪态：</p><p>​    进程等待的事件到来时，如 I/O 操作结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞态转换为就绪态。</p></li></ul></li></ul><h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><blockquote><p>来自《王道》</p><p>在操作系统中，一般把进程控制用的程序段称为<strong>原语</strong>，原语的特点是执行期间<strong>不允许中断</strong>，它是一个不可分割的基本单位。</p></blockquote><ul><li><p>进程的创建：</p><ul><li><p>允许一个进程创建另一个进程。此时创建者称为<strong>父进程</strong>，被创建的进程称为子进程。</p></li><li><p>子进程可以<strong>继承父进程所拥有的资源</strong>。当子进程被撤销时，应将其从父进程那里获得的资源<strong>归还</strong>给父进程。</p></li><li><p>在撤销父进程时，必须同时撤销其所有的子进程。</p></li><li><p>操作系统创建一个新进程的过程如下（创建原语）：</p><ul><li><p>为新进程分配一个唯一的<strong>进程标识号</strong>，并申请一个空白的 PCB（PCB 是有限的）。若 PCB 申请失败，则创建失败。</p></li><li><p>为进程分配资源，为新进程的<strong>程序和数据及用户栈分配必要的内存空间</strong>（在 PCB 中体现）。</p><blockquote><p>若资源不足（如内存空间），则并不是创建失败，而是处于阻塞态，等待内存资源。</p></blockquote></li><li><p>初始化 PCB，主要包括初始化<strong>标志信息</strong>、<strong>处理机状态与控制信息</strong>，以及设置<strong>进程的优先级</strong>等。</p></li><li><p>若进程就绪队列能够接纳新进程，则将新进程插入就绪队列，等待被调度运行。</p></li></ul><blockquote><div align="center"><img src=" /img/blog/os-note-images/image-20211213151050037.png"></div></blockquote></li></ul></li><li><p>进程的终止:</p><ul><li><p>引起进程终止的事件主要有：</p><ul><li><p>正常结束：</p><p>​    表示进程的任务已完成并准备退出运行。</p></li><li><p>异常结束：</p><p>​    表示进程在运行时，发生了某种异常事件，使程序无法继续运行，如存储区越界、保护错、非法指令、特权指令错、运行超时、算术运算错、I/O 故障等。</p></li><li><p>外界干预：</p><p>​    指进程应外界的请求而终止运行，如<strong>操作员或操作系统干预</strong>、<strong>父进程请求</strong>和<strong>父进程终止</strong>。</p></li></ul></li><li><p>操作系统终止进程的过程如下（撤销原语）：</p><ul><li>根据被终止进程的标识符，<strong>检索 PCB</strong>，从中读出该进程的状态。</li><li>若被终止进程处于执行状态，立即终止该进程的执行，将<strong>处理机资源</strong>分配给其他进程。</li><li>若该进程还有子孙进程，则<strong>应将其所有子孙进程终止</strong>。</li><li>将该进程所拥有的全部资源，或<strong>归还</strong>给其父进程，或归还给操作系统。</li><li>将该 PCB 从所在队列（链表）中删除。</li></ul></li></ul></li><li><p>进程的阻塞和唤醒：</p><ul><li><p>正在执行的进程，由于期待的某些事件未发生，如<strong>请求系统资源失败</strong>、<strong>等待某种操作的完成</strong>、新数据尚未到达或无新工作可做等，由系统自动执行阻塞原语（Block），使自己由运行态变为<strong>阻塞态</strong>。</p><blockquote><p>进程的阻塞是进程自身的一种<strong>主动行为</strong>，也因此只有处于<strong>运行态</strong>的进程（获得 CPU），才可能将其转为阻塞态。</p></blockquote></li><li><p>阻塞原语的执行过程如下：</p><ul><li><p>找到将要被阻塞进程的标识号对应的 PCB。</p></li><li><p>若该进程为运行态，则<strong>保护其现场</strong>，将其状态转为阻塞态，停止运行。</p></li><li><p>把该 PCB 插入相应事件的等待队列，将处理机资源调度给其他就绪进程。</p><blockquote><p>当被阻塞进程所期待的事件出现时，如它所启动的 I/O 操作已完成或其所期待的数据已到达，由<strong>有关进程</strong>（比如，释放该 I/O 设备的进程，或提供数据的进程）调用<strong>唤醒原语</strong>（Wakeup），将等待该事件的进程唤醒。</p><p>唤醒原语的执行过程如下：</p><ul><li>在该事件的等待队列中找到相应进程的 PCB.</li><li>将其从等待队列中移出，并置其状态为就绪态。</li><li>把该 PCB 插入就绪队列，等待调度程序调度。</li><li>需要注意的是，Block 原语和 Wakeup 原语是一对作用刚好相反的原语，必须成对使用。</li><li>Block 原语是由被阻塞进程<strong>自我调用</strong>实现的，而 Wakeup 原语则是由一个与被唤醒进程合作或被其他相关的<strong>进程调用</strong>实现的。</li></ul></blockquote></li></ul></li></ul></li><li><p>进程切换：</p><blockquote><p>对于通常的进程而言，其创建、撤销及要求由系统设备完成的 I/O 操作，都是利用系统调用而进入内核，再由<strong>内核中的相应处理程</strong>序予以完成的。</p><p>进程切换同样是在内核的支持下实现的，因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p></blockquote><p>进程切换是指处理机从一个进程的运行转到另一个进程上运行，在这个过程中，<strong>进程的运行环境产生了实质性的变化</strong>。进程切换的过程如下：</p><ul><li>保存<strong>处理机上下文</strong>，包括程序计数器和其他寄存器。</li><li><strong>更新 PCB 信息</strong>。</li><li>把进程的 PCB 移入相应的队列，如就绪、在某事件阻塞等队列。</li><li>选择另一个进程执行，并更新其 PCB.</li><li>更新<strong>内存管理</strong>的数据结构（可能要刷新 TLB 之类的）。</li><li><strong>恢复</strong>处理机上下文。</li></ul></li></ul><h3 id="进程-Unix-代码"><a href="#进程-Unix-代码" class="headerlink" title="进程 Unix 代码"></a>进程 Unix 代码</h3><blockquote><p>来自 PPT 和 CSAPP</p></blockquote><ul><li><p>获取进程 ID：</p><p>​    每个进程都有一个唯一的正数（非零）进程 ID（PID）。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">pid_t</span> <span class="hljs-title">getpid</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;  <span class="hljs-comment">/* 返回调用进程的PID */</span><br><span class="hljs-function"><span class="hljs-keyword">pid_t</span> <span class="hljs-title">getppid</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>; <span class="hljs-comment">/* 返回调用进程的父进程的 PID */</span><br></code></pre></td></tr></tbody></table></figure></li><li><p><code>exit</code> 终止进程:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* exit 函数以 status 退出状态来终止进程。正常结束时返回 0 , 错误时返回非 0 值*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> status)</span></span>;<br></code></pre></td></tr></tbody></table></figure></li><li><p><code>fork()</code> 创建进程：</p><ul><li><p>子进程得到与父进程<strong>用户级虚拟地址空间</strong>相同的（但是<strong>独立</strong>的）一份<strong>副本</strong>，包括<strong>代码和数据段、堆、共享库以及用户栈</strong>。</p></li><li><p>子进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用 <code>fork()</code> 时，子进程可以读写父进程中打开的任何<strong>文件</strong>。</p></li><li><p>父进程和新创建的子进程之间<strong>最大的区别</strong>在于它们有<strong>不同的 PID</strong>。</p></li><li><p><code>fork()</code> 函数只被调用一次，却会返回两次。一次是在调用进程（父进程）中，一次是在新创建的子进程中：</p><ul><li>在<strong>父进程</strong>中，<code>fork()</code> 返回子进程的 PID。</li><li>在<strong>子进程</strong>中，<code>fork()</code> 返回 $0$。因为子进程的 PID 总是<strong>为非零</strong>，返回值就提供一个明确的方法来<strong>分辨</strong>程序是在父进程还是在子进程中执行。</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fork</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br></code></pre></td></tr></tbody></table></figure></li><li><p>子进程和父进程并发执行。</p></li><li><p>进程图：</p><blockquote><p>有向边 $a\to b$ 表示 $a$ 在 $b$ 前执行。</p></blockquote><p>对于代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{<br>Fork();<br>Fork(); <br><span class="hljs-built_in">printf</span> (<span class="hljs-string">"hello\n"</span>); <br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>其进程图为：</p><div align="center"><img src=" /img/blog/os-note-images/image-20210923190042191.png"></div></li></ul></li><li><p>进程回收：</p><ul><li><p>当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除，而是被保持在一种<strong>已终止</strong>的状态中，直到被它的<strong>父进程回收</strong>。</p></li><li><p>当父进程回收已终止的子进程时，内核将子进程的<strong>退出状态</strong>传递给父进程，然后抛弃已终止的进程，从此时开始，该进程就不存在了。</p></li><li><p>一个终止了但还未被回收的进程称为<strong>僵死进程</strong>。</p></li><li><p>如果一个父进程终止了，内核会安排 <strong>init 进程</strong>成为它的孤儿进程的<strong>养父</strong>。</p></li><li><p>init 进程的 PID 为 $1$，是在系统启动时由<strong>内核</strong>创建的，它不会终止，是<strong>所有进程的祖先</strong>。</p></li><li><p>如果父进程没有回收它的僵死子进程就终止了，那么内核会安排 init 进程去回收它们。</p></li><li><p>即使僵死子进程没有运行，它们仍然<strong>消耗</strong>系统的内存资源。</p></li><li><p>一个进程可以通过调用 <code>waitpid</code> 函数来等待它的子进程终止或者停止。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">pid_t</span> <span class="hljs-title">waitpid</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid, <span class="hljs-keyword">int</span> *statusp, <span class="hljs-keyword">int</span> options)</span></span>;<br></code></pre></td></tr></tbody></table></figure><ul><li><p>默认情况下（当 <code>options = 0</code> 时），<code>waitpid</code> <strong>挂起调用进程</strong>的执行，直到它的等待集合中的<strong>一个子进程</strong>终止。</p></li><li><p>如果等待集合中的<strong>一个进程</strong>在刚调用的时刻就已经终止了，那么 <code>waitpid</code> 就<strong>立即返回</strong>。</p></li><li><p><code>waitpid</code> 返回导致 <code>waitpid</code> 返回的<strong>已终止子进程的 PID</strong>。已终止的子进程已经被回收，内核会从系统中删除掉它的所有痕迹。</p><blockquote><p>如果 <code>pid &gt; 0</code>，那么等待集合就是一个单独的子进程，它的进程 ID 等于 pid。<br>如果 <code>pid = -1</code>，那么等待集合就是由<strong>父进程所有的子进程</strong>组成的。</p></blockquote></li><li><p>调用 <code>wait(&amp;status)</code> 等价于调用 <code>waitpid(-1, &amp;status, 0)</code>。</p></li></ul><blockquote><p>常用写法总结：</p><ul><li><p>循环回收并等待所有子进程结束：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> ((pid = waitpid(<span class="hljs-number">-1</span>, &amp;status, <span class="hljs-number">0</span>)) &gt; <span class="hljs-number">0</span>)<br></code></pre></td></tr></tbody></table></figure></li><li><p>循环回收当前所有已结束的子进程，不等待：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (waitpid(<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, WNOHANG) &gt; <span class="hljs-number">0</span>)<br></code></pre></td></tr></tbody></table></figure><blockquote><p><code>WNOHANG</code>：</p><ul><li>如果等待集合中的任何子进程都还没有终止，那么就立即返回（返回值为 $0$）。</li><li>之前默认的行为（<code>option = 0</code>）是挂起调用进程，直到有子进程终止。</li><li>可以用来<strong>回收后台子进程任务</strong>。</li></ul></blockquote></li></ul></blockquote></li></ul></li><li><p>进程休眠（挂起）：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> secs)</span></span>;<br></code></pre></td></tr></tbody></table></figure><ul><li><p>如果请求的时间量已经到了，<code>sleep</code> 返回 <code>0</code>，否则返回还剩下的要休眠的秒数（如果因为 <code>sleep</code> 函数被一个信号中断而过早地返回）。</p></li><li><p><code>pause</code> 函数让调用函数休眠，直到该进程收到一个信号。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pause</span> <span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br></code></pre></td></tr></tbody></table></figure></li></ul></li><li><p>加载并运行程序：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execve</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *argv[], <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *envp[])</span></span>;<br></code></pre></td></tr></tbody></table></figure><ul><li><code>execve()</code> 函数加载并运行可执行目标文件 <code>filename</code>，且带参数列表 <code>argv</code> 和环境变量列表 <code>envp</code>。</li><li>只有当出现错误时，例如找不到 <code>filename</code> 或 <code>execve()</code> 才会返回到调用程序。</li><li><code>execve()</code> 调用一次并从不返回。</li><li>参数列表是如图所示：<ul><li><code>argv</code> 变量指向一个以 <code>null</code> 结尾的指针数组，其中每个指针都指向一个参数字符串。<code>argv[0]</code> 是<strong>可执行目标文件</strong>的名字。</li><li><code>envp</code> 变量指向一个以 <code>null</code> 结尾的指针数组，其中每个指针指向一个环境变量字符串，每个串都是形如 <code>"name=value"</code> 的名字 - 值对。</li></ul></li><li><code>execve()</code> 函数在当前进程的上下文中加载并运行一个<strong>新的程序</strong>，覆盖当前进程的<strong>地址空间</strong>，但并没有创建一个新进程。</li></ul></li></ul><h3 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h3><blockquote><p>进程是一个独立的运行单位，也是操作系统进行<strong>资源分配和调度的基本单位</strong>。它由以下三部分组成，其中最核心的是<strong>进程控制块</strong>（PCB）</p></blockquote><ul><li><p>进程控制块：</p><ul><li><p>进程创建时，操作系统为它新建一个 PCB，该结构之后常驻<strong>内存</strong>，任意时刻都可以存取，并在进程结束时删除。</p></li><li><p>PCB 是进程实体的一部分，是<strong>进程存在的唯一标志</strong>。</p></li><li><p>进程执行时，系统通过其 PCB 了解进程的现行<strong>状态信息</strong>，以便对其进行控制和管理；进程结束时，系统收回其 PCB，该进程随之消亡。</p></li><li><p>操作系统通过 PCB 表来管理和控制进程：</p><ul><li>当操作系统欲<strong>调度</strong>某进程运行时，要从该进程的 PCB 中查出其<strong>现行状态及优先级</strong>。</li><li>在调度到某进程后，要根据其 PCB 中所保存的处理机状态信息，设置该进程<strong>恢复运行的现场</strong>，并根据其 PCB 中的程序和数据的内存始址，找到其程序和数据。</li><li>进程在<strong>运行</strong>过程中，当需要和与之合作的进程实现<strong>同步、通信或访问文件</strong>时，也需要访问 PCB。</li><li>当进程由于某种原因而<strong>暂停</strong>运行时，又需将其断点的处理机环境保存在 PCB 中。</li><li>可见，在进程的整个生命期中，系统总是通过 PCB 对进程进行控制的，亦即系统唯有通过进程的 PCB 才能感知到该进程的存在。</li></ul><blockquote><p>下表是一个 PCB 的实例。</p></blockquote></li></ul></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">进程描述信息</th><th style="text-align:center">进程控制和管理信息</th><th style="text-align:center">资源分配清单</th><th style="text-align:center">处理机相关信息</th></tr></thead><tbody><tr><td style="text-align:center">进程标识符（PID）</td><td style="text-align:center">进程当前状态</td><td style="text-align:center">代码段指针</td><td style="text-align:center">通用寄存器值</td></tr><tr><td style="text-align:center">用户标识符（UID）</td><td style="text-align:center">进程优先级</td><td style="text-align:center">数据段指针</td><td style="text-align:center">地址寄存器值</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">代码运行入口地址</td><td style="text-align:center">堆栈段指针</td><td style="text-align:center">控制寄存器值</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">程序的外存地址</td><td style="text-align:center">文件描述符</td><td style="text-align:center">标志寄存器值</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">进入内存时间</td><td style="text-align:center">键盘</td><td style="text-align:center">状态字</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">处理机占用时机</td><td style="text-align:center">鼠标</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">信号量使用</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><ul><li><p>程序段：</p><p>​    程序段就是能被进程调度程序调度到 CPU 执行的程序代码段。注意，<strong>程序可被多个进程共享</strong>，即多个进程可以运行同一个程序。</p></li><li><p>数据段：</p><p>​    一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果。</p></li></ul><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><blockquote><p>整理自《王道》</p><p>进程通信是指进程之间的信息交换。$PV$ 操作是低级通信方式，高级通信方式是指以<strong>较高的效率</strong>传输大量数据的通信方式。</p></blockquote><p>高级通信方法主要有以下三类:</p><ul><li><p>共享存储：</p><ul><li><p>在通信的进程之间存在一块可直接访问的<strong>共享空间</strong>，通过对这片共享空间进行写/读操作实现进程之间的信息交换。</p></li><li><p>在对共享空间进行写/读操作时，需要使用<strong>同步互斥工具</strong>（如 $P$ 操作、$V$ 操作），对共享空间的写/读进行控制。</p></li><li><p>共享存储又分为两种：</p><ul><li>低级方式的共享是基于<strong>数据结构</strong>的共享。</li><li>高级方式的共享则是基于<strong>存储区</strong>的共享。</li></ul></li><li><p>操作系统只负责为通信进程提供可共享使用的<strong>存储空间和同步互斥工具</strong>，而数据交换则由用户自己安排读/写指令完成。</p><blockquote><p>注意，用户进程空间一般都是独立的，进程运行期间一般不能访问其他进程的空间，只能通过共享空间间接访问，<strong>不能通过全局变量共享</strong>。</p><p>要想让两个用户进程共享空间，必须通过特殊的系统调用实现，而进程内的线程是自然共享进程空间的。</p></blockquote></li></ul></li><li><p>消息传递：</p><ul><li><p>在消息传递系统中，进程间的数据交换是以<strong>格式化的消息（Message）为单位</strong>的。</p></li><li><p>若通信的进程之间不存在可直接访问的共享空间，则必须利用操作系统提供的消息传递方法实现进程通信。</p></li><li><p>进程通过系统提供的<strong>发送消息和接收消息两个原语</strong>进行数据交换。</p></li><li><p>有两种通信方式：</p><ul><li><p>直接通信方式：</p><p>​    发送进程直接把消息发送给接收进程，并将它挂在接收进程的<strong>消息缓冲队列</strong>上，接收进程从消息缓冲队列中取得消息。</p></li><li><p>间接通信方式：</p><p>​    发送进程把消息发送到某个<strong>中间实体</strong>，接收进程从中间实体取得消息。</p><blockquote><p>这种中间实体一般称为信箱，这种通信方式又称信箱通信方式。该通信方式广泛应用于计算机网络，相应的通信系统称为电子邮件系统。</p></blockquote></li></ul></li></ul></li><li><p>管道通信：</p><ul><li><p>所谓「<strong>管道</strong>」，是指用于连接一个读进程和一个写进程以实现它们之间的通信的一个<strong>共享文件</strong>，又名 pipe 文件。</p></li><li><p>向管道（共享文件）提供输入的发送进程（即写进程），以字符流形式将大量的数据送入（写）管道。</p></li><li><p>而接收管道输出的接收进程（即读进程）则从管道中接收（读）数据。</p></li><li><p>为了协调双方的通信，管道机制必须提供以下三方面的协调能力：</p><ul><li><p><strong>互斥</strong>：</p><p>​    一个进程正在对 pipe 进行读/写操作时，另一进程必须等待。</p></li><li><p><strong>同步</strong>：</p><ul><li>当写（输入）进程把一定数量的数据写入 pipe 后，便去睡眠等待，直到读（输出）进程取走数据将其唤醒。</li><li>当读进程读一空 pipe，也应睡眠等待，直至写进程将数据写入管道，才将其唤醒。</li></ul></li><li><p><strong>确定对方的存在</strong>：</p><p>​    只有确定对方已存在时，才能进行管道通信，否则会造成因对方不存在而无限期等待。</p></li></ul></li><li><p>从本质上说，管道也是一种文件，但它又和一般的文件有所不同，管道可以克服使用文件进行通信的两个问题，具体表现如下：</p><ul><li><p>限制管道的大小：</p><ul><li>实际上，管道是一个<strong>固定大小的缓冲区</strong>，在 Linux 中，该缓冲区的大小为 $4\rm ~KB$，这使得它的大小不像文件那样不加检验地增长。</li><li>使用单个固定缓冲区也会带来问题，比如在写管道时可能变满。</li><li>这种情况发生时，随后对管道的 <code>write()</code> 调用将默认地被<strong>阻塞</strong>，等待某些数据被读取，以便腾出足够的空间供 <code>write()</code> 调用写。</li></ul></li><li><p>读进程也可能工作得比写进程快：</p><ul><li>当所有当前进程数据已被读取时，管道变空。</li><li>这种情况发生时，一个随后的 <code>read()</code> 调用将默认地被阻塞，等待某些数据被写入，这解决了 <code>read()</code> 调用返回文件结束的问题。</li></ul><blockquote><p>从管道读数据是一次性操作，数据一旦被读取，它就从管道中被抛弃，释放空间以便写更多的数据。</p><p>管道只能采用<strong>半双工通信</strong>，即某一时刻只能单向传输，「双向数据传输」是错误的说法。要实现父子进程双方互动通信，需要定义两个管道。</p><div align="center"><img src=" /img/blog/os-note-images/image-20211211224246093.png"></div></blockquote></li></ul></li></ul></li></ul><h3 id="异常控制流"><a href="#异常控制流" class="headerlink" title="异常控制流"></a>异常控制流</h3><blockquote><p>整理自 PPT 和 CSAPP，以 CSAPP 的顺序描述</p></blockquote><h4 id="异常控制流概念"><a href="#异常控制流概念" class="headerlink" title="异常控制流概念"></a>异常控制流概念</h4><ul><li><p>控制流定义：</p><p>​    从开机到结束运行，<strong>一个</strong> CPU 所作的仅仅是读取并且执行（或者说是解释）<strong>一连串的指令</strong>，在某个时刻只会<strong>运行一条指令</strong>，这样一个指令的运行序列就是 CPU 的<strong>控制流</strong>。</p></li><li><p>异常控制流定义：</p><p>​    现代系统通过使控制流发生突变来对这些情况做出反应，这些突变称为<strong>异常控制流</strong>（Exceptional Control Flow，ECF）。</p></li><li><p>异常定义：</p><ul><li>异常是异常控制流的一种<strong>形式</strong>，它一部分由<strong>硬件</strong>实现，一部分由<strong>操作系统</strong>实现。</li><li>异常响应某些事件（即处理器状态更改），进而将控制权转移到 <strong>OS 内核</strong>。</li></ul></li><li><p>异常处理：</p><ul><li><p>系统中可能的每种类型的异常都分配了一个<strong>唯一的非负整数的异常号</strong>：</p><ul><li><p>由<strong>处理器的设计者</strong>分配的号码：</p><p>​    包括被零除、缺页、内存访问违例、断点以及算术运算溢出。</p></li><li><p>由<strong>操作系统内核</strong>（操作系统常驻内存的部分）的<strong>设计者</strong>分配的号码：</p><p>​    包括<strong>系统调用</strong>和来自外部 I/O 设备的信号。</p></li></ul></li><li><p>在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做<strong>异常表</strong>的跳转表，进行一个间接过程调用（异常），到一个专门设计用来处理这类事件的操作系统子程序（<strong>异常处理程序</strong>），当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下 $3$ 种情况中的一种：</p><ul><li>处理程序将控制返回给当前指令 $I_{curr}$，即当事件发生时<strong>正在执行</strong>的指令。</li><li>处理程序将控制返回给 $I_{next}$，即如果没有发生异常将会执行的<strong>下一条</strong>指令。</li><li>处理程序<strong>终止</strong>被中断的程序。</li></ul></li><li><p>异常类似于过程调用，但是有一些重要的不同之处：</p><ul><li><p>入栈内容不同：</p><ul><li>过程调用时，在跳转到处理程序之前，处理器将返回地址压入栈中。</li><li>根据异常的类型，返回地址要么是当前指令，要么是下一条指令。</li><li>处理器也把一些额外的<strong>处理器状态</strong>压到栈里，在处理程序返回时，重新开始执行被中断的程序会需要这些状态。</li></ul></li><li><p>入的栈不同：</p><p>​    如果控制从用户程序转移到内核，所有这些项目都被压到<strong>内核栈</strong>中，而不是压到用户栈中。</p></li><li><p>权限不同：</p><p>​    异常处理程序运行在内核模式下，这意味着它们对所有的系统资源都有完全的访问权限。</p></li></ul></li></ul></li><li><p>异常类别：</p><ul><li>属性概括：</li></ul></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">类别</th><th style="text-align:center">原因</th><th style="text-align:center">异步/同步</th><th style="text-align:center">返回行为</th></tr></thead><tbody><tr><td style="text-align:center">中断（Interrupt）</td><td style="text-align:center">来自 I/O 设备的信号</td><td style="text-align:center">异步</td><td style="text-align:center">总是返回到下一条指令</td></tr><tr><td style="text-align:center">陷阱（Trap）</td><td style="text-align:center">有意的异常</td><td style="text-align:center">同步</td><td style="text-align:center">总是返回到下一条指令</td></tr><tr><td style="text-align:center">故障（Fault）</td><td style="text-align:center">潜在的可恢复的错误</td><td style="text-align:center">同步</td><td style="text-align:center">返回到当前指令或终止</td></tr><tr><td style="text-align:center">终止（Abort）</td><td style="text-align:center">不可恢复的错误</td><td style="text-align:center">同步</td><td style="text-align:center">不会返回</td></tr></tbody></table></div><ul><li><p>中断：</p><ul><li><p>中断是<strong>异步</strong>发生的，是来自处理器外部的 I/O 设备的信号的结果。</p></li><li><p>硬件中断<strong>不是由任何一条专门的指令</strong>造成的，从这个意义上来说它是异步的。</p></li><li><p>硬件中断的异常处理程序常常称为<strong>中断处理程序</strong>。</p></li><li><p>通过设置 CPU 的<strong>中断引脚</strong>来触发。</p><blockquote><p>其他三类同步异常也叫故障指令。</p></blockquote></li></ul></li><li><p>陷阱：</p><ul><li>陷阱是<strong>有意的</strong>异常，是执行一条指令的结果。</li><li>就像中断处理程序一样，陷阱处理程序将控制返回到<strong>下一条指令</strong>。</li><li>陷阱最重要的用途是在<strong>用户程序和内核</strong>之间提供一个像过程一样的<strong>接口</strong>，叫做<strong>系统调用</strong>。</li><li>系统调用运行在内核模式中，内核模式允许系统调用执行特权指令，并访问定义在内核中的栈。</li></ul></li><li><p>故障：</p><ul><li><p>故障由错误情况引起，它<strong>可能</strong>能够被故障处理程序修正。</p></li><li><p>当故障发生时，处理器将控制转移给<strong>故障处理程序</strong>。</p></li><li><p>如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而<strong>重新执行</strong>它。</p></li><li><p>否则，处理程序返回到内核中的 abort 例程，<strong>终止</strong>引起故障的应用程序。</p><blockquote><p><strong>缺页</strong>和<strong>无效的内存引用</strong>（越界）会引发故障。</p></blockquote></li></ul></li><li><p>终止：</p><p>​    终止是不可恢复的致命错误造成的结果，通常是一些<strong>硬件错误</strong>。</p></li></ul><h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><ul><li><p>信号定义：</p><ul><li>信号是<strong>内核</strong>发出的一个消息，用来通知进程，系统中发生了某种类型的事件。</li><li>信号从<strong>内核发往进程</strong>（有时信号的发送是由另一个<strong>进程发起</strong>的）。</li><li>每一种信号都用一个整数 ID 来表示。</li><li>通常情况下只有信号 ID 会被发送给进程。</li><li>使用信号的两个主要目的为：<ul><li>通知进程某种特殊的事件发生了（比如一些低层的<strong>硬件异常</strong>）。</li><li>迫使进程<strong>执行信号处理程序</strong>。</li></ul></li></ul></li><li><p>进程组：</p><ul><li><p>每个进程都<strong>只属于一个进程组</strong>，进程组是由一个正整数进程组 ID 来标识的。<code>getpgrp</code> 函数返回当前进程的进程组 ID：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">pid_t</span> <span class="hljs-title">getpgrp</span> <span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">pid_t</span> <span class="hljs-title">getpgid</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid)</span></span>; <span class="hljs-comment">/* 返回 ID 为 pid 的进程的组 ID */</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>默认子进程和它的<strong>父进程</strong>同属于一个进程组，可以修改指定进程的进程组：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 将进程 pid 的进程组改为 pgid,若成功则为 0,若错误则为 -1 */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setpgid</span> <span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid，<span class="hljs-keyword">pid_t</span> pgid)</span></span><br><span class="hljs-function"><span class="hljs-comment">/* </span></span><br><span class="hljs-comment"><span class="hljs-function">* 如果 pid 是 0,那么就使用当前调用进程的 PID</span></span><br><span class="hljs-comment"><span class="hljs-function">* 如果 pgid 是 0,那么就用 pid 指定的进程的 PID 作为进程组 ID</span></span><br><span class="hljs-comment"><span class="hljs-function">* 例如：</span></span><br><span class="hljs-comment"><span class="hljs-function">* 如果当前调用进程 PID 为 15213,那么 setpgid(0，0) 会创建一个新的进程组,</span></span><br><span class="hljs-comment"><span class="hljs-function">* 其进程组的 ID 是 15213,并且把进程 15213 加入到这个新的进程组中。</span></span><br><span class="hljs-comment"><span class="hljs-function">*/</span></span><br></code></pre></td></tr></tbody></table></figure></li><li><p><code>kill</code> 函数：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kill</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid，<span class="hljs-keyword">int</span> sig)</span></span><br><span class="hljs-function"><span class="hljs-comment">/*</span></span><br><span class="hljs-comment"><span class="hljs-function">* pid &gt; 0：发送信号 sig 给进程 pid </span></span><br><span class="hljs-comment"><span class="hljs-function">* pid = 0：发送信号 sig 给调用进程的进程组内的所有进程包括其自身</span></span><br><span class="hljs-comment"><span class="hljs-function">* pid &lt; 0：发送信号 sig 给进程组 |pid| (pid的绝对值) 内的所有进程</span></span><br><span class="hljs-comment"><span class="hljs-function">*/</span></span><br></code></pre></td></tr></tbody></table></figure></li><li><p>用 <code>/bin/kill</code> 程序发送信号：</p><ul><li><code>/bin/kill</code> 程序可以向另外的进程发送任意的信号。</li><li>命令 <code>linux&gt;/bin/kill -9 15213</code> 发送信号 <code>9(SIGKILL)</code> 给进程 <code>15213</code>。</li><li>一个为负的 PID 会导致信号被发送到进程组 PID 中的每个进程。</li></ul></li></ul><blockquote><p>传送一个信号到目的进程是由发送信号和接收信号完成。</p></blockquote></li><li><p><strong>发送信号</strong>：</p><ul><li>内核通过更新目的<strong>进程上下文中的某个状态</strong>，发送一个信号给目的进程。</li><li><p>发送信号可以有如下两种原因：</p><ul><li>内核检测到一个<strong>系统事件</strong>，比如除零错误或者子进程终止。</li><li>一个进程调用了 <code>kill</code> 函数，显式地要求内核发送一个信号给目的进程。</li></ul></li><li>一个进程可以发送信号给它<strong>自己</strong>。</li></ul></li><li><p><strong>接收信号</strong>：</p><ul><li><p>当目的进程被内核<strong>强迫</strong>以某种方式对信号的发送<strong>做出反应</strong>时，它就接收了信号。</p></li><li><p>当内核把<strong>进程 $p$</strong> 从<strong>内核模式切换到用户模式</strong>时（例如，从系统调用返回或是完成了一次上下文切换），它会检查进程 $p$ 的<strong>未被阻塞的待处理信号</strong>的集合（pending \&amp; ~blocked）：</p><ul><li>如果这个集合<strong>为空</strong>（通常情况下），那么内核将控制传递到进程 $p$ 的逻辑控制流中的<strong>下一条指令</strong> $I_{next }$。</li><li>如果集合是<strong>非空</strong>的，那么内核选择集合中的某个信号 $k$（通常是最小的 $k$），并且强制进程 $p$ 接收信号 $k$，收到这个信号会触发进程采取某种行为。</li><li>完成这一行为后将该位清零，然后重复这一过程，直到集合为空，把控制传递回 $p$ 的逻辑控制流中的<strong>下一条</strong>指令 $I_{next }$。</li><li>每个信号类型都有一个预定义的默认行为，是下面中的一种:<ul><li>进程终止。</li><li>进程终止并<strong>转储内存</strong>。</li><li>进程<strong>停止（挂起）</strong>直到被 SIGCONT 信号重启。</li><li>进程<strong>忽略</strong>该信号。</li></ul></li></ul></li><li><p>设置信号处理程序：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">sighandler_t</span> <span class="hljs-title">signal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> signum, <span class="hljs-keyword">sighandler_t</span> handler)</span></span>;<br></code></pre></td></tr></tbody></table></figure><p><code>signal</code> 函数可以通过下列三种方法之一来改变和信号 <code>signum</code> 相关联的行为：</p><ul><li>如果 <code>handler</code> 是 <code>SIG-IGN</code>，那么忽略类型为 <code>signum</code> 的信号。</li><li>如果 <code>handler</code> 是 <code>SIG-DFL</code>，那么类型为 <code>signum</code> 的信号行为恢复为默认行为。</li><li>否则，<code>handler</code> 就是用户定义的函数的地址，这个函数被称为信号处理程序，只要进程接收到一个类型为 <code>signum</code> 的信号，就会调用这个程序。</li><li>当一个进程捕获了一个类型为 $k$ 的信号时，会调用为信号 $k$ 设置的处理程序。</li></ul></li></ul></li><li><p>待处理信号：</p><ul><li>一个发出而没有被接收的信号叫做<strong>待处理信号</strong>。</li><li>在任何时刻，<strong>一种类型至多只会有一个</strong>待处理信号。</li><li>如果一个进程有一个<strong>类型为 $k$ 的待处理信号</strong>，那么任何接下来发送到这个进程的类型为 $k$ 的信号<strong>都不会排队等待</strong>，而是被简单地丢弃。</li></ul></li><li><p>一个进程可以<strong>有选择性地阻塞</strong>接收某种信号。当一种信号被阻塞时，它仍可以被传送，但是它不会被接收，直到进程取消对这种信号的阻塞。</p><ul><li>一个待处理信号最多只能被接收一次。</li><li>内核为每个进程在 pending <strong>挂起位向量</strong>中维护着<strong>待处理信号</strong>的集合，而在 blocked <strong>阻塞位向量</strong>中维护着被<strong>阻塞</strong>的信号集合。</li><li>只要<strong>传送</strong>了一个类型为 $k$ 的信号，内核就会<strong>设置</strong> pending 中的第 $k$ 位。</li><li>只要<strong>接收</strong>了一个类型为 $k$ 的信号，内核就会<strong>清除</strong> pending 中的第 $k$ 位。</li></ul></li><li><p>阻塞信号：</p><ul><li><p><strong>隐式</strong>阻塞机制：</p><p>​    内核默认阻塞任何当前处理程序<strong>正在处理信号类型</strong>的待处理的信号。</p></li><li><p><strong>显式</strong>阻塞机制：</p><p>​    应用程序可以使用 <code>sigprocmask</code> 函数和它的辅助函数，明确地阻塞和解除阻塞选定的信号。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* sigset_t 类型其实是和 pending 和 blocked 相同的位向量，每一位表示一个信号 */</span><br><span class="hljs-comment">/* 如果成功则为 0，若出错则为 -1 */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sigemptyset</span><span class="hljs-params">(<span class="hljs-keyword">sigset_t</span> *<span class="hljs-built_in">set</span>)</span></span>;  <span class="hljs-comment">/* 初始化 set 为空集合 */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sigfillset</span><span class="hljs-params">(<span class="hljs-keyword">sigset_t</span> *<span class="hljs-built_in">set</span>)</span></span>;  <span class="hljs-comment">/* 把每个信号都添加到 set 中 */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sigaddset</span><span class="hljs-params">(<span class="hljs-keyword">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-keyword">int</span> signum)</span></span>; <span class="hljs-comment">/* 把指定的信号 signum 添加到 e */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sigdelset</span><span class="hljs-params">(<span class="hljs-keyword">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-keyword">int</span> signum)</span></span>; <span class="hljs-comment">/* 从 set 中删除指定的信号 signum */</span><br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">*  如果 how = SIG_BLOCK,则表示将 set 中的信号全部添加到 blocked 中,即阻塞 set 中的全部信号 </span><br><span class="hljs-comment">*  将 blocked 位向量之前的值保存在 oldset 中,通过 sigprocmask(SIG_SETMASK, &amp;oldset, NULL); 还原</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sigprocmask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> how, <span class="hljs-keyword">const</span> <span class="hljs-keyword">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-keyword">sigset_t</span> *oldset)</span></span>;  <br><br><br><span class="hljs-comment">/* 若 signum 是 set 的成员则为 1，如果不是则为 0，若出错则为 -1 */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sigismember</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-keyword">int</span> signum)</span></span>;<br></code></pre></td></tr></tbody></table></figure></li></ul></li></ul><h4 id="编写信号处理要注意的问题"><a href="#编写信号处理要注意的问题" class="headerlink" title="编写信号处理要注意的问题"></a>编写信号处理要注意的问题</h4><blockquote><p>存在的问题：</p><p>​    信号处理程序与主程序<strong>并发</strong>运行，共享同样的全局变量，因此可能与主程序和其他处理程序互相干扰。</p></blockquote><ul><li><p><strong>安全的信号处理</strong>：</p><ul><li><p>$G0$：</p><p>​    处理程序尽可能地<strong>简单</strong>。</p><blockquote><p>例如：</p><ul><li>处理程序可能只是简单地设置全局标志并立即返回</li><li>所有与<strong>接收信号</strong>相关的处理都由<strong>主程序</strong>执行，<strong>处理程序</strong>只周期性地<strong>检查</strong>（并重置）这个标志。</li></ul></blockquote></li><li><p>$G1$：</p><p>​    在处理程序中只调用<strong>异步信号安全</strong>的函数：</p><ul><li>是<strong>可重入</strong>的，参见 <a href="#可重入性">后文</a>。</li><li><strong>不能被信号处理程序中断</strong>。</li></ul><blockquote><p>信号处理程序中产生<strong>输出</strong>唯一安全的方法是使用 <code>write</code> 函数。特别地，调用 <code>printf</code> 或 <code>sprintf</code> 是<strong>不安全</strong>的。</p><p>一些安全的函数，称为 SIO（安全的 I/O）包，可以用来在信号处理程序中打印简单的消息。</p></blockquote></li><li><p>$G2$：</p><p>​    <strong>保存和恢复</strong> <code>errno</code>。</p><ul><li>许多 Linux 异步信号安全的函数都会在<strong>出错返回时设置</strong> <code>errno</code>。</li><li>在处理程序中调用这样的函数可能会干扰<strong>主程序中其他依赖</strong>于 <code>errno</code> 的部分。</li><li>解决方法是在进入处理程序时把 <code>errno</code> 保存在一个<strong>局部变量</strong>中，在处理程序返回前恢复它。</li><li>注意，只有在处理程序要返回时才有此必要。如果处理程序调用 <code>exit</code> 终止该进程，那么就不需要这样做了。</li><li>每个线程都有自己的局部 <code>errno</code>，是多线程安全的。</li></ul></li><li><p>$G3$：</p><p>​    <strong>阻塞</strong>所有的信号，保护对<strong>共享全局数据结构</strong>的访问。</p></li><li><p>$G4$：</p><p>​    用 <code>volatile</code> 声明<strong>全局变量</strong>。</p><blockquote><p>用 <code>volatile</code> 类型限定符来定义一个变量，编译器就不会缓存它。用处在于：</p><ul><li>对于一个主程序和信号处理程序共享的变量 $x$，如果主程序没有对该变量进行写操作，它的值对于编译器来说就像一个定值</li><li>此时，一个优化编译器会认为使用缓存在寄存器中的副本来满足对 $x$ 的每次使用是很安全的，但是实际上信号处理程序有可能改变 $x$。</li><li>如果这样，主程序可能永远都无法看到处理程序更新过的值。使用 <code>volatile</code> 类型就可以强制让编译器不对 $x$ 进行缓存优化。</li></ul><p>例如：</p><p><code>volatile int x;</code></p><p>强迫编译器每次在代码中引用 <code>x</code> 时，都要从内存中读取 <code>x</code> 的值。</p><p>一般来说，和其他所有共享数据结构一样，应该暂时阻塞信号，保护每次对全局变量的访问。</p></blockquote></li><li><p>$G5$：</p><p>​    用 <code>sig_atomict_t</code> 声明标志。</p><blockquote><p>在常见的处理程序设计中，处理程序会写<strong>全局标志</strong>来记录收到了信号。</p><p>主程序周期性地<strong>读</strong>这个标志，响应信号，再<strong>清除</strong>（写）该标志。</p><p>对于通过这种方式来共享的标志，C 提供一种整形数据类型 <code>sig_atomic_t</code>，对它的读和写保证会是原子的（不可中 断）。</p><p>对多条指令实现的 <code>flag++</code> 和<code>flag = flag + 10</code> 不适用。</p></blockquote></li></ul></li><li><p>正确的信号处理：</p><ul><li>信号的一个与直觉不符的方面是未处理的信号是<strong>不排队</strong>的。</li><li>因为 pending 位向量中每种类型的信号只对应有一位，所以每种类型最多只能有一个未处理的信号。</li><li>所以要注意，如果存在一个未处理地信号就表明<strong>至少有一个</strong>信号到达了。</li></ul></li><li><p>可移植的信号处理</p></li></ul><h3 id="CPU-调度"><a href="#CPU-调度" class="headerlink" title="CPU 调度"></a>CPU 调度</h3><blockquote><p>整理自 PPT，《王道》和《操作系统概念》</p></blockquote><h4 id="CPU-调度概念"><a href="#CPU-调度概念" class="headerlink" title="CPU 调度概念"></a>CPU 调度概念</h4><ul><li><p>在多道程序系统中，进程的数量往往多于处理机的个数。</p></li><li><p>CPU 调度是对 CPU 并行分配，即从就绪队列中按照一定的算法（公平、高效）选择一个进程并将 CPU 分配给它运行，以实现进程并发地执行。</p></li><li><p>CPU 调度是多道程序操作系统的基础，是操作系统设计的核心问题进程调度。</p></li><li><p>遵循的原则：</p><p>​    <strong>资源高效，公平合理</strong>（两者可能存在冲突）。</p></li><li><p>CPU - I/O 执行周期：</p><ul><li>程序代码可以分为计算类代码和 I/O 类代码。</li><li>进程执行过程由 CPU 执行和 I/O 等待周期组成 CPU 区间和 I/O 区间。</li><li>CPU 约束型（密集）程序以计算为主，CPU 区间较多，还会有少量长的 CPU 区间。</li><li>I/O 约束型程序以 I/O 为主，但配合 I/O 处理有大量短的 CPU 区间。</li><li>进程通常具有<strong>大量短 CPU 区间和少量长 CPU 区间</strong>。</li></ul></li><li><p>进程调度方式：</p><blockquote><p>整理自《操作系统概念》</p><p>进程调度的时机：</p><ol><li>当一个进程从<strong>运行</strong>状态切换到<strong>阻塞</strong>状态时（例如，I/O 请求，或 <code>wait</code> 调用以便等待一个子进程的终止）</li><li>当一个进程<strong>终止</strong>时</li><li>当一个进程从<strong>运行</strong>状态切换到<strong>就绪</strong>状态时（例如，当出现时钟中断时，笔者感觉这个更像调度后的结果<span class="">😒</span>）</li><li>当一个进程从<strong>阻塞</strong>状态切换到<strong>就绪</strong>状态时（例如，I/O 完成）</li></ol></blockquote><ul><li><p>非剥夺调度方式，又称<strong>非抢占方式</strong>：</p><ul><li>仅发生在情况 $1,2$。即一旦某个进程分配到 CPU，该进程就会一直使用 CPU，直到它<strong>终止或切换到阻塞</strong>状态。</li><li><p>当一个进程正在 CPU 上执行时，即使有某个更为重要的进程进入<strong>就绪队列</strong>，仍然让正在执行的进程<strong>继续执行</strong>，直到该进程<strong>终止或切换到阻塞</strong>状态时，才把 CPU 分配给更为重要的进程。</p><blockquote><p>优点：</p><p>​    实现简单、系统开销小，适用于大多数的<strong>批处理系统</strong>，但它不能用于<strong>分时系统和大多数的实时系统</strong>。</p></blockquote></li></ul></li><li><p>剥夺调度方式，又称<strong>抢占方式</strong>：</p><ul><li>可以发生在情况 $1,2,3,4$。</li><li><p>当一个进程正在 CPU 上执行时，若有更重要的进程需要进入就绪队列，则<strong>立即暂停</strong>正在执行的进程，将 CPU 分配给这个更为重要的进程。</p><blockquote><p>采用剥夺式的调度，对<strong>提高系统吞吐率和响应效率</strong>都有明显的好处。</p><p>但「剥夺」不是一种任意性行为，必须遵循一定的原则，主要有<strong>优先权、短进程优先和时间片原则</strong>等。</p></blockquote></li></ul></li></ul></li></ul><h4 id="调度的基本准则"><a href="#调度的基本准则" class="headerlink" title="调度的基本准则"></a>调度的基本准则</h4><ul><li><p>CPU 利用率：</p><p>​    CPU 是计算机系统中最重要和昂贵的资源之一，所以应尽可能使 CPU 保持「忙」状态，使这一资源利用率最高。</p></li><li><p>系统吞吐量：</p><p>​    表示<strong>单位时间内 CPU 完成作业的数量</strong>。</p><blockquote><ul><li><strong>长作业</strong>需要消耗的处理机时间较<strong>长</strong>，因此会<strong>降低</strong>系统的吞吐量。</li><li><strong>短作业</strong>需要消耗的处理机时间较<strong>短</strong>，因此能<strong>提高</strong>系统的吞吐量。</li><li><strong>调度算法和方式</strong>的不同，也会对系统的吞吐量产生较大的影响。</li><li>系统吞吐量大 $\Leftrightarrow$ CPU 使用率高 $+$ 上下文切换代价小</li></ul></blockquote></li><li><p>周转时间：</p><p>​    周转时间是指<strong>从作业提交到作业完成</strong>所经历的时间。</p><blockquote><ul><li><p>作业的周转时间可用公式表示如下：</p><p>​    周转时间 $=$ 作业完成时间 $-$ 作业提交时间</p></li><li><p><strong>平均周转时间</strong>是指多个作业周转时间的平均值：</p><p>​    平均周转时间 $=$（作业 $1$ 的周转时间 $+\cdots+$ 作业 $n$ 的周转时间）/ $n$ </p></li></ul></blockquote></li><li><p>等待时间：</p><p>​    等待时间指<strong>进程处于等处理机状态的时间之和</strong>，等待时间越长，用户满意度越低。</p><blockquote><ul><li><p>CPU 调度算法实际上并<strong>不影响作业执行或 I/O 操作</strong>的时间，只影响作业在就绪队列中<strong>等待</strong>所花的时间。</p></li><li><p>因此衡量一个调度算法的优劣，常常只需考察等待时间。</p></li></ul></blockquote></li><li><p>响应时间：</p><p>​    响应时间指从<strong>用户提交请求到系统首次产生响应</strong>所用的时间。</p><blockquote><p>在交互式系统中，周转时间不可能是最好的评价准则，一般采用响应时间作为衡量调度算法的重要准则之一。</p><p>从用户角度来看，调度策略应尽量降低响应时间，使响应时间处在用户能接受的范围之内。</p><p>公平性：</p><p>​    合理分配 CPU，使它尽可能的「忙」。</p><p>矛盾：</p><ul><li><p>响应时间短和公平性之间的矛盾：</p><p>​    <strong>响应时间短</strong> $\Rightarrow$ <strong>前台</strong>任务的<strong>优先级高 </strong>$\Rightarrow$ <strong>后台任务</strong>得不到 CPU</p></li><li><p>吞吐量和响应时间之间的矛盾：</p><p>​    吞吐量大 $\Rightarrow$ 上下文切换代价小（尽量少切换） $\Rightarrow$ 时间片大 $\Rightarrow$ 响应时间长</p></li></ul></blockquote></li></ul><h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><ul><li><p>先到先服务（First - Come First - Served，FCFS）调度：</p><p>​    调度的顺序就是任务到达就绪队列的顺序。</p><blockquote><p>实现简单，但缺点为：</p><ul><li><p>平均等待时间往往很长，是非抢占的。</p></li><li><p>看似公平，实则对<strong>长作业</strong>比较有利，但对短作业不利（相对 SJF 调度和高响应比）</p><blockquote><p>一个先到的长作业会让短作业等待时间过长。</p></blockquote></li></ul><p>有利于 <strong>CPU 繁忙型</strong>作业，而不利于 I/O 繁忙型作业</p></blockquote></li><li><p>最短作业优先（Shortest - Job - First，SJF）调度：</p><ul><li><p>非抢占式：</p><p>​    从就绪队列中选择一个或若干<strong>估计运行时间最短</strong>的作业，将它们调入内存运行。</p></li><li><p><strong>抢占</strong> SJF 调度，又称<strong>最短剩余时间优先</strong>（Shortest - Remaining - Time - First，SRTF）调度：</p><p>​    会抢占当前运行进程，每次<strong>新进程到来或者当前进程结束</strong>时判断是否抢占当前进程。</p></li></ul><blockquote><p>在执行时间确定的情况下，平均等待时间、平均周转时间最少。</p><p>缺点：</p><ul><li>对<strong>长作业</strong>不利，导致「饥饿」</li><li>完全未考虑作业的<strong>紧迫程度</strong></li><li>运行时间为<strong>估计值</strong>，并不能反映真实运行时间，实际上可能做不到最短作业优先</li></ul></blockquote><ul><li><p>使用预测算法改进：</p><ul><li><p>可以认为下一个 CPU 执行的长度与以前的相似。</p></li><li><p>下次 $\mathrm{CPU}$ 执行通常预测为以前 $\mathrm{CPU}$ 执行的测量长度的<strong>指数平均</strong>。</p></li><li><p>设 $t_{n}$ 为第 $n$ 个 $\mathrm{CPU}$ 执行长度，设 $\tau_{n+1}$ 为下次 $\mathrm{CPU}$ 执行预测值。因此，对于 $\alpha, 0 \leqslant \alpha \leqslant 1$，定义</p><script type="math/tex; mode=display">\tau_{n+1}=\alpha t_{n}+(1-\alpha) \tau_{n}</script><p> $t_{n}$ 包括<strong>最近信息</strong>，而 $\tau_{n}$ 存储了<strong>过去历史</strong>，参数 $\alpha$ 控制最近和过去历史在预测中的<strong>权重</strong>。</p></li><li><p>如果 $\alpha=0$，那么 $\tau_{n+1}=\tau_{n}$，最近信息没有影响。</p></li><li><p>如果 $\alpha=1$，那么 $\tau_{n+1}=$ $t_{n}$，只有最近 $\mathrm{CPU}$ 执行才重要。</p></li><li><p>通常取 $\alpha=$ $1 / 2$，认为最近信息和过去历史同样重要。初始值 $\tau_{0}$ 可作为常量或系统的总体平均值。</p></li></ul></li></ul></li><li><p>优先级调度（SJF 的一般化）：</p><ul><li>每个进程都有一个<strong>优先级</strong>与其关联，而具有最高优先级的进程会分配到 CPU。</li><li><p>进程优先级的设置可以参照以下原则：</p><ul><li><strong>系统进程</strong> $&gt;$ 用户进程。系统进程作为系统的管理者，应拥有更高的优先级。</li><li><strong>交互型进程</strong> $&gt;$ 非交互型进程（前台进程 $&gt;$ 后台进程）。在<strong>前台运行</strong>的正在和用户交互的进程应<strong>更快得到响应</strong>，因此需要更高的优先级。</li><li><strong>I/O 型</strong>进程 $&gt;$ 计算型进程。I/O 型进程是指会频繁使用 I/O 设备的进程，而计算型进程是那些频繁使用 CPU 的进程。I/O 设备（如打印机）的处理速度要比 CPU 慢得多，因此若将 I/O 型进程的优先级越高，就可以让 I/O 设备<strong>越早开始工作</strong>，进而提升系统的<strong>整体效率</strong>。</li></ul></li><li><p>会导致某些低优先级进程处于<strong>饥饿</strong>状态，不能运行，可以用<strong>老化</strong>技术逐渐增加在系统中等待很长时间的进程的优先级。</p></li></ul></li><li><p>（时间片）轮询（轮转）调度（Round - Robin，RR）：</p><ul><li><p>时间片轮转调度算法主要适用于<strong>分时系统</strong>。</p><blockquote><p><a href="#操作系统的发展与分类（理解）">分时系统</a> 中，多个用户分享使用同一台计算机。</p></blockquote></li><li><p>系统将所有就绪进程按<strong>到达时间的先后</strong>次序排成一个队列，进程调度程序总是选择<strong>就绪队列中的第一个进程</strong>执行，即<strong>先来先服务</strong>的原则，但<strong>仅能运行一个时间片</strong>。</p></li><li><p>在使用完一个时间片后，进程即使未完成运行，也必须释放出 CPU 给下一个<strong>就绪</strong>的进程，然后返回到就绪队列的<strong>末尾</strong>重新排队，等候再次运行。</p></li><li><p>时间片的大小对系统性能的影响很大：</p><ul><li>若时间片足够大，以至于所有进程都能<strong>在一个时间片内执行完毕</strong>，则时间片轮转调度算法就退化为<strong>先来先服务调度算法</strong>。</li><li>若时间片很小，则 CPU 将在进程间过于频繁地切换，使处理机的<strong>开销增大</strong>，而真正用于运行用户进程的时间将减少。</li></ul></li><li><p>时间片的长短通常由以下因素确定：</p><ul><li>系统的<strong>响应时间</strong></li><li><strong>就绪队列</strong>中的<strong>进程数目</strong></li><li>系统的处理能力</li></ul></li></ul></li><li><p>多级（反馈）队列调度：</p><ul><li><p>设置多个<strong>就绪队列</strong>，并为各个队列赋予不同的优先级，第 $1$ 级队列的优先级最高，第 $2$ 级队列次之，其余队列的优先级逐次降低。</p></li><li><p>优先级越低的队列运行时间片越大，让长作业在低优先级的队列中得到更长时间的执行。</p></li><li><p>将任务按照优先级分为多个队列，每次从优先级最高的队列选择任务。</p></li><li><p>允许进程在队列之间移动，根据不同 CPU 执行的特点来区分进程。如果进程使用过多的 CPU 时间，那么它会被移到更低的优先级队列。这种方案将 <strong>I/O 密集型和交互进程放在更高优先级队列</strong>上。</p><blockquote><p>《操作系统概念》提及：</p><p>​    「在较低优先级队列中等待过长的进程会被移到更高优先级队列（老化）」</p><p>具体实现并没有给出例子，其他书也没有出现类似理解</p></blockquote></li><li><div align="center"><img src=" /img/blog/os-note-images/image-20211012132640554.png"></div><ul><li><p>最先执行队列 $0$ 的任务，队列 $0$ 为<strong>空</strong>时才执行队列 $1$，依此类推。</p></li><li><p>到达高优先级队列的任务，会<strong>抢占</strong>低优先级队列的任务。</p></li><li>一个新进程进入内存后，首先将它放入队列 $0$ 的末尾，按 FCFS 原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；否则将该进程转入队列 $1$ 的末尾。</li></ul></li><li><p>综合了前几种调度算法的优点：</p><ul><li><strong>短作业优先</strong>。</li><li><strong>周转时间较短</strong>。</li><li>经过前面几个队列得到部分执行，长批处理作业不会长期得不到处理。</li></ul></li></ul></li><li><p>彩票调度：</p><ul><li>保证每个任务都获得<strong>一定比例的 CPU 时间</strong>。</li><li>彩票数表示了任务应该接受到的资源份额</li><li>彩票数百分比表示了其所占有的系统资源份额，随着运行时间的增加，任务得到的 CPU 时间比例会越接近该百分比。</li></ul></li></ul><h3 id="CPU-优化"><a href="#CPU-优化" class="headerlink" title="CPU 优化"></a>CPU 优化</h3><blockquote><p>整理自 PPT 和 CSAPP</p></blockquote><h4 id="CPU-优化要求和影响因素"><a href="#CPU-优化要求和影响因素" class="headerlink" title="CPU 优化要求和影响因素"></a>CPU 优化要求和影响因素</h4><ul><li><p>编写高效程序要求：</p><ul><li>选择适当的算法和数据结构。</li><li>让编译器能够有效优化（编写<strong>编译器友好</strong>的代码）：<ul><li>编写程序方式中看上去只是一点小小的变动，都会引起编译器优化方式很大的变化。</li><li>在程序的<strong>可读性</strong>模块性与<strong>运行速度</strong>之间做出权衡。</li></ul></li></ul></li><li><p>编译器会受到「妨碍优化的因素」的影响：</p><ul><li><p>潜在的<strong>内存别名</strong>使用：</p><p>​    不同的指针指向同一个位置：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-keyword">long</span> *xp, <span class="hljs-keyword">long</span> *yp)</span> </span>{<br>*xp += *yp; <br>*xp += *yp<br>}<br><span class="hljs-keyword">void</span> fun2(<span class="hljs-keyword">long</span> *xp, <span class="hljs-keyword">long</span> *yp) {<br>*xp += <span class="hljs-number">2</span>* *yp; <br>}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* fun2 读写次数比 fun1 少,看起来功能一样,但当 yp 和 xp 指向同一内存单元时,结果会不同</span><br><span class="hljs-comment">* 我们希望编译器可以将 fun1 优化成 fun2,但是编译器要进行安全的优化,所以必须假设存在上面这种特殊情况,故妨碍了优化。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>潜在的<strong>函数副作用</strong>：</p><p>​    可能修改了全局程序状态</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">long</span> counter=<span class="hljs-number">0</span>;      <span class="hljs-comment">//全局变量</span><br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> counter++; <br>}<br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> f()+f()+f()+f();<br>} <br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">fun2</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> <span class="hljs-number">4</span>*f();    <span class="hljs-comment">// 与 fun1 在该情况下不等效,妨碍编译器优化</span><br>}<br><span class="hljs-comment">// 内联函数替换 fun1,减少函数调用的开销</span><br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">fun1inline</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">long</span> t=counter++; <br>    t+=counter++;<br>t+=counter++; <br>    t+=counter++; <br>    <span class="hljs-keyword">return</span> t;<br>}<br></code></pre></td></tr></tbody></table></figure></li></ul></li><li><p>编译器优化选项：</p><ul><li><code>-Og</code> 使用一组基本的优化。</li><li><code>-O1</code> 有限的保守的优化。</li><li><code>-O2</code> 适中的优化，对大多数项目来说，是可接受的标准。</li><li><code>-O3</code> 更激进的优化，提高性能，增加规模，调试工具更难调试。</li></ul></li><li><p>每元素的周期（Cycles Per Element，CPE）：</p><p>​    用来评价循环性能，并不是实际上一个元素占用的时钟周期数，是个平均指标。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">psum1</span><span class="hljs-params">(<span class="hljs-keyword">float</span> a[], <span class="hljs-keyword">float</span> p[], <span class="hljs-keyword">long</span> n)</span> </span>{<br><span class="hljs-keyword">long</span> i; <br>    p[<span class="hljs-number">0</span>] = a[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; n; i++) <br>        p[i] = p[i-l] + a[i];<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">psum2</span><span class="hljs-params">(<span class="hljs-keyword">float</span> a[], <span class="hljs-keyword">float</span> p[], <span class="hljs-keyword">long</span> n)</span> </span>{<br><span class="hljs-keyword">long</span> i;<br>    p[<span class="hljs-number">0</span>] = a[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; n<span class="hljs-number">-1</span>; i+=<span class="hljs-number">2</span>) { <br>        p[i] = p[i<span class="hljs-number">-1</span>] + a[i]; <br>        p[i+l] = p[i] + a[i+l]; <br>    }<br><span class="hljs-comment">/* For even n, finish remaining element */</span><br>    <span class="hljs-keyword">if</span> (i &lt; n)<br>        p[i] = p[i-l] + a[i]; <br>}<br></code></pre></td></tr></tbody></table></figure><ul><li><code>psum2</code> 使用了循环展开的技术，CPE 比 <code>psum1</code> 要低，即每个元素需要的时钟周期数要比 <code>psum1</code> 要少，效率更高。</li><li>$T($ 运行时间 $) = CPE\times n ~+$ 基本的周期开销</li></ul></li></ul><h4 id="利用指令级并行进行优化"><a href="#利用指令级并行进行优化" class="headerlink" title="利用指令级并行进行优化"></a>利用指令级并行进行优化</h4><blockquote><p>其实没太懂这些数是怎么得到的，感觉不怎么能考，听说有的班直接没讲<span class="">😢</span></p></blockquote><ul><li><p>现代计算机的设计：</p><ul><li>硬件可以<strong>并行执行</strong>多个指令（每个时钟周期执行多个操作，乱序）。</li><li>性能受<strong>数据依赖</strong>的限制。</li><li>简单的转换可以带来显著的性能改进：<ul><li>编译器通常无法进行这些转换。</li><li>浮点运算缺乏结合性和可分配性。</li></ul></li></ul></li><li><p>超标量定义：</p><p>​    <strong>超标量</strong>指可以在每个时钟周期执行多个操作，而且是乱序的（指令执行的顺序与它们在机器级程序中的顺序可能不一样）。</p></li><li><p>名词定义：</p><blockquote><p>Haswell 架构的 CPU 各模块数量：</p><ul><li>$2$ 个加载功能模块</li><li>$1$ 个存储</li><li>$4$ 个整数运算 </li><li>$2$ 个浮点乘法运算 </li><li>$1$ 个浮点加法 </li><li>$1$ 个浮点除法</li></ul></blockquote><ul><li><p>延迟：</p><p>​    <strong>完成运算</strong>所需要的时钟周期总数。</p></li><li><p>发射时间：</p><p>​    <strong>连续同类型运算</strong>之间间隔<strong>最小周期数</strong>。发射为 $1$ 意味着同类运算间不用等待。</p></li><li><p>容量：</p><p>​    能够<strong>执行该运算的功能单元数量</strong>，即同时能发射多少这样运算。</p></li><li><p>延迟界限：</p><p>​    一种运算的延迟为 $n$，意味着需要 $n$ 个时钟周期执行这种运算，当<strong>顺序执行</strong>时，无论怎样优化，其 CPE 的下限不会低于延迟界限。</p></li><li><p>吞吐量界限：</p><p>​    CPE 的<strong>最小界限</strong>，假设执行某种运算的功能单元（<strong>容量</strong>）有 $k$ 个（还要受限于<strong>地址加载单元数量</strong>），其<strong>发射</strong>为 $n$，则<strong>吞吐量界限</strong>为 $\begin{aligned}\frac{n}{k}\end{aligned}$。</p><blockquote><p>这里忽略延迟，其实是当延迟为 $1$ 算，这样缩放可以让这个值成为真正的极限，无论怎么优化，CPE 都不可能比吞吐量界限小。</p></blockquote><p><img src="/img/blog/os-note-images/image-20211012222645387.png" alt="image-20211012222645387"></p></li></ul></li><li><p>运算重组：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span></span>{<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; limit; i++) <br>        x = x OP d[i];<br>}<br><br><span class="hljs-comment">// 2*1</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">()</span></span>{<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; limit; i+=<span class="hljs-number">2</span>) <br>        x = (x OP d[i]) OP d[i+<span class="hljs-number">1</span>];<br>}<br><br><span class="hljs-comment">// 2*1a</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun3</span><span class="hljs-params">()</span></span>{<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; limit; i+=<span class="hljs-number">2</span>) <br>        x = x OP (d[i] OP d[i+<span class="hljs-number">1</span>]); <span class="hljs-comment">// 消除了一个数据依赖,可以提前算 d[i] OP d[i+1],实现并行</span><br>}<br><br><span class="hljs-comment">// 2*2</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun4</span><span class="hljs-params">()</span></span>{<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; limit; i+=<span class="hljs-number">2</span>) <br>        x0 = x0 OP d[i],<br>        x1 = x1 OP d[i+<span class="hljs-number">1</span>];<br>}<br></code></pre></td></tr></tbody></table></figure></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">整数</th><th style="text-align:center">整数</th><th style="text-align:center">浮点数</th><th style="text-align:center">浮点数</th><th style="text-align:center">优化原因</th></tr></thead><tbody><tr><td style="text-align:center">操作</td><td style="text-align:center">$+$</td><td style="text-align:center">$\times$</td><td style="text-align:center">$+$</td><td style="text-align:center">$\times$</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>fun1</code></td><td style="text-align:center">$1.27$</td><td style="text-align:center">$3.01$</td><td style="text-align:center">$3.01$</td><td style="text-align:center">$5.01$</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>fun2(2*1)</code></td><td style="text-align:center">$1.01$</td><td style="text-align:center">$3.01$</td><td style="text-align:center">$3.01$</td><td style="text-align:center">$5.01$</td><td style="text-align:center">整数加法减少了循环开销（一次循环也需要一次整数加法），<br>但是和其他运算一样不能突破<strong>延迟界限</strong></td></tr><tr><td style="text-align:center"><code>fun3(2*1a)</code></td><td style="text-align:center">$1.01$</td><td style="text-align:center">$1.51$</td><td style="text-align:center">$1.51$</td><td style="text-align:center">$2.51$</td><td style="text-align:center">这里整数加法并没有得到优化，<br>猜想编译器只用到了一个整数加功能模块，<br>所以对于延迟为 $1$ 的整数加没有提升</td></tr><tr><td style="text-align:center"><code>fun4(2*2)</code></td><td style="text-align:center">$0.81$</td><td style="text-align:center">$1.51$</td><td style="text-align:center">$1.51$</td><td style="text-align:center">$2.51$</td><td style="text-align:center">用到了 $2$ 个整数加功能模块，<br>其他操作因为循环开销，延迟和数据依赖的问题，<br>在单个功能模块时已达到性能极限</td></tr><tr><td style="text-align:center">延迟界限</td><td style="text-align:center">$1.00$</td><td style="text-align:center">$3.00$</td><td style="text-align:center">$3.00$</td><td style="text-align:center">$5.00$</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">吞吐量界限</td><td style="text-align:center">$0.50$</td><td style="text-align:center">$1.00$</td><td style="text-align:center">$1.00$</td><td style="text-align:center">$0.50$</td><td style="text-align:center"></td></tr></tbody></table></div><ul><li><p>达到某操作的吞吐量界限所要求的<strong>循环展开因</strong>子：</p><p>​    达到时，要保持执行该操作的所有功能单元的<strong>流水线都是满</strong>的（即发射为 $1$），对延迟为 $L$，容量为 $C$ 的操作而言，循环展开因子满足 $k\ge CL$。</p></li></ul><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h3><blockquote><p>整理自 PPT，CSAPP 和《王道》</p></blockquote><h4 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h4><blockquote><p>引入进程的目的是更好地使多道程序并发执行，提高资源利用率和系统吞吐量。</p></blockquote><ul><li><p>引入线程的目的是<strong>减小程序在并发执行时所付出的时空开销</strong>，提高操作系统的并发性能。</p></li><li><p>线程可理解为「轻量级进程」，它是一个基本的 CPU 执行单元，也是程序执行流的<strong>最小单元</strong>，由线程 ID、程序计数器、寄存器集合和堆栈组成。</p><blockquote><p>线程包含 CPU 现场，可以独立执行程序</p></blockquote></li><li><p>线程是进程中的一个实体，是被<strong>系统独立调度和分派的基本单位</strong>，是进程内一个<strong>相对独立的可调度的执行单元</strong>。</p></li><li><p>线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其他线程<strong>共享进程</strong>所拥有的全部资源。</p></li><li><p>一个线程可以创建和撤销另一个线程，<strong>同一进程</strong>中的<strong>多个线程</strong>之间可以<strong>并发</strong>执行。</p></li><li><p>由于线程之间的相互制约，致使线程在运行中呈现出<strong>间断性</strong>，也有就绪、阻塞和运行三种基本状态。</p></li><li><p>引入线程后，进程只作为除 CPU 外的<strong>系统资源的分配单元</strong>，而线程则作为<strong>处理机的分配单元</strong>。</p></li><li><p>由于一个进程内部有多个线程，若线程的切换发生在同一个进程内部，则只需要<strong>很少的时空开销</strong>。</p></li></ul><blockquote><p>进程与线程的比较：</p><ul><li><p>调度：</p><ul><li>在传统的操作系统中，拥有资源和独立调度的基本单位都是进程。</li><li>在引入线程的操作系统中，<strong>线程是独立调度的基本单位</strong>，<strong>进程是拥有资源的基本单位</strong>。</li><li>在同一进程中，线程的切换不会引起进程切换。</li><li><strong>在不同进程中进行线程切换，如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换</strong>。</li></ul><blockquote><p>由于有了线程，线程切换时，有可能会发生进程切换，也有可能不发生进程切换，平摊下来<strong>每次切换所需的开销就变小</strong>了，因此能够让更多的线程参与并发，而不会影响到<strong>响应时间</strong>等问题。</p></blockquote></li><li><p>拥有资源：</p><p>​    不论是传统操作系统还是设有线程的操作系统，<strong>进程</strong>都是<strong>拥有资源</strong>（资源分配）的基本单位，而线程不拥有系统资源（只有一点必要的资源），但线程可以访问其隶属进程的系统资源。</p><blockquote><p>若线程也是拥有资源的单位，则切换线程就需要较大的时空开销，线程这个概念的提出就没有意义。</p></blockquote></li><li><p>并发性：</p><p>​    在引入线程的操作系统中，不仅进程之间可以并发执行，而且<strong>多个线程之间也可以并发执行</strong>，从而使操作系统具有更好的并发性，提高了系统的吞吐量。</p></li><li><p>系统开销：</p><ul><li>由于创建或撤销<strong>进程</strong>时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，因此操作系统所付出的开销远大于创建或撤销线程时的开销。</li><li>在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度到进程 CPU 环境的设置，而线程切换时<strong>只需保存和设置少量寄存器内容</strong>，开销很小。</li><li>由于同一进程内的多个线程<strong>共享</strong>进程的<strong>地址空间</strong>，因此这些<strong>线程之间的同步与通信</strong>非常容易实现，甚至无须操作系统的干预。</li></ul></li><li><p>地址空间和其他资源（如打开的文件）：</p><p>​    进程的地址空间之间互相独立，同一进程的各线程间共享进程的资源，某进程内的线程对于其他进程不可见。</p></li><li><p>通信方面：</p><p>​    进程间通信（IPC）需要进程同步和互斥手段的辅助，以保证数据的一致性，而线程间可以直接读/写进程数据段（如全局变量）来进行通信。</p></li><li><p>关系：</p><ul><li>线程不像进程那样，不是按照严格的父子层次来组织的。</li><li>和一个进程相关的线程组成一个<strong>对等（线程）池</strong>，独立于其他线程创建的线程。</li><li><strong>主线程</strong>和其他线程的区别仅在于它总是进程中第一个运行的线程。</li><li>对等（线程）池概念的主要影响是，一个线程可以杀死它的任何对等线程，或者等待它的任意对等线程终止，都能读写相同的共享数据。</li></ul></li></ul></blockquote><h3 id="线程的实现方式（理解）"><a href="#线程的实现方式（理解）" class="headerlink" title="线程的实现方式（理解）"></a>线程的实现方式（理解）</h3><ul><li><p>线程的实现分为两类：</p><p>​    <strong>用户级线程</strong>（User-Level Thread，ULT）和<strong>内核级线程</strong>（Kernel-Level Thread，KLT），内核级线程又称<strong>内核支持的线程</strong>。</p></li><li><p>用户级线程：</p><ul><li>有关线程管理（线程的创建、撤销和切换等）的所有工作都由<strong>应用程序</strong>完成，内核意识不到线程的存在。</li><li>应用程序可以通过使用线程库设计成<strong>多线程程序</strong>。</li><li>应用程序从<strong>单线程（主线程）</strong>开始，在该线程中开始运行，在其运行的任何时刻，可以通过调用线程库中的派生例程创建一个在相同进程中运行的<strong>新线程（对等线程）</strong>。</li></ul></li><li><p>内核级线程：</p><ul><li>在内核级线程中，线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只有一个到内核级线程的编程接口。</li><li>内核为进程及其内部的每个线程维护上下文信息，调度也在内核基于线程架构的基础上完成。</li></ul></li><li><p>组合：</p><ul><li><p>有些系统中使用组合方式的<strong>多线程实现</strong>。线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行。</p></li><li><p>一个应用程序中的多个用户级线程被<strong>映射</strong>到一些（小于等于用户级线程的数目）内核级线程上。</p><blockquote><p>组合模式的多线程模型：</p><ul><li><p>多对一模型：</p><p>​    将多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。此模式中，<strong>用户级线程对操作系统不可见</strong>（即<strong>透明</strong>，a 对 b 透明在计算机领域是在 b 的角度 a 不可见的意思）。</p><ul><li><p>优点：</p><p>​    线程管理是在用户空间进行的，效率高，<strong>相同映射</strong>的<strong>用户级线程</strong>之间的切换不需要在内核级中切换。</p></li><li><p>缺点：</p><ul><li><strong>一个线程在使用内核服务时被阻塞，整个进程都会被阻塞</strong></li><li>任一时间只有一个线程可以访问内核，导致多个线程<strong>不能并行</strong>地运行在多处理机上。</li></ul></li></ul></li><li><p>一对一模型：</p><p>​    将每个用户级线程映射到一个内核级线程。</p><ul><li><p>优点：</p><p>​    当一个线程被阻塞后，允许另一个线程继续执行，所以<strong>并发能力</strong>较强。</p></li><li><p>缺点：</p><p>​    每创建一个用户级线程都需要创建一个内核级线程与其对应，这样创建线程的<strong>开销</strong>比较大，会影响到应用程序的性能</p></li></ul></li><li><p>多对多模型：</p><p>​    将 $n$ 个用户级线程映射到 $m$ 个内核级线程上，要求 $n\ge m$。集前两者之所长。</p></li></ul></blockquote></li></ul></li></ul><h4 id="Posix-线程"><a href="#Posix-线程" class="headerlink" title="Posix 线程"></a>Posix 线程</h4><ul><li><p>Posix 线程（Pthreads）是在 C 程序中处理线程的一个标准接口，在所有的 Linux 系统上都可用。</p></li><li><p>Pthreads 定义了大约 $60$ 个函数，允许程序<strong>创建、杀死和回收</strong>线程，与对等线程<strong>安全地共享数据</strong>，还可以<strong>通知</strong>对等线程系统状态的变化。</p></li><li><p>创建线程：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 若创建成功则返回 0, 若出错则为非零。</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_create</span><span class="hljs-params">(<span class="hljs-keyword">pthread_t</span> *tid,          <span class="hljs-comment">// 新创建线程的 ID</span></span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-keyword">pthread_attr_t</span> *attr,    <span class="hljs-comment">// 设置新创建线程的属性,为 NULL 就好</span></span></span><br><span class="hljs-params"><span class="hljs-function">                   func *f,                 <span class="hljs-comment">// 创建线程后将执行的程序（线程例程）</span></span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-keyword">void</span> *arg)</span></span><br><span class="hljs-function"><span class="hljs-comment">// arg 是一个可以传递给开始程序的参数。它必须作为空类型的指针强制转换通过引用传递。如果不传递任何参数，则可以使用 NULL。</span></span><br></code></pre></td></tr></tbody></table></figure><p>新线程可以调用 <code>pthread_self(void)</code> 来获得它自己的线程 ID。</p><blockquote><p>CSAPP 中使用<strong>线程例程</strong>的概念：</p><ul><li>线程的<strong>代码和本地数据</strong>被封装在一个线程例程（thread routine）中。</li><li>每个线程例程都以一个<strong>通用指针作为输入</strong>，并返回一个通用指针。</li></ul></blockquote></li><li><p>终止线程：</p><ul><li><p>隐式终止：</p><ul><li>当顶层的<strong>线程例程返回</strong>时，线程会隐式地终止。</li><li>所属进程</li></ul></li><li><p>显式终止：</p><p>​    通过调用 <code>pthread_exit</code> 函数，线程会显式地终止。如果主线程调用 <code>pthread_exit</code>，它会<strong>等待</strong>所有其他<strong>对等线程</strong>终止，然后再终止主线程和整个进程，返回值为 <code>thread_return</code>。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 无返回值</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pthread_exit</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *thread_return)</span></span>;<br></code></pre></td></tr></tbody></table></figure></li></ul></li><li><p>阻塞线程：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 若创建成功则返回 0, 若出错则为非零。</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_join</span><span class="hljs-params">(<span class="hljs-keyword">pthread_t</span> tid, <span class="hljs-keyword">void</span> **thread_return)</span></span><br></code></pre></td></tr></tbody></table></figure><ul><li><code>pthread-join</code> 函数会阻塞当前线程，直到线程 <code>tid</code> 终止，将线程例程返回的通用 <code>(void*)</code> 指针赋值为 <code>thread-return</code> 指向的位置，然后回收已终止线程占用的所有内存资源。</li><li>不同于 <code>wait</code>，<code>pthread_join</code> 只能等待<strong>一个指定的线程</strong>终止。</li></ul></li><li><p>分离线程：</p><ul><li><p>在任何一个时间点上，线程是可结合的（joinable）或者是分离的（detached）。</p></li><li><p>一个可结合的线程能够<strong>被其他线程收回和杀死</strong>。在<strong>被其他线程回收之前</strong>，它的内存资源（例如栈）是不释放的。</p></li><li><p>而一个分离的线程是不能被其他线程回收或杀死的。它的内存资源在<strong>它终止时由系统自动释放</strong>。</p></li><li><p>默认情况下，线程<strong>被创建成可结合的</strong>。为了避免内存泄漏，每个可结合线程都应该要么被其他线程显式地收回，要么通过调用 <code>pthread detach</code> 函数被分离。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 若创建成功则返回 0, 若出错则为非零。</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_detach</span><span class="hljs-params">(<span class="hljs-keyword">pthread_t</span> tid)</span></span>;<br></code></pre></td></tr></tbody></table></figure></li></ul></li></ul><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><blockquote><p>也有叫进程同步，应该没区别吧<span class="">👶</span></p><p>整理自 PPT 和《王道》，《王道》题目量巨大</p></blockquote><h4 id="线程内存模型"><a href="#线程内存模型" class="headerlink" title="线程内存模型"></a>线程内存模型</h4><ul><li><p>一组<strong>并发线程</strong>运行在一<strong>个进程的上下文</strong>中。</p></li><li><p>每个线程都有它自己<strong>独立</strong>的<strong>线程上下文</strong>，包括<strong>线程 ID、栈、栈指针、程序计数器、条件码和通用目的寄存器值</strong>。</p></li><li><p>每个线程和其他线程一起<strong>共享</strong>进程上下文的<strong>剩余部分</strong>。</p><blockquote><p>共享区域：</p><ul><li>整个用户虚拟地址空间，它是由只读文本（代码）、读/写数据、堆以及所有的共享库代码和数据区域组成的。</li><li>线程也共享相同的打开文件的集合。</li></ul></blockquote></li><li><p>寄存器是从不共享的，而虚拟内存总是共享的。</p></li><li><p>变量映射到虚拟内存：</p><ul><li><p>全局变量：</p><ul><li>全局变量是定义在<strong>函数之外</strong>的变量。</li><li>在运行时，虚拟内存的读/写区域<strong>只包含</strong>每个全局变量的<strong>一个实例</strong>，任何线程都可以引用。</li></ul></li><li><p>本地自动变量：</p><ul><li>本地自动变量就是定义在函数内部但是<strong>没有 static 属性</strong>的变量。</li><li>在运行时，每个线程的<strong>栈</strong>都包含它自己的所有本地自动变量的实例。即使多个线程执行同一个线程例程时也是如此。</li></ul></li><li><p>本地静态变量：</p><ul><li>本地静态变量是定义在函数内部并<strong>有 static 属性</strong>的变量。</li><li>和全局变量一样，虚拟内存的读/写区域只包含在程序中声明的每个本地静态变量的<strong>一个实例</strong>。</li></ul></li><li><p>共享变量：</p><p>​    共享变量的一个实例被<strong>一个以上的线程</strong>引用。</p><blockquote><p><strong>本地自动变量也能被共享</strong>，可能被其他线程通过指针间接引用。</p></blockquote></li></ul></li></ul><h4 id="同步问题"><a href="#同步问题" class="headerlink" title="同步问题"></a>同步问题</h4><ul><li><p>五个阶段：</p><ul><li><p>$H_{i}$：</p><p>​    在循环头部的指令块。</p></li><li><p>$L_{i}$（load）：</p><p>​    加载共享变量 $cnt$ 到累加寄存器 $\mathrm{rdx}_{i}$ 的指令, 这里 $\mathrm{rdx}_{i}$ 表示线程 $i$ 中的寄存器 $\mathrm{rdx}_{i}$ 的值。</p></li><li><p>$U_i$（update）：</p><p>​    更新（增加）$\mathrm{rdx}_{i}$。</p></li><li><p>$S_{i}$（store）：</p><p>​    将 $\mathrm{rdx}_{i}$ 的更新值存回到共享变量 $cnt$ 的指令。</p></li><li><p>$T_{i}$：</p><p>​    循环尾部的指令块。</p></li></ul></li><li><p>进度图：</p><ul><li><p><strong>进度图</strong>将 $n$ 个并发线程的执行模型化为一条 $n$ 维笛卡儿空间中的轨迹线。</p></li><li><p>每条轴 $k$ 对应于线程 $k$ 的进度。</p></li><li><p>每个点 $\left(I_{1}, I_{2}, \cdots, I_{n}\right)$ 代表线程 $k(k=1, \cdots, n)$ 已经<strong>完成</strong>了指令 $I_{k}$ 这一状态。</p></li><li><p>图的<strong>原点</strong>对应于<strong>没有任何线程完成一条指令</strong>的初始状态。</p></li><li><p>进度图将指令执行模型化为从一种状态到另一种状态的<strong>转换</strong>。</p></li><li><p>转换被表示为一条从一点到相邻点的<strong>有向边</strong>。向下或者向左移动的转换也是不合法的。</p></li><li><p>对于线程 $i$，操作共享变量 $cnt$ 内容的指令 $\left(L_{i}, U_{i}, S_{i}\right)$ 构成了一个（关于共享变量 $cnt$ 的）<strong>临界区</strong>（critical section），这个临界区<strong>不应该和其他进程的临界区交替执行</strong>。</p><blockquote><p><strong>临界区</strong>是指进程中用于访问<strong>临界资源</strong>的<strong>那段代码</strong>。</p></blockquote></li><li><p>想要确保每个线程在执行它的临界区中的指令时, 拥有对共享变量的<strong>互斥的访问</strong>，这种现象称为互斥。</p></li><li><p>在进度图中, 两个临界区的交集形成的状态空间区域称为<strong>不安全区</strong>。</p><blockquote><p>不安全区和与它交界的状态相毗邻，但<strong>并不包括这些状态</strong>。</p><p>例如，状态 $\left(H_{1}, H_{2}\right)$ 和 $\left(S_{1}, U_{2}\right)$ 毗邻不安全区，但是它们并不是不安全区的一部分。</p><p>绕开不安全区的轨迹线叫做安全轨迹线，接触到任何不安全区的轨迹线就叫做不安全轨迹线。</p><div align="center"><img src=" /img/blog/os-note-images/image-20210921211420273.png" alt="image-20210921211420273"></div></blockquote></li></ul></li></ul><ul><li><p>同步与互斥：</p><ul><li><p>同步（<strong>直接制约</strong>关系）定义：</p><ul><li><p><strong>同步</strong>指为完成某种任务而建立的<strong>两个或多个进程</strong>，这些进程因为需要在某些位置上协调它们的工作次序而<strong>等待、传递</strong>信息所产生的制约关系。</p></li><li><p>进程间的直接制约关系<strong>源于它们之间的相互合作</strong>。</p><blockquote><p>例如：</p><ul><li>输入进程 A 通过单缓冲向进程 B 提供数据。</li><li><p>当该缓冲区空时，进程 B 不能获得所需数据而阻塞，一旦进程 A 将数据送入缓冲区，进程 B 就被唤醒。</p></li><li><p>当缓冲区满时，进程 A 被阻塞，仅当进程 B 取走缓冲数据时，才唤醒进程 A。</p></li></ul></blockquote></li></ul></li><li><p>互斥（<strong>间接制约</strong>关系）定义：</p><ul><li><p>当一个进程进入临界区<strong>使用临界资源</strong>时，另一个进程必须<strong>等待</strong>。</p></li><li><p>当占用临界资源的进程<strong>退出</strong>临界区后，另一进程才允许去访问此临界资源。</p></li><li><p>进程间的间接制约关系<strong>源于它们之间对临界资源的相互竞争</strong>。</p><blockquote><p>例如：</p><ul><li>在仅有一台打印机的系统中，有两个进程 A 和进程 B。</li><li>若进程 A 需要打印时，系统已将打印机<strong>分配</strong>给进程 B，则进程 A 必须<strong>阻塞</strong>。</li><li>一旦进程 B 将打印机<strong>释放</strong>，系统便将进程 A <strong>唤醒</strong>，并将其由<strong>阻塞态变为就绪态</strong>。</li></ul></blockquote></li></ul></li><li><p>为禁止两个进程<strong>同时进入</strong>临界区，同步机制应遵循以下准则：</p><ul><li><p>空闲让进：</p><p>​    临界区<strong>空闲</strong>时，可以<strong>允许</strong>一个<strong>请求进入临界区</strong>的进程立即<strong>进入</strong>临界区。</p></li><li><p>忙则等待：</p><p>​    当<strong>已有进程</strong>进入临界区时，其他试图进入临界区的进程必须<strong>等待</strong>。</p></li><li><p>有限等待：</p><p>​    对请求访问的进程，应保证能在<strong>有限时间</strong>内进入临界区（不一直等待）。</p></li><li><p>让权等待：</p><p>​    当进程<strong>不能进入</strong>临界区时，应立即<strong>释放</strong>处理器，防止进程忙等待。</p></li></ul></li></ul></li></ul><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><ul><li>信号量 $s$ 是具有非负整数值的全局变量，只能由两种特殊的操作来处理，这两种操作称为 $P$ 和 $V$ :</li></ul><ul><li><p>$P(s)$ : </p><ul><li>如果 $s$ 是非零的，那么 $P$ 将 $s$ 减 $1$，并且<strong>立即返回</strong>。</li><li>如果 $s$ 为零，那么就<strong>挂起这个线程</strong>，直到 $s$ 变为非零，而一个 $V$ 操作会<strong>重启</strong>这个线程。</li><li>在重启之后，$P$ 操作将 $s$ 减 $1$，并将控制返回给调用者。</li></ul></li><li><p>$V(s)$：</p><ul><li><p>$V$ 操作将 $s$ 加 1。</p></li><li><p>如果有任何线程<strong>阻塞</strong>在 $P$ 操作等待</p></li><li><p>$s$ 变成非零，那么 $V$ 操作会<strong>重启</strong>这些线程中的一个，然后该线程将 $s$ 减 $1$，完成它的 $P$ 操作。</p><blockquote><p>CSAPP 和《操作系统概念》的定义不一样，以后者为准：</p><ul><li><p>CSAPP：</p><p>​    $V$ 的定义中没有定义等待线程被重启动的顺序。唯一的要求是 $V$ 必须只能重启一个正在等待的线程。因此，当有多个线程在等待同一个信号量时，不能预测 $V$ 操作要重启哪一个线程。</p></li><li><p>《操作系统概念》：</p><p>​    $V$ 操作是排队唤醒的。</p></li></ul></blockquote></li></ul></li><li><p>Posix 函数：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">P</span><span class="hljs-params">(<span class="hljs-keyword">sem_t</span> *s)</span></span>;<span class="hljs-comment">/* Wrapper function for sem_wait */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-keyword">sem_t</span> *s)</span></span>;<span class="hljs-comment">/* Wrapper function for sem_post */</span><br></code></pre></td></tr></tbody></table></figure><ul><li><p>信号量提供了一种很方便的方法来确保对共享变量的互斥访问：</p><p>​    基本思想是将<strong>每个共享变量</strong>（或者一组相关的共享变量）与一个信号量 $s$（一般<strong>初始为 $1$</strong>）联系起来, 然后用 $P(s)$ 和 $V$ $(s)$ 操作将相应的<strong>临界区包围</strong>起来。</p><blockquote><p>利用信号量不变性：</p><p>​    一个正确初始化的信号量不会出现负值，而出现负值的点在不安全区里面。</p><div align="center"><img src=" /img/blog/os-note-images/image-20210921221906980.png" alt="image-20210921221906980"></div></blockquote></li></ul></li></ul><ul><li><p>以这种方式来保护共享变量的信号量叫做<strong>二元信号量</strong>，因为它的值总是 $0$ 或者 $1$。</p></li><li><p>以提供互斥为目的的二元信号量常常也称为<strong>互斥锁</strong>（mutex）。</p></li><li><p>在一个互斥锁上执行 $P$ 操作称为对互斥锁<strong>加锁</strong>，执行 $V$ 操作称为对互斥锁<strong>解锁</strong>。</p></li><li><p>对一个互斥锁加了锁但是还没有解锁的线程称为<strong>占用</strong>这个互斥锁。</p></li><li><p>一个被用作<strong>一组可用资源的计数器</strong>的信号量被称为<strong>计数信号量</strong>。</p><blockquote><p>除了提供互斥之外，信号量的另一个重要作用是<strong>调度对共享资源的访问</strong>。</p><p>在这种场景中，一个线程用信号量操作来<strong>通知</strong>另一个线程，程序状态中的<strong>某个条件已经为满足</strong>了。</p><p>两个经典而有用的例子是生产者 - 消费者和读者 - 写者问题</p></blockquote></li></ul><h4 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者 - 消费者问题"></a>生产者 - 消费者问题</h4><ul><li><p>生产者和消费者线程共享一个有 <strong>$n$ 个槽的有限缓冲区</strong>。</p></li><li><p><strong>生产者线程</strong>反复地<strong>生成</strong>新的项目，并把它们插入到缓冲区中。</p></li><li><p><strong>消费者线程</strong>不断地从缓冲区中取出这些项目，然后消费（使用）它们。</p></li><li><p>因为插入和取出项目都涉及<strong>更新共享变量</strong>，所以我们必须保证对缓冲区的访问是<strong>互斥</strong>的，不能同时插入和取出。</p></li><li><p>但是只保证互斥访问是不够的，我们还需要<strong>调度对缓冲区的访问</strong>：</p><ul><li><p>如果缓冲区是<strong>满的（没有空的槽位）</strong>，那么<strong>生产者</strong>必须<strong>等待</strong>直到有一个槽位变为可用。</p></li><li><p>如果缓冲区是<strong>空的（没有可取用的项目）</strong>，那么<strong>消费者</strong>必须<strong>等待</strong>直到有一个项目变为可用。</p><blockquote><p>例子：</p><ul><li>在一个多媒体系统中，生产者编码视频帧，而消费者解码并在屏幕上呈现出来。缓冲区的目的是为了减少视频流的抖动，而这种抖动是由各个帧的编码和解码时与数据相关的差异引起的。缓冲区为生产者提供了一个槽位池，而为消费者提供一个已编码的帧池。</li><li>另一个常见的示例是图形用户接口设计。生产者检测到鼠标和键盘事件，并将它们插入到缓冲区中。消费者以某种基于优先级的方式从缓冲区取出这些事件，并显示在屏幕上。</li></ul></blockquote></li></ul></li><li><p>代码实现：</p><ul><li><p>定义结构体：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span> <br>  <span class="hljs-keyword">int</span> *buf;    <span class="hljs-comment">/* 缓冲区数组 */</span> <br>  <span class="hljs-keyword">int</span> n;                   <span class="hljs-comment">/* 最大槽位数 */</span><br>  <span class="hljs-keyword">int</span> front;               <span class="hljs-comment">/* buf[(front+1)%n] 是第一个项目 */</span><br>  <span class="hljs-keyword">int</span> rear;                <span class="hljs-comment">/* buf[rear%n] 是最后一个项目 */</span><br>  <span class="hljs-keyword">sem_t</span> mutex;             <span class="hljs-comment">/* 二元信号量：确保互斥地访问缓冲区 */</span><br>  <span class="hljs-keyword">sem_t</span> slots;             <span class="hljs-comment">/* 计数信号量：计数缓冲区中可用的槽位 */</span> <br>  <span class="hljs-keyword">sem_t</span> items;             <span class="hljs-comment">/* 计数信号量：计数缓冲区中可用的项目 */</span><br>} <span class="hljs-keyword">sbuf_t</span>;<br></code></pre></td></tr></tbody></table></figure></li><li><p>生产者插入项目到缓冲区：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sbuf_insert</span><span class="hljs-params">(<span class="hljs-keyword">sbuf_t</span> *sp, <span class="hljs-keyword">int</span> item)</span> </span>{<br>  P(&amp;sp-&gt;slots);                        <span class="hljs-comment">/* 等待可用槽位,与缓冲区加锁顺序不能换,否则消费者取不出项目,生产者也只能死等*/</span><br>  P(&amp;sp-&gt;mutex);                        <span class="hljs-comment">/* 给缓冲区加锁*/</span><br>  sp-&gt;buf[(++sp-&gt;rear)%(sp-&gt;n)] = item; <span class="hljs-comment">/* 插入项目*/</span><br>  V(&amp;sp-&gt;mutex);                        <span class="hljs-comment">/* 解锁缓冲区*/</span><br>  V(&amp;sp-&gt;items);                        <span class="hljs-comment">/* 宣告这里有可用的项目 */</span><br>} <br></code></pre></td></tr></tbody></table></figure></li><li><p>消费者从缓冲区取走项目：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sbuf_remove</span><span class="hljs-params">(<span class="hljs-keyword">sbuf_t</span> *sp)</span> </span>{<br>  <span class="hljs-keyword">int</span> item; <br>  P(&amp;sp-&gt;items);                          <span class="hljs-comment">/* 等待可用项目*/</span><br>  P(&amp;sp-&gt;mutex);                          <span class="hljs-comment">/* 给缓冲区加锁*/</span><br>  item = sp-&gt;buf[(++sp-&gt;front)%(sp-&gt;n)];  <span class="hljs-comment">/* 移除项目 */</span> <br>  V(&amp;sp-&gt;mutex);                          <span class="hljs-comment">/* 解锁缓冲区*/</span><br>  V(&amp;sp-&gt;slots);                          <span class="hljs-comment">/* 宣告这里有可用的槽位 */</span><br>  <span class="hljs-keyword">return</span> item;<br>}  <br></code></pre></td></tr></tbody></table></figure></li></ul></li></ul><h4 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h4><ul><li><p>定义：</p><ul><li><p>读者-写者问题是互斥问题的一个概括。</p></li><li><p>一组<strong>并发的线程</strong>要访问一个<strong>共享对象</strong>，例如一个主存中的数据结构，或者一个磁盘上的数据库。</p></li><li><p>有些线程只读对象，叫做<strong>读者</strong>；其他的线程只修改对象，叫做<strong>写者</strong>。</p></li><li><p><strong>写者</strong>必须拥有对对象的<strong>独占</strong>的访问，而<strong>读者可以和无限多个其他的读者共享对象</strong>。</p><blockquote><ul><li><p>读者和写者是互斥的，写者和写者也是互斥的，而读者和读者不存在互斥问题。</p></li><li><p>任一写者在完成写操作之前不允许其他读者或写者工作</p></li></ul></blockquote></li><li><p>一般来说，有无限多个并发的读者和写者。</p><blockquote><p>例子：</p><ul><li>一个在线航空预定系统中，允许有无限多客户同时查看座位分配，但是正在预订座位的客户必须拥有对数据库的独占的访问。</li><li>在一个多线程缓存 Web 代理中，无限多个线程可以从共享页面缓存中取出已有的页面，但是任何向缓存中写入一个新页面的线程必须拥有独占的访问。</li></ul></blockquote></li></ul></li><li><p>读者优先：</p><ul><li><p>要求<strong>不要让读者等待</strong>，除非已经把使用对象的权限赋予了一个<strong>写者</strong>。</p></li><li><p>读者不会因为有一个写者在等待而等待。</p></li><li><p>实现：</p><ul><li><p>定义：</p><ul><li><p>信号量 w 控制对访问共享对象的临界区的访问（写者间，读者和写者间互斥访问）。</p></li><li><p>信号量 <strong>mutex</strong> 保护对<strong>共享量 readcnt</strong> 的访问（读者间的互斥访问），readcnt 统计当前在临界区中的读者数量。</p></li><li><p>每当一个写者进入临界区时，它对互斥锁 w 加锁，每当它离开临界区时，对 w 解锁。</p><blockquote><p>保证了任意时刻临界区中最多只有一个写者。</p></blockquote></li><li><p>只有<strong>第一个进入</strong>临界区的<strong>读者</strong>对 w <strong>加锁</strong>，而只有<strong>最后一个离开</strong>临界区的<strong>读者</strong>对 w <strong>解锁</strong>。</p></li><li><p>当一个读者进入和离开临界区时，如果还有其他读者在临界区中，那么这个读者会<strong>忽略</strong>互斥锁 w。</p></li><li><p>这就意味着只要还有一个读者<strong>占用</strong>互斥锁 w，<strong>无限多数量的读者</strong>可以没有障碍地进入临界区。</p></li></ul></li><li><p>代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> readcnt; <span class="hljs-comment">/* Initially = 0 */</span> <br><span class="hljs-keyword">sem_t</span> mutex, w; <span class="hljs-comment">/* Initially = 1 */</span> <br><span class="hljs-comment">/* 读者 */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reader</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) { <br>        P(&amp;mutex); <br>        readcnt++; <br>        <span class="hljs-keyword">if</span> (readcnt == <span class="hljs-number">1</span>) <span class="hljs-comment">/* 第一个进入 */</span> <br>            P(&amp;w);<br>V(&amp;mutex); <br>        <span class="hljs-comment">/* 这里放临界区代码 */</span> <br>        <span class="hljs-comment">/* 读 */</span> <br>        P(&amp;mutex); <br>        readcnt--; <br>        <span class="hljs-keyword">if</span> (readcnt == <span class="hljs-number">0</span>) <span class="hljs-comment">/* 最后一个离开 */</span> <br>        V(&amp;w);<br>V(&amp;mutex); <br>    } <br>}<br><br><span class="hljs-comment">/* 写者 */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">writer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) { <br>        P(&amp;w);<br><span class="hljs-comment">/* 这里放临界区代码 */</span><br><span class="hljs-comment">/* 写 */</span> <br>        V(&amp;w);<br>} <br>}<br></code></pre></td></tr></tbody></table></figure></li><li><p>饥饿：</p><ul><li><p>对这读者 - 写者问题的正确解答可能导致饥饿（starvation），饥饿就是一个<strong>线程无限期地阻塞</strong>，无法进展。</p></li><li><p>如果有读者不断地到达，写者就可能无限期地等待。</p></li><li><p>但是从某种意义上说，这种优先级是很弱的，因为一个离开临界区的<strong>写者</strong>可能重启一个在等待的<strong>写者</strong>，而不是一个在等待的读者。其中这种弱优先级会导致一群写者使得一个读者饥饿。</p></li></ul></li></ul></li></ul></li><li><p>写者优先：</p><ul><li>要求一旦一个写者准备好可以写，它就会<strong>尽可能快地完成它的写操作</strong>。</li><li>在一个写者后到达的<strong>读者</strong>必须<strong>等待</strong>，即使这个写者也是在等待。</li></ul></li></ul><h4 id="基于预线程化的并发服务器"><a href="#基于预线程化的并发服务器" class="headerlink" title="基于预线程化的并发服务器"></a>基于预线程化的并发服务器</h4><ul><li><p>定义:</p><ul><li><p>我们为每一个新客户端创建了一个<strong>新线程</strong>，导致开销过大。</p></li><li><p>一个基于预线程化的服务器试图通过使用如图所示的<strong>生产者 - 消费者</strong>模型来降低这种开销（有一个生产者和多个消费者）。</p></li><li><p>服务器是由<strong>一个主线程和一组工作者线程</strong>构成的。</p></li><li><p>主线程不断地接受来自客户端的连接请求，并将得到的<strong>连接描述符</strong>放在一个<strong>有限缓冲区</strong>中。</p></li><li><p>每一个工作者线程反复地从共享缓冲区中<strong>取出</strong>描述符，为客户端服务，然后<strong>等待</strong>下一个描述符。</p></li></ul><div align="center"><img src="/img/blog/os-note-images/image-20210922105410600.png"></div></li><li><p>实现：</p><ul><li>在初始化了缓冲区 sbuf 后，主线程创建了<strong>一组工作者线程</strong>。</li><li>然后它进入了无限的服务器<strong>循环</strong>，<strong>接受</strong>连接<strong>请求</strong>，并将得到的已<strong>连接描述符</strong>插入到缓冲区 sbuf 中。</li><li>每个<strong>工作者线程</strong>的行为都非常简单。它等待直到它能从<strong>缓冲区中取出</strong>一个<strong>已连接描述符</strong>，然后调用 <code>echo_cnt()</code> 例程函数<strong>回送</strong>客户端的输入。</li><li>函数 <code>echo_cnt()</code> 在全局变量 byte_cnt 中记录了从所有客户端接收到的累计字节数，用 mutex 信号量进行互斥保护。</li></ul></li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><blockquote><p>主要来自《王道》</p></blockquote><h4 id="死锁的定义和发生条件"><a href="#死锁的定义和发生条件" class="headerlink" title="死锁的定义和发生条件"></a>死锁的定义和发生条件</h4><ul><li><p>信号量引入了一种潜在的令人厌恶的运行时错误，叫做死锁（deadlock），体现为线程因为等待一个永远也不会为真的条件被阻塞了。</p><blockquote><p>死锁是多个进程因<strong>竞争资源</strong>而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。</p><p>只有对<strong>不可抢占资源（不共享）的竞争</strong>才可能产生死锁，对可抢占资源（贡献）的竞争是不会引起死锁的，如只读文件。</p></blockquote></li><li><p>程序员使用 $P$ 和 $V$ 操作顺序不当，以至于两个信号量的禁止区域重叠。</p></li><li><p>如果某个执行轨迹线碰巧到达了死锁状态，那么就不可能有进一步的进展了，因为重叠的禁止区域（死锁区域）阻塞了每个合法方向上的进展。</p><blockquote><p>换句话说，程序死锁是因为每个线程都在等待其他线程执行一个根本不可能发生的 $V$ 操作。</p></blockquote><div align="center"><img src=" /img/blog/os-note-images/image-20210927150402535.png" alt="image-20210927150402535"></div></li><li><p>资源分配图：</p><ul><li><p>通过称为系统资源分配图的有向图可以更精确地描述死锁，包括一个节点集合 $V$ 和一个边集合 $E_{\circ}$ </p></li><li><p>节点集合 $V$ 可分成两种类型： $P=\{P_{1},P_{2}, \cdots, P_{n}\}$ （系统所有<strong>活动进程的集合</strong>）和 $R=\{R_{1}, R_{2}, \cdots, R_{m}\}$（系统所有资源类型的集合）。</p></li><li><p>申请边：</p><p>​    从进程 $P_{i}$ 到资源类型 $R_{j}$ 的有向边记为 $P_{i} \rightarrow R_{j}$，它表示进程 $P_{i}$ 已经<strong>申请</strong>了资源类型 $R_j$ 的一个实例，并且正在<strong>等待</strong>这个资源。</p></li><li><p>分配边：</p><p>​    从资源类型 $R_{j}$ 到进程 $P_{i}$ 的有向边记为 $R_{j} \rightarrow P_{i}$，它表示资源类型 $R_{j}$ 的一个实例已经<strong>分配</strong>给了进程 $P_i$。</p><blockquote><p>在图形上，用<strong>圆表示进程</strong> $P_{i}$，用<strong>矩形表示资源</strong>类型 $R$。由于资源类型 $R_{j}$ 可能有多个实例，所以矩形内的<strong>点的数量表示实例数量</strong>。</p><p>注意申请边只指向矩形 $R_{j}$，而分配边应指定矩形内的<strong>某个圆点</strong>。</p><p>当进程 $P_{i}$ 申请资源类型 $R_{j}$ 的一个实例时，就在资源分配图中加入一条申请边（$P$ 操作阻塞）。</p><p>当该申请得到满足时，那么申请边就立即转换成分配边（$P$ 操作之后）。</p><p>当进程不再需要访问资源时，它就释放资源，因此就删除了分配边（$V$ 操作之后）。</p></blockquote></li><li><p>有环是有死锁的<strong>必要条件</strong>：</p><div align="center"><img src=" /img/blog/os-note-images/image-20210927152310670.png" alt="image-20210927152310670"></div><p>​    右图因为进程 $P_2$ 可能释放资源类型 $R_1$ 的实例，这个资源可分配给进程 $P_1$，从而打破环。</p></li></ul></li><li><p>死锁的四个必要条件：</p><ul><li><p><strong>互斥</strong>：</p><p>​    在一段时间内某非共享资源<strong>仅为一个进程所占有</strong>。此时若有其他进程请求该资源，则请求进程只能<strong>等待</strong>。</p></li><li><p><strong>不可抢占</strong>：</p><p>​    进程所获得的资源在末使用完之前，<strong>不能</strong>被其他进程<strong>强行夺走</strong>，即只能由获得该资源的进程自己来释放（只能是<strong>主动释放</strong>）。</p></li><li><p><strong>请求和保持条件</strong>：</p><p>​    进程已经<strong>保持（已申请到）了至少一个资源</strong>，但又提出了<strong>新的资源请求</strong>，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源<strong>不释放</strong>（保持）。</p></li><li><p><strong>循环等待</strong>：</p><p>​    存在一种进程资源的循环等待环，环中每个进程已获得的资源同时被链中下一个进程所请求。即存在一个处于等待态的进程集合 $\{P_{1}, P_{2}, \cdots, P_{n}\}$，其中 $P_{i}$ 等待的资源被 $P_{i+1}(i=0,1, \cdots, n-1)$ 占有，$P_{n}$ 等待的资源被 $P_{0}$ 占有。</p></li></ul></li></ul><h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><ul><li><p>思想：</p><p>​    破坏产生死锁的 $4$ 个<strong>必要条件</strong>中的一个或几个。</p></li><li><p>破坏互斥条件：</p><p>​    若允许系统资源都能共享使用，则系统不会进入死锁状态。</p><blockquote><p>有些资源本身就是不能同时访问，如打印机等临界资源只能互斥使用。</p></blockquote></li><li><p>破坏不可抢占条件：</p><p>​    当一个<strong>已保持了某些不可抢占资源</strong>的进程<strong>请求新的资源而得不到满足</strong>时，它必须<strong>释放已经保持的所有资源</strong>，待以后需要时再重新申请（<strong>持有不用会被别的进程抢占</strong>）。</p><blockquote><p>缺点：</p><p>​    该策略实现复杂，释放已获得的资源可能造成<strong>前一阶段工作的失效</strong>，<strong>反复地申请和释放资源</strong>会增加系统<strong>开销</strong>，降低系统<strong>吞吐量</strong>。</p><p>这种方法常用于状态<strong>易于保存和恢复</strong>的资源，如 <strong>CPU 的寄存器及内存资源</strong>，一般<strong>不能用于打印机</strong>之类的资源</p></blockquote></li><li><p>破坏请求并保持条件：</p><ul><li>采用预先静态分配方法，即进程在运行前一次申请完<strong>它所需要的全部资源</strong>，在它的资源未满足前，不把它投入运行。</li><li>一旦投入运行，这些资源就<strong>一直归它所有</strong>，不再提出其他资源请求，这样就可以保证系统不会发生死锁。</li><li>另一种方式是<strong>在没有占用资源时，才可申请资源</strong>。在申请新的资源之前，必须释放已分配的所有资源（先释放再申请）。</li></ul><blockquote><p>这种方式实现简单，缺点是系统资源被严重<strong>浪费</strong>，利用率低。</p><p>而且还会导致「<strong>饥饿</strong>」现象，由于个别资源长期被其他进程占用时，将致使等待该资源的进程迟迟不能开始运行。</p></blockquote></li><li><p>破坏循环等待条件：</p><ul><li>为了破坏循环等待条件，可采用顺序资源分配法。</li><li>首先给系统中的资源编号，规定每个进程必须按<strong>编号递增的顺序请求资源</strong>，同类资源一次申请完。</li><li>也就是说，只要进程提出申请分配资源 $R$，则该进程在以后的资源申请中就只能申请编号大于 $R$ 的资源。</li></ul><blockquote><p>这种方法存在的问题是：</p><ul><li>编号必须相对稳定，这就<strong>限制了新类型设备的增加</strong>。</li><li>会发生作业使用资源的顺序与系统规定顺序不同的情况，造成<strong>资源的浪费</strong>。</li><li>此外，这种按规定次序申请资源的方法，也必然会给用户的<strong>编程</strong>带来麻烦。</li></ul></blockquote></li></ul><h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><p>  ​    在资源的动态分配过程中，用某种方法<strong>防止系统进入不安全状态</strong>，从而避免死锁。</p><ul><li><p>避免死锁的方法中，允许进程<strong>动态地申请资源</strong>，但系统在进行资源分配之前，应先计算此次分配的<strong>安全性</strong>。若<strong>此次分配不会导致系统进入不安全状态</strong>，则允许分配，否则让进程等待。</p><blockquote><p>安全状态定义：</p><p>​    系统能按某种进程推进顺序 $\left(P_{1}, P_{2}, \cdots, P_{n}\right)$ 为每个进程 $P_{i}$ 分配其所需的资源，直至满足每个进程对资源的最大需求，使每个进程都可顺序完成。</p><p>此时称 $P_{1}, P_{2}, \cdots, P_{n}$ 为<strong>安全序列</strong>。若系统无法找到一个安全序列，则称系统处于不安全状态。</p></blockquote></li><li><p>银行家算法是最著名的死锁避免算法，其思想是：</p><ul><li>把<strong>操作系统</strong>视为<strong>银行家</strong>，操作系统管理的<strong>资源</strong>相当于银行家管理的<strong>资金</strong>，进程向操作系统<strong>请求分配资源</strong>相当于用户向银行家<strong>贷款</strong>，操作系统按照银行家制定的规则为进程分配资源。</li><li>进程运行之前先声明对各种资源的<strong>最大需求量</strong> $\operatorname{Max}$，这一数量不能超过系统资源的总和。</li><li>当用户<strong>申请</strong>一组资源时，系统应<strong>检测</strong>资源的分配是否仍会使系统处于<strong>安全状态</strong>。如果会，就可分配资源；否则，进程应等待，直到某个其他进程<strong>释放</strong>足够多的资源为止</li></ul></li><li><p>变量定义：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> n,m;              <span class="hljs-comment">//系统中进程总数n和资源种类总数m </span><br><span class="hljs-keyword">int</span> Available[m];  <span class="hljs-comment">//资源当前可用总量</span><br><span class="hljs-keyword">int</span> Allocation[n][m]; <span class="hljs-comment">//当前已经分配给每个进程的各种资源数量</span><br><span class="hljs-keyword">int</span> Need[n][m];  <span class="hljs-comment">//当前每个进程还需分配的各种资源数量</span><br><span class="hljs-keyword">int</span> Work[m];   <span class="hljs-comment">//当前可分配的资源,可用+可收回的</span><br><span class="hljs-keyword">bool</span> Finish[n];  <span class="hljs-comment">//进程是否结束</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>资源请求算法：</p><p>​    设 $\operatorname{Request}_{i}$ 是进程 $P_{i}$ 的请求向量，$\operatorname{Request}_{i}[j]=K$ 表示进程 $P_{i}$ 需要 $j$ 类资源 $K$ 个。当 $P_{i}$ 发出资源请求后，系统按下述步骤进行检查:</p><ol><li>若 $\operatorname{Request}_{i}[j] \leq \operatorname{Need}[i, j]$，则转向步骤 $2$，否则认为出错，因为它所需要的资源数已超过它所宣布的<strong>最大值</strong>。</li><li>若 $\operatorname{Request}_{i}[j] \leq \operatorname{Available} [j]$，则转向步骤 $3$，否则表示<strong>尚无足够资源</strong>，$P_{i}$ 等待。</li><li>系统<strong>试探</strong>着把资源分配给进程 $P_{i}$，并修改下面数据结构中的数值。</li></ol><script type="math/tex; mode=display">   \begin{aligned}   & \operatorname{Available}=\operatorname{Available}-\operatorname{Request}_i[j]\\   &\operatorname{Allocation}[i,j]=\operatorname{Allowcation}[i,j]+\operatorname{Request}_i[j]\\   & \operatorname{Need}[i,j]=\operatorname{Need}[i,j]-\operatorname{Request}_i[j]   \end{aligned}</script><ol><li>系统执行<strong>安全性算法</strong>，检查此次资源分配后，系统是否处于<strong>安全状态</strong>。若安全，才正式将资源分配给进程 $P_{i}$，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程 $P_{i}$ <strong>等待</strong>。</li></ol></li><li><p>安全性算法（时间复杂度 $\mathcal{O}(mn^2)$）：</p><p>​    设置工作向量 $\operatorname{Work} = \operatorname{Available}$，有 $m$ 个元素，表示系统中的剩余可用资源数目。</p><ol><li>初始时安全序列为空。</li><li>从 $\operatorname{Need}$ 矩阵中找出符合下面条件的行：<ul><li>该行对应的进程<strong>不在安全序列</strong>中。</li><li>该行小于等于 $\operatorname{Work}$ 向量（即每一列都小于），找到后，把对应的进程加入安全序列；若找不到，则执行步骤 $4$。</li></ul></li><li>设步骤 $2$ 中找到的进程 ${P}_{i}$ 进入安全序列后，可顺利执行直至完成，并释放分配给它的资源，此时执行 $\operatorname{Work} = \operatorname{Work} + \operatorname{Allocation}[i]$，其中 $\operatorname{Allocation}[i]$ 表示进程 ${P}_{i}$ 代表的在 $\operatorname{Allocation}[i]$ 矩阵中对应的行，返回步骤 $2$。</li><li>若 $3$ 中安全序列中<strong>已有所有进程</strong>，则系统处于<strong>安全状态</strong>，若未找到满足条件的进程，则系统处于不安全状态。</li></ol><p>伪代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">bool</span> Found; <br>Work = Available; <br>Finish = <span class="hljs-literal">false</span>; <br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>){ <br>    Found = <span class="hljs-literal">false</span>;  <span class="hljs-comment">//是否为安全序列找到一个进程 </span><br> <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br><span class="hljs-keyword">if</span>(Finish[i] == <span class="hljs-literal">false</span> &amp;&amp; Need[i] &lt;= Work){      <span class="hljs-comment">// 这个向量「小于等于」是每个分量都小于等于，O(m)判断</span><br>Work = Work + Allocation[i]; <br>Finish[i] = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d-&gt;"</span>,i); <span class="hljs-comment">//输出安全序列 </span><br>Found = <span class="hljs-literal">true</span>;<br> }<br><span class="hljs-keyword">if</span>(Found == <span class="hljs-literal">false</span>) <span class="hljs-keyword">break</span>;<br>}<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>;i &lt;= n;i++) <br><span class="hljs-keyword">if</span>(Finish[i] == <span class="hljs-literal">false</span>) <br><span class="hljs-keyword">return</span> <span class="hljs-string">"deadlock"</span>;    <span class="hljs-comment">//只要有一个没有分配成功，就是产生了死锁</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>缺点：</p><ul><li>每个进程进入系统时必须告知<strong>所需资源的最大数量</strong>，对应用程序员要求高。</li><li>安全序列寻找算法（安全状态判定算法）计算时间复杂度为 $\mathcal{O}(mn^2)$，过于复杂。</li><li>若<strong>每次资源请求</strong>都要调用银行家算法，耗时过大。</li><li>当前有资源可用，尽管可能很快就会释放，由于会使整体进程处于不安全状态，而不被分配，致使<strong>资源利用率</strong>大大降低。</li></ul></li></ul><h4 id="死锁的检测及恢复"><a href="#死锁的检测及恢复" class="headerlink" title="死锁的检测及恢复"></a>死锁的检测及恢复</h4><ul><li><p>无须采取任何限制性措施，<strong>允许</strong>进程在运行过程中<strong>发生死锁</strong>。通过系统的检测机构及时地<strong>检测出死锁的发生</strong>，然后采取某种措施<strong>解除死锁</strong>（抢占一些进程的资源）。</p></li><li><p>类似银行家算法的死锁检测：</p><p>思想：</p><p>​    只要可用资源足够，则分配，发现问题再处理（定时检测或者当发现资源利用率低时检测）。</p><blockquote><p>$\operatorname{Request}_{i}$ 是进程 $P_{i}$ 的请求向量，$\operatorname{Request}_{i}[j]=K$ 表示进程 $P_{i}$ 需要 $j$ 类资源 $K$ 个，代替原来的 $\operatorname{Need}$ 向量。</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">bool</span> Found; <br>Work = Available; <br>Finish = <span class="hljs-literal">false</span>; <br><span class="hljs-keyword">if</span> Allocation[i] != <span class="hljs-number">0</span>: Finish[i] = <span class="hljs-literal">false</span>; <br><span class="hljs-keyword">else</span>: Finish[i] = <span class="hljs-literal">true</span>;       <span class="hljs-comment">//对于无分配资源的进程,不论其是否获得请求资源,则认为其是完成的。</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>){ <br>    Found = <span class="hljs-literal">false</span>;   <span class="hljs-comment">//是否为安全序列找到一个进程 </span><br> <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-comment">/* </span><br><span class="hljs-comment">        *  这里原来是判断 Need[i] &lt;= work</span><br><span class="hljs-comment">        *  原因是已知 Pi 现在不参与死锁(Request &lt;= Work),可以乐观地认为 Pi 不再需要更多资源就可以完成任务,</span><br><span class="hljs-comment">        *  它会返回现已分配的所有资源。如果这个假定不正确,那么下次调用死锁检测算法时,就会检测到死锁状态。</span><br><span class="hljs-comment">        */</span><br><span class="hljs-keyword">if</span>(Finish[i] == <span class="hljs-literal">false</span> &amp;&amp; Request[i] &lt;= Work){<br>Work = Work + Allocation[i]; <br>Finish[i] = <span class="hljs-literal">true</span>;<br>Found = <span class="hljs-literal">true</span>;<br> }<br><span class="hljs-keyword">if</span>(Found == <span class="hljs-literal">false</span>) <span class="hljs-keyword">break</span>;<br>}<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>;i &lt;= n;i++) <br><span class="hljs-keyword">if</span>(Finish[i] == <span class="hljs-literal">false</span>) <br><span class="hljs-keyword">return</span> <span class="hljs-string">"deadlock"</span>;     <span class="hljs-comment">//只要有一个没有分配成功，就是产生了死锁</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>死锁恢复的方法：</p><ul><li><p>终止进程：</p><ul><li><p><strong>中止所有死锁进程</strong>：</p><ul><li>这种方法显然会打破死锁环，但是代价也大。</li><li>这些死锁进程可能已计算了较长时间，这些部分计算的结果也要放弃，并且以后可能还要重新计算。</li></ul></li><li><p>一次<strong>中止一个进程</strong>，直到消除死锁循环为止：</p><p>​    这种方法的开销会相当大，这是因为每次中止一个进程，都应<strong>调用死锁检测算法</strong>，以确定是否仍有进程处于死锁。</p></li></ul></li><li><p>抢占资源：</p><ul><li><p>选择牺牲进程：</p><ul><li><p>应确定<strong>抢占的顺序</strong>使得代价最小。</p></li><li><p>代价因素：</p><p>​    死锁进程拥有的资源数量、死锁进程耗时等。</p></li></ul></li><li><p>回滚：</p><ul><li>必须将进程回滚到某个安全状态（足够打破死锁），以便从该状态重启进程。</li><li>要求系统维护有关进程<strong>运行状态的更多信息</strong>。</li><li>或者完全回滚，终止进程<strong>重新执行</strong>。</li></ul></li><li><p>饥饿：</p><ul><li>要保证资源不会<strong>总是</strong>从同一个进程中被抢占。</li><li>如果一个系统是<strong>基于代价</strong>来选择牺牲进程，那么同一进程可能总是被选为牺牲的，导致这个进程永远不能完成指定任务。应确保一个进程只能<strong>有限次数地被选为牺牲进程</strong>。</li><li>最为常用的方法是在<strong>代价因素中加上回滚次数</strong>。</li></ul></li></ul></li></ul><blockquote><ul><li><p>预防死锁和避免死锁都属于<strong>事先预防策略</strong>，预防死锁的限制条件比较<strong>严格</strong>，实现起来较为简单，但往往导致系统的<strong>效率低</strong>，资源利用率低。</p></li><li><p>避免死锁的限制条件相对<strong>宽松</strong>，资源分配后需要通过算法来判断是否进入不安全状态，实现起来较为<strong>复杂</strong>。</p></li></ul></blockquote></li></ul><ul><li><p>死锁忽略：</p><p>​    采用最多，以上白学<span class="">🔮</span></p></li></ul><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><blockquote><p>整理自 PPT 和 CSAPP</p></blockquote><p>线程安全定义：</p><p>​    线程安全的函数被多个<strong>并发线程反复</strong>地调用时，会一直产生<strong>正确</strong>的结果。</p><h4 id="四类线程不安全函数"><a href="#四类线程不安全函数" class="headerlink" title="四类线程不安全函数"></a>四类线程不安全函数</h4><ul><li><p>不保护<strong>共享变量</strong>的函数：</p><ul><li>利用像 $P$ 和 $V$ 操作这样的同步操作来保护共享的变量可以转变为线程安全函数。</li><li>这个方法的优点是在调用程序中<strong>不需要修改</strong>。</li><li>缺点是同步操作将<strong>减慢</strong>程序的执行时间。</li></ul></li><li><p>被多个进程调用且<strong>持续保持状态</strong>的函数：</p><blockquote><p>原名为「保持跨越多个调用的状态的函数」，有点拗口</p></blockquote><p>​    一个<strong>伪随机数生成器</strong>是这类线程不安全函数的简单例子：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> next = <span class="hljs-number">1</span>;<br><span class="hljs-comment">/* rand: 返回取值范围为 0..32767 的伪随机数 */</span> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rand</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{<br>next = next * <span class="hljs-number">1103515245</span> + <span class="hljs-number">12345</span>; <br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)(next / <span class="hljs-number">65536</span>) % <span class="hljs-number">32768</span>;<br>}<br><span class="hljs-comment">/* srand: set seed for rand() */</span> <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">srand</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> seed)</span> </span>{<br>next = seed; <br>}<br></code></pre></td></tr></tbody></table></figure><ul><li><p>当调用 <code>srand()</code> 为 <code>rand()</code> 设置了一个种子后，一个单线程反复地调用 <code>rand()</code>，能够预期得到一个可重复的随机数字序列。</p></li><li><p>上面的 <code>rand()</code> 函数是线程不安全的，因为当前调用的结果依赖于<strong>前次调用</strong>（可能是其他线程调用的）的中间结果。</p></li><li><p>所以如果<strong>多线程</strong>调用 <code>rand()</code> 函数，得到的 <code>next</code> 随机数<strong>不均匀甚至是常数</strong>。</p></li><li><p><code>rand()</code> 这样的函数变为线程安全的<strong>唯一方式是重写</strong>它，使得它不再使用任何 <code>static</code> 变量，而是依靠调用者在参数中传递状态信息。</p></li><li><p>修改后的代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 传入当前线程上次调用的得到的随机数变量地址</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rand_r</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *nextp)</span> </span>{<br>*nextp = *nextp * <span class="hljs-number">1103515245</span> + <span class="hljs-number">12345</span>; <br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)(*nextp / <span class="hljs-number">65536</span>) % <span class="hljs-number">32768</span>;<br>}<br></code></pre></td></tr></tbody></table></figure></li><li><p>这样做的缺点是：</p><p>​    修改将是非常麻烦的，而且容易出错。</p></li></ul></li><li><p>返回指向静态变量的指针的函数：</p><ul><li><p>某些函数，例如 <code>ctime()</code> 和 <code>gethost-byname()</code>，将计算结果放在一个 <code>static</code> 变量中，然后返回一个指向这个变量的指针。</p></li><li><p>如果我们从并发线程中调用这些函数，那么将可能发生错误，因为正在被一个线程使用的结果会被另一个线程悄悄地<strong>覆盖</strong>了。</p></li><li><p>有两种方法来处理这类线程不安全函数：</p><ul><li><p>重写函数：</p><p>​    使得调用者传递存放结果的<strong>变量的地址</strong>。这就消除了所有共享数据，但是它要求程序员能够修改函数的源代码。</p></li><li><p>使用加锁 - 复制技术：</p><ul><li>基本思想是将<strong>线程不安全函数与互斥锁</strong>联系起来。</li><li>在每一个<strong>调用位置</strong>，对互斥锁加锁，调用线程不安全函数，将函数返回的结果<strong>复制</strong>到一个<strong>私有的内存位置</strong>，然后对互斥锁解锁。</li><li>为了尽可能地减少对调用者的修改，定义一个线程安全的<strong>封装函数</strong>，它执行加锁 - 复制，然后通过<strong>调用这个封装函数</strong>来<strong>取代</strong>所有对线程不安全函数的调用。</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* lock-and-copy version ,取代 ctime 函数*/</span> <br><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">ctime_ts</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">time_t</span> *timep, <span class="hljs-keyword">char</span> *privatep)</span> </span>{<br><span class="hljs-keyword">char</span> *sharedp;<br>P(&amp;mutex); <br>    sharedp = ctime(timep); <br>    <span class="hljs-built_in">strcpy</span>(privatep, sharedp); <br>    V(&amp;mutex); <br>    <span class="hljs-keyword">return</span> privatep;<br>}<br></code></pre></td></tr></tbody></table></figure></li></ul></li></ul></li><li><p>调用线程不安全函数的函数：</p><ul><li>如果函数 $f$ 调用线程不安全函数 $g$，那么 $f$ 不一定是线程不安全。</li><li>如果 $g$ 是第 $2$ 类函数，那么函数 $f$ 也是线程不安全的，只能重写函数 $g$。</li><li>如果 $g$ 是第 $1$ 类或者第 $3$ 类函数，那么只要你用一个互斥锁保护调用位置和任何得到的共享数据，$f$ 仍然可能是线程安全的。</li></ul></li></ul><h4 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h4><ul><li><p>有一类重要的线程安全函数，叫做<strong>可重入函数</strong>（reentrant function）。</p></li><li><p>其特点在于它们具有这样一种属性：</p><p>​    当它们被多个线程调用时，<strong>不会引用任何共享数据</strong>。</p></li><li><p>尽管线程安全和可重入有时会（不正确地）被用做同义词，但是它们之间还是有清晰的技术差别。<strong>可重入函数集合</strong>是<strong>线程安全函数</strong>的一个<strong>真子集</strong>。</p></li><li><p>显式可重入函数：</p><ul><li>所有的函数参数都是<strong>传值传递</strong>的（即<strong>没有指针</strong>）。</li><li>所有的数据引用都是<strong>本地自动栈变量</strong>（即没有引用<strong>静态或全局变量</strong>）。</li><li>无论怎么被调用，都可断言它是可重入的。</li></ul></li><li><p>隐式可重入函数：</p><p>​    <strong>允许一些</strong>参数是<strong>引用传递</strong>的（即允许传递指针），需要<strong>小心地传递</strong>指向<strong>非共享数据</strong>的指针。</p></li></ul><ul><li><p>线程安全的库函数：</p><ul><li><p>大多数 Linux 函数，包括定义在标准 C 库中的函数都是线程安全的，例如：</p><p>​    <code>malloc, free, printf, scanf</code></p></li><li><p>例外：</p><div align="center"><img src=" /img/blog/os-note-images/image-20210922143820526.png"></div></li><li><p>调用这些线程不安全的函数，可以采用加锁复制的方法，缺点有：</p><ul><li>降低了程序的速度。</li><li>某些函数返回指向复杂结构的指针，需要深层复制结构。</li><li>对第 $2$ 类函数如 <code>rand()</code> 这样依赖跨越调用的无效。</li></ul></li></ul></li></ul><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存管理基本概念"><a href="#内存管理基本概念" class="headerlink" title="内存管理基本概念"></a>内存管理基本概念</h3><blockquote><p>整理自《王道》。</p></blockquote><h4 id="程序装入和链接"><a href="#程序装入和链接" class="headerlink" title="程序装入和链接"></a>程序装入和链接</h4><p>创建进程首先要将<strong>程序和数据装入内存</strong>。将用户<strong>源程序</strong>变为可在内存中执行的<strong>程序</strong>，通常需要以下几个步骤：</p><ul><li><p>编译：</p><p>​    由编译程序将用户源代码<strong>编译成若干目标模块</strong>，形成整个程序的完整逻辑地址空间。</p></li><li><p>链接：</p><p>​    由链接程序将编译后形成的一组<strong>目标模块</strong>及所需的<strong>库函数</strong>链接在一起，形成一个完整的<strong>装入模块</strong>。</p></li><li><p>装入：</p><p>​    由装入程序将<strong>装入模块装入内存</strong>运行。</p></li></ul><h4 id="逻辑地址和物理地址"><a href="#逻辑地址和物理地址" class="headerlink" title="逻辑地址和物理地址"></a>逻辑地址和物理地址</h4><ul><li><p>逻辑地址：</p><ul><li>编译后，每个目标模块都从 $0$ 号单元开始编址，这称为该目标模块的相对地址（或逻辑地址）。</li><li>当<strong>链接程序</strong>将各个模块链接成一个完整的可执行目标程序时，链接程序顺序依次按各个模块的相对地址构成统一的从 $0$ 号单元开始编址的逻辑地址空间。</li><li>用户程序和程序员只需知道逻辑地址，而内存管理的具体机制则是完全透明的，只有系统编程人员才会涉及内存管理的具体机制。</li><li><strong>不同进程可以有相同的逻辑地址</strong>，因为他们可以映射到主存的不同位置。</li></ul></li><li><p>物理地址：</p><ul><li>物理地址空间是指内存中物理单元的集合，它是地址转换的最终地址，进程在运行时执行指令和访问数据，最后都要通过物理地址从主存中存取。</li><li>当装入程序将可执行代码<strong>装入内存</strong>时，必须通过地址转换将逻辑地址转换成物理地址（动态重定位貌似不用），这个过程称为<strong>地址重定位</strong>。</li></ul><blockquote><ul><li><p>逻辑地址空间：</p><p>​    在实际应用中，将虚拟地址和逻辑地址经常不加区分，通称为逻辑地址。逻辑地址的集合称为逻辑地址空间</p></li><li><p>线性地址空间：</p><p>​    <strong>CPU 地址总线可以访问</strong>的所有地址集合称为线性地址空间</p></li><li><p>物理地址空间：</p><p>​    <strong>实际存在</strong>的可访问的物理内存地址集合称为物理地址空间</p></li></ul></blockquote></li></ul><h4 id="程序的链接的三种方式"><a href="#程序的链接的三种方式" class="headerlink" title="程序的链接的三种方式"></a>程序的链接的三种方式</h4><ul><li><p><strong>静态链接</strong>：</p><p>​    在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的可执行程序，以后<strong>不再拆开</strong>。</p></li><li><p><strong>装入</strong>时动态链接：</p><p>​    将用户源程序编译后所得到的一组目标模块，在装入内存时，采用<strong>边装入边链接</strong>的方式。</p></li><li><p><strong>运行</strong>时动态链接：</p><p>​    对某些目标模块的链接，是在程序执行中<strong>需要</strong>该目标模块时<strong>才进行</strong>的。其优点是便于修改和更新，便于实现对目标模块的共享。</p></li></ul><p>内存的装入模块在装入内存时，对应有以下三种方式：</p><ul><li><p>绝对装入：</p><ul><li>在<strong>编译</strong>时，若知道程序将驻留在内存的某个位置，则编译程序将产生绝对地址的目标代码。</li><li>绝对装入程序按照装入模块中的地址，将程序和数据装入内存。</li><li>由于程序中的<strong>逻辑地址与实际内存地址完全相同</strong>，因此不需对程序和数据的地址进行修改。</li><li>绝对装入方式只适用于<strong>单道程序环境</strong>。</li></ul></li><li><p>可重定位装入：</p><ul><li>在<strong>多道程序环境</strong>下，多个目标模块的<strong>起始地址</strong>通常都从 $0$ 开始，程序中的其他地址都是<strong>相对于始址</strong>的。</li><li>根据内存的当前情况，将装入模块装入<strong>内存的适当位置</strong>。装入时对目标程序中指令和数据的修改过程称为<strong>重定位</strong>，地址变换通常是在装入时一次完成的，所以又称<strong>静态重定位</strong>。</li><li>静态重定位的特点是，一个作业装入内存时，必须给它分配要求的全部内存空间，若没有足够的内存，则不能装入该作业。</li><li>作业一旦进入内存（一旦装入），整个运行期间就<strong>不能</strong>再在内存中<strong>移动</strong>，也不能再申请内存空间。</li></ul></li><li><p>动态运行时装入（<strong>动态重定位</strong>）：</p><ul><li><p>程序在内存中若发生移动（进程调度），则需要采用动态的装入方式。</p></li><li><p>装入程序把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换<strong>推迟</strong>到程序<strong>真正要执行时才进行</strong>。</p></li><li><p>因此，装入内存后的所有地址均为相对地址。这种方式需要一个<strong>重定位寄存器</strong>的支持，提供基地址。</p><blockquote><p>每个进程有自己的重定位寄存器，达到保护进程数据的作用。</p></blockquote></li><li><p>动态重定位的特点如下：</p><ul><li>可以将程序分配到<strong>不连续</strong>的存储区中。</li><li>在程序运行之前可以只装入它的<strong>部分代码</strong>即可投入运行，然后在程序运行期间，根据需要动态申请分配内存。</li><li>便于<strong>程序段</strong>的共享，可以向用户提供一个<strong>比存储空间大得多的地址空间</strong>。</li><li>在<strong>作业执行过程</strong>中进行的，不是装入过程。</li></ul></li></ul></li></ul><h4 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h4><p>​    内存分配前，需要保护操作系统不受用户进程的影响，同时<strong>保护用户进程不受其他用户进程</strong>的影响。内存保护可采取两种方法：</p><ul><li><p>在 CPU 中设置一对上、下限寄存器，存放用户作业在主存中的下限和上限地址，每当 CPU 要访问一个地址时，分别和两个寄存器值相比，判断有无越界。</p></li><li><p>采用重定位寄存器（或基址寄存器）和界地址寄存器（又称限长寄存器）来实现这种保护：</p><ul><li><strong>重定位</strong>寄存器含<strong>最小</strong>的<strong>物理地址</strong>值，<strong>界地址</strong>寄存器含<strong>逻辑地址的最大值</strong>。</li><li>每个<strong>逻辑地址值必须小于界地址寄存器</strong>。</li><li>内存管理机构动态地将逻辑地址与界地址寄存器进行<strong>比较</strong>，若<strong>未发生地址越界</strong>，则加上重定位寄存器的值后映射成物理地址，再送交内存单元。</li></ul><div align="center"><img src=" /img/blog/os-note-images/image-20211013235611684.png" alt="image-20211013235611684" style="zoom:80%;"></div></li></ul><blockquote><p>内存保护需要<strong>操作系统和硬件</strong>合作完成。</p></blockquote><h3 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h3><blockquote><p>整理自《王道》。</p></blockquote><ul><li><p>连续分配方式是指为一个<strong>用户程序</strong>分配一个<strong>连续的内存空间</strong>。</p></li><li><p>碎片：</p><p>​    <strong>内存</strong>中<strong>剩余的无法使用</strong>的存储空间。</p></li><li><p>外部碎片：</p><p>​    随着<strong>进程不断的装入和移出</strong>，对分区不断的分割，使得内存中产生许多特别<strong>小的分区</strong>，它们并不连续可用。</p></li><li><p>内部碎片：</p><p>​    对<strong>固定分区</strong>来说，只要分区被分配给某进程使用，其中<strong>并未占用的空间</strong>不能分给其他进程，这些空间称为<strong>内部碎片</strong>。</p></li><li><p>单一连续分配：</p><ul><li>内存在此方式下分为系统区和用户区，系统区仅供操作系统使用，通常在低地址部分。</li><li>用户区是为用户提供的、除系统区之外的内存空间。</li><li>这种方式无须进行内存保护。因为内存中永远只有<strong>一道程序</strong>，因此肯定不会因为访问越界而干扰其他程序。</li><li>优点是简单、<strong>无外部碎片</strong>。</li><li>缺点是只能用于<strong>单用户、单任务</strong>的操作系统中，有<strong>内部碎片</strong>，存储器的利用率极低。</li></ul></li><li><p>固定分区分配：</p><ul><li><p>是最简单的一种<strong>多道程序</strong>存储管理方式，它<strong>预先</strong>将用户内存空间划分为若干<strong>固定大小</strong>的区域，<strong>每个分区只装入一道作业</strong>。</p></li><li><p>当有<strong>空闲分区</strong>时，便可再从外存的后备作业队列中选择适当大小的作业装入该分区。</p></li><li><p>分区大小相等（等长分区）：</p><p>​    用于利用一台计算机去控制多个<strong>相同对象</strong>的场合，缺乏灵活性。</p></li><li><p>分区大小不等（变长分区）：</p><p>​    划分为多个较小的分区、适量的中等分区和少量大分区。</p></li><li><p>特点：</p><p>​    <strong>无外部碎片</strong>，但不能实现多进程<strong>共享</strong>一个主存区，存储空间<strong>利用率低</strong>。</p></li></ul></li><li><p>动态分区分配（<strong>可变分区</strong>分配）：</p><blockquote><p><strong>可变分区</strong>和<strong>变长分区</strong>要区别。</p></blockquote><ul><li><p>不预先划分内存，而是在<strong>进程装入内存</strong>时，根据进程的大小<strong>动态</strong>建立分区，并使分区的大小正好适合进程的需要（即分区本身没有<strong>内部碎片</strong>）。</p></li><li><p>系统中分区的大小和数目是可变的。</p></li><li><p>动态分区在换入换出后会导致内存中出现许多小的内存块（碎片），即<strong>外部碎片</strong>。</p></li><li><p>动态分区的分配策略：</p><ul><li><p>首次适应（First Fit）  </p><p>​    空闲分区以<strong>地址递增</strong>的次序链接。分配内存时顺序查找，找到能满足要求的第一个空闲分区。</p></li><li><p>最佳适应（Best Fit）：</p><p>​    空闲分区按<strong>容量递增</strong>的次序链接，找到第一个能满足要求的空闲分区。</p></li><li><p>最坏适应（Worst Fit）</p><p>​    空闲分区以<strong>容量递减</strong>的次序链接，找到第一个能满足要求的空闲分区，即挑选出<strong>最大的分区</strong>。</p></li></ul></li><li><p>克服外部碎片可以通过紧凑（合并空闲分区）技术来解决，即操作系统不时地对进程进行移动和整理。但这需要<strong>动态重定位寄存器</strong>的支持，且相对费时。</p></li></ul></li></ul><div align="center"><img src=" /img/blog/os-note-images/image-20211202113528076.png"></div><h3 id="非连续分配管理方式"><a href="#非连续分配管理方式" class="headerlink" title="非连续分配管理方式"></a>非连续分配管理方式</h3><h4 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h4><ul><li><p>将程序按含义分成若干部分，即分段。<strong>段内要求连续</strong>，<strong>段间不要求连续</strong>，因此整个作业的地址空间是<strong>二维</strong>的</p></li><li><p>汇编时每个段从 $0$ 编址，链接时可不为 $0$。</p></li><li><p>创建进程（分别载入各个段）时，建立<strong>进程段表</strong>，用于实现从逻辑段到物理内存区的映射：</p><div align="center"><img src=" /img/blog/os-note-images/image-20211014190118300.png" alt="image-20211014190118300" style="zoom:80%;"></div><p>每个进程有自己的进程段表，有多个基址。</p></li><li><p>内存仍用<strong>可变分区</strong>进行管理，载入段时要使用分配算法。</p></li><li><p>从逻辑地址中取出前几位为<strong>段号</strong>，后几位为<strong>段内偏移量</strong>，需要判断：</p><ul><li>段号是否存在于段表中</li><li><strong>段表项长度</strong>是否大于等于<strong>段内偏移量</strong>，小于会判断为越界</li></ul></li><li><p>PC 及数据地址要通过段表算出物理地址，到达内存。</p></li><li><p>进程切换时，<strong>进程段表</strong>也跟着切换。</p></li></ul><blockquote><p>优点：</p><ul><li>不同的段有不同的含义，可区别对待。</li><li>每个段独立编址，编程容易。</li></ul><p>缺点：</p><p>​    存在<strong>外部碎片</strong>（王道说是<strong>没有内部碎片</strong>的），有较大的资源浪费。</p><p>分段的题目：</p><div align="center"><img src=" /img/blog/os-note-images/image-20211214095011776.png"></div><div align="center"><img src=" /img/blog/os-note-images/image_71.png"></div></blockquote><h4 id="基本分页存储管理方式"><a href="#基本分页存储管理方式" class="headerlink" title="基本分页存储管理方式"></a>基本分页存储管理方式</h4><ul><li><p>选择分页的原因：</p><ul><li><strong>固定分区</strong>会产生<strong>内部碎片</strong>，<strong>动态分区</strong>会产生<strong>外部碎片</strong>，这两种技术对内存的利用率都比较低。</li><li>把主存空间划分为大小相等且固定的块，块相对较<strong>小</strong>，作为主存的基本单位。</li><li>每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。</li><li>分页的方法从形式上看，像等长等长分区的固定分区技术，分页管理不会产生<strong>外部碎片</strong>，块的大小相对分区要小很多，内部碎片大小有上界保证。</li></ul></li><li><p>分页的概念：</p><ul><li><p>页面和页面大小：</p><ul><li><strong>进程中的块称为页</strong>，<strong>内存中的块称为页框</strong>（页帧）。</li><li>外存也以同样的单位进行划分，直接称为块，大小和页是一样的。</li><li>进程在执行时需要申请主存空间，即要为每个页面分配<strong>主存中的可用页框</strong>，这就产生了页和页框的一一对应。</li></ul></li><li><p>逻辑（虚拟）地址的结构：</p><ul><li>地址结构前一部分为页号 $P$，后一部分为页内偏移量 $W$。</li><li>地址长度为 $32$ 位，其中 $0 \sim 11$ 位为页内地址，即<strong>每页大小</strong>为 $4 \mathrm{~KB}$，$ 12 \sim 31$ 位为页号，地址空间最多允许 $2^{20}$ 页。</li><li>地址结构决定了<strong>虚拟内存的寻址空间</strong>有多大。</li></ul></li><li><p>页表：</p><ul><li><p>为了便于在内存中找到进程的每个页面所对应的物理块，系统为<strong>每个进程建立一张页表</strong>，它记录页面在内存中对应的<strong>物理块号</strong>（页框号或帧号），页表一般存放在<strong>内存</strong>中。</p></li><li><p>页表是由页表项组成的，注意：</p><ul><li><p>页表项与地址都由两部分构成，第一部分都是<strong>页号</strong>（页表项的页号一般是连续的，所以可以不存页号这一列）。</p></li><li><p>页表项的第二部分是<strong>物理内存中的块号</strong>，而地址的第二部分是<strong>页内偏移</strong>。</p></li><li><p><strong>页表项的第二部分与地址的第二部分</strong>共同组成<strong>物理地址</strong>。</p></li><li><p>页表项结构（PTE）图（上面说的第二部分就是物理页号）：</p><div align="center"><img src=" /img/blog/os-note-images/image-20211018155121060.png"></div></li></ul></li><li><p>页表长度是指一个页表中一共有多少页，页表项长度是指页地址占多大的存储空间。</p></li></ul></li><li><p>在系统中通常设置一个<strong>页表寄存器</strong>（PTR），存放页表在内存的起始地址 $F$ 和页表长度 $L$。进程未执行时，页表的始址和长度存放在<strong>进程控制块</strong>中。</p></li><li><p>设页面大小为 $L$，逻辑地址 $A$ 到物理地址 $E$ 的转换过程：</p><ol><li>计算页号 $P(P=A / L)$ 和页内偏移量 $W(W=A \% L)$。</li><li>比较页号 $P$ 和<strong>页表长度</strong>（共有多少页） $M$，若 $P \geq M$，则产生越界中断，否则继续执行。<br>页表中页号 $P$ 对应的页表项地址 $=$ 页表始址 $F~+$ 页号 $P ~\times$ 页表项长度，取出该页表项内容 $b$，即为<strong>物理块号</strong>。</li><li>计算 $E=b \times L+W$，用得到的<strong>物理地址</strong> $E$ 去访问内存。</li></ol></li><li><p>缺点：</p><ul><li>每次访存操作都需要进行<strong>逻辑地址到物理地址</strong>的转换，地址转换过程必须足够快，否则访存速度会降低。</li><li>每个进程引入页表，用于存储映射机制，页表不能太大，否则<strong>内存利用率</strong>会降低。</li></ul></li></ul></li><li><p>具有快表 TLB 的地址变换机构（后面会详细解释）：</p><ul><li>在页表的地址变换过程中，若<strong>页表全部放在内存</strong>中，则存取一个数据或一条指令至少要<strong>访问两次内存</strong>：<ul><li>第一次是<strong>访问页表</strong>，确定所存取的数据或指令的物理地址。</li><li>第二次是根据该地址存取数据或指令。</li></ul></li><li>在地址变换机构中增设一个具有并行查找能力的高速缓冲存储器（一组关联快速寄存器组），又称相联存储器（<strong>TLB</strong>），用来存放<strong>当前访问的若干页表项</strong>，以加速地址变换的过程。与此对应，主存中的页表常称为<strong>慢表</strong>。</li><li>具体过程：<ul><li>CPU 给出<strong>虚拟地址</strong>后，由硬件进行地址转换，将<strong>虚拟页号</strong>送入 TLB，并将此页号与 TLB 中的所有页号进行比较。</li><li>若找到匹配的页号，说明所要访问的页表项在快表中，则直接从中取出该页对应的<strong>页框号</strong>，与页内偏移量拼接形成物理地址。这样，存取数据仅<strong>一次访存</strong>便可实现。</li><li>若未找到匹配的页号，则需要<strong>访问主存中的页表</strong>，在读出页表项后，应同时将其<strong>存入快表</strong>，以便后面可能的再次访问。</li><li>若快表已满，则必须按照一定的算法对旧的页表项进行替换。</li></ul></li><li>快表的有效性基于著名的<strong>局部性原理</strong>。</li></ul></li></ul><h4 id="二级页表（比较绕）"><a href="#二级页表（比较绕）" class="headerlink" title="二级页表（比较绕）"></a>二级页表（比较绕）</h4><ul><li><p>本质上就是在<strong>原有页表结构上再加上一层页表</strong>，顶级页表只有 $1$ 个页面。</p><div align="center"><img src=" /img/blog/os-note-images/image-20211018160636257.png" alt="image-20211018160636257" style="zoom:100%;"></div></li><li><p>一个页表的在内存中占 $4~\mathrm {KB}$，且页面大小也是 $4~\mathrm {KB}$，所以一个页（内存中的块）能放下一个页表。</p></li><li><p>多级页表要达到的目的：</p><p>​    在进程执行时，<strong>只需要将顶级页表调入内存</strong>即可，进程的页表和进程本身的页面可在后面的执行中再调入内存（<strong>需要时再调入</strong>）。</p><blockquote><p>内存中分成 $2^{20}$ 个页，页表中每个页表项大小为 $4~\mathrm {B}$，如果全部调入内存需要 $4~\mathrm {MB}$ 的大小，而很多页是不需要的。</p><p>多级页表就是想让不需要的页表不用调入内存。</p><p>如果顶级页表中的一个 PTE 是空的，那么相应的二级页表就根本不会存在，这就是多级页表节约内存的原理。</p></blockquote></li><li><p>顶级页表正好通过 $1~\mathrm {K}$ 个页表项，得到其他的 $1~\mathrm {K}$ 个次级页表的块号。</p></li><li><p>PDE（顶级页表的页表项） 和 PTE 的 $4~\mathrm {B}$结构：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* PDE */</span><br>|&lt;------ <span class="hljs-number">31</span>~<span class="hljs-number">12</span>------&gt;|&lt;------ <span class="hljs-number">11</span>~<span class="hljs-number">0</span> ---------&gt;| 比特<br>                     |b a <span class="hljs-number">9</span> <span class="hljs-number">8</span> <span class="hljs-number">7</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span>| <br>|--------------------|-|-|-|-|-|-|-|-|-|-|-|-| 占位<br>|&lt;-------index------&gt;| AVL |G|P|<span class="hljs-number">0</span>|A|P|P|U|R|P| 属性<br>                             |S|   |C|W|/|/|<br>                                   |D|T|S|W|<br>    <br><span class="hljs-comment">/* PTE */</span><br>|&lt;------ <span class="hljs-number">31</span>~<span class="hljs-number">12</span>------&gt;|&lt;------ <span class="hljs-number">11</span>~<span class="hljs-number">0</span> ---------&gt;| 比特<br>                     |b a <span class="hljs-number">9</span> <span class="hljs-number">8</span> <span class="hljs-number">7</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span>|<br>|--------------------|-|-|-|-|-|-|-|-|-|-|-|-| 占位<br>|&lt;-------index------&gt;| AVL |G|P|D|A|P|P|U|R|P| 属性<br>                             |A|   |C|W|/|/|<br>                             |T|   |D|T|S|W|<br></code></pre></td></tr></tbody></table></figure></li><li><p>使用二级页表的地址翻译过程（逻辑地址到物理地址）：</p><ul><li><strong>逻辑地址</strong>格式：</li></ul></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">顶级页号（页目录号） $10~\rm b$</th><th style="text-align:center">次级页号 $10~\rm b$</th><th>页内偏移量 $12~\rm b$</th></tr></thead><tbody><tr><td style="text-align:center"></td></tr></tbody></table></div><ul><li><p>回顾只有一级页表的地址翻译过程：</p><blockquote><p>设页面大小为 $L$，逻辑地址 $A$ 到物理地址 $E$ 的转换过程：</p><ol><li>计算页号 $P(P=A / L)$ 和页内偏移量 $W(W=A \% L)$。</li><li>比较页号 $P$ 和<strong>页表长度</strong> $M$，若 $P \geq M$，则产生越界中断，否则继续执行。</li><li>页表中页号 $P$ 对应的页表项地址 $=$ 页表始址 $F~+$ 页号 $P ~\times$ 页表项长度，取出该页表项内容 $b$，即为<strong>物理块号</strong>。</li><li>计算 $E=b \times L+W$，用得到的<strong>物理地址</strong> $E$ 去访问内存。</li></ol></blockquote></li><li><p>在顶级页表中，这个页面大小不是 $4~\rm{KB}$。因为顶级页表的一个页表项对应于一个次级页表所在块，这个次级列表有 $1~\mathrm {K}$ 个页表项，每页是 $4~\rm{KB}$，所以这个次级列表所映射的页面大小之和是 $4~\rm{MB}$。所以在顶级页表中，这个页面大小是 $4~\rm{MB}$。这也对应了逻辑地址格式的顶级页号是 $10~\rm{b}$。</p></li><li><p>在第 $3$ 步根据顶级页号可以找到对应页表项的内容（PDE 的结构中的第 $12-31$ 位），即次级页表所在块号。</p></li><li><p>笔者认为，这时我们不需要用到页内偏移量，可以认为 $W=0$，这样就能找到次级页表的首地址了。</p></li><li><p>在次级页表中，这个地址翻译过程就比较容易理解了，和一级页表翻译过程完全一样，页面大小是 $4~\rm{KB}$，得到次级页号也是 $10~\rm{b}$ 的。</p></li><li><p>多级页表使得地址翻译效率更低，<strong>访问内存次数增加</strong>。</p></li></ul><h4 id="段页式管理方式"><a href="#段页式管理方式" class="headerlink" title="段页式管理方式"></a>段页式管理方式</h4><ul><li><p>综合两者优点：</p><p>​    页式存储管理能有效地提高<strong>内存利用率</strong>，而分段存储管理能反映<strong>程序的逻辑结构</strong>并有利于段的共享，符合程序员习惯。</p></li><li><p>在段页式系统中，作业的<strong>地址空间首先被分成若干逻辑段</strong>，每段都有自己的段号（面向程序员）。然后将<strong>每段</strong>分成若干<strong>大小固定的页</strong>（面向硬件）。</p></li><li><p>对内存空间的管理仍然和分页存储管理一样，将其分成若干和<strong>页面大小相同的存储块</strong>，对内存的分配以存储块为单位</p></li><li><p>结构图：</p><div align="center"><img src=" /img/blog/os-note-images/image-20211019100254533.png" style="zoom:80%;"></div></li><li><p>系统为<strong>每个进程</strong>建立一张<strong>段表</strong>，每个分段有一张<strong>页表</strong>。此外，系统中还应有一个段表寄存器，指出作业的段表始址和段表长度。</p></li><li><p>段表寄存器和页表寄存器的作用都有两个，一是在段表或页表中寻址，二是判断是否越界。</p><blockquote><p>在一个进程中，段表只有一个，而页表可能有多个。</p></blockquote></li><li><p>地址翻译过程：</p><div align="center"><img src=" /img/blog/os-note-images/image-20211019100841669.png"></div></li><li><p>在进行地址翻译时，首先通过段表查到<strong>页表基址</strong>，然后通过页表找到页帧号，最后形成物理地址，进行一次访问实际需要<strong>三次</strong>访问主存，可通过 TLB 加速。</p><blockquote><p>PPT 上是逻辑地址 $\to$ 线性地址 $\to$ 物理地址，地址格式也不同。</p></blockquote></li></ul><h4 id="Intel-x86-的内存"><a href="#Intel-x86-的内存" class="headerlink" title="Intel x86 的内存"></a>Intel x86 的内存</h4><blockquote><p>来自 PPT，有的班没讲，可跳过<span class="">😿</span></p></blockquote><ul><li><p>实模式：</p><p>​    逻辑地址与物理地址一致，物理地址 = 段地址 + 偏移地址。</p></li><li><p>保护模式：</p><ul><li>内存的管理模式分为<strong>纯段模式</strong>和<strong>段页模式</strong>，没有纯页模式。</li><li>段模式是必不可少的，而页模式则是可选的。</li><li>如果使用页模式，则是段页式，否则这是纯段模式。</li></ul></li><li><p>GDT 和 LDT：</p><ul><li>每个<strong>进程</strong>都有自己的<strong>段表</strong>（LDT，存各个进程的段描述符），<strong>操作系统</strong>有自己的段表（GDT，存操作系统的段描述符）</li><li>GDT 的入口放在 GDTR 寄存器中，GDT 中还记录各个进程的段表 LDT 入口，<strong>当前进程</strong>的 LDT 入口同时放入 <strong>LDTR 寄存器</strong>。</li><li>GDTR 和 LDTR 寄存器（存放 GDT 和当前进程 LDT 的入口）都有 $32$ 位段表基址（线性空间 $4 \rm ~G$） + $16$ 位段表长度。</li></ul></li><li><p>寻找<strong>段</strong>对应<strong>内存线性空间</strong>的块位置：</p><ul><li><p>若 $TI = 0$（<strong>段寄存器</strong>的一个标志位）：</p><div align="center"><img src=" /img/blog/os-note-images/image-20211020114648595.png"></div><ul><li><p>先从 GDTR 寄存器中获得 GDT 基址。</p></li><li><p>然后在 GDT 中以段选择器（段寄存器）高 $13$ 位位置索引值得到段描述符。</p></li><li><p>段描述符包含段的<strong>基址、限长</strong>、优先级等各种属性，这就得到了<strong>段的起始地址（基址）</strong>，再以基址加上偏移地址得到线性地址。</p><blockquote><p>顺序：</p><p>​    GDTR $\to$ GDT $\to$ 段寄存器索引 $\to$ GDT $\to$ 对应段</p></blockquote></li></ul></li><li><p>若 $TI = 1$：</p><div align="center"><img src=" /img/blog/os-note-images/image-20211020114714397.png"></div><ul><li>还是先从 GDTR 寄存器中获得 GDT 基址（找 LDT）。</li><li>从 LDTR 寄存器中获取 LDT 所在段的位置索引（LDTR 高 $13$ 位），以这个位置索引在 GDT 中得到 LDT 段描述符从而得到 LDT 段基址。</li><li>用段选择器高 $13$ 位位置索引值从 LDT 段中得到段描述符。</li><li><p>段描述符包含段的基址、限长、优先级等各种属性，这就得到了段的起始地址（基址），再以基址加上偏移地址得到线性地址。</p><blockquote><p>顺序：</p><p>​    GDTR $\to$ GDT $\to$ LDTR $\to$ GDT $\to$ LDT $\to$ 段寄存器索引 $\to$ LDT $\to$ 对应段</p></blockquote></li></ul></li></ul></li></ul><ul><li><p>段页模式的地址变换：</p><p>​    所有进程共享 $4\rm ~G$ 的线性地址空间，段基址可以重叠，只需要页表不同（CR3 寄存器指向当前进程的页目录）。</p><div align="center"><img src=" /img/blog/os-note-images/page.png"></div></li></ul><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><blockquote><p>整理自《王道》，CSAPP，PPT</p></blockquote><h4 id="虚拟内存的概念"><a href="#虚拟内存的概念" class="headerlink" title="虚拟内存的概念"></a>虚拟内存的概念</h4><ul><li><p>之前讨论的内存管理策略的共性和不足：</p><ul><li><p>同时将多个进程保存在内存中，以便允许进行多道程序设计。</p></li><li><p>一次性：</p><p>​    作业必须<strong>一次性全部</strong>装入内存后，才能开始运行。这会导致两种情况：</p><ul><li>当作业很大而不能全部被装入内存时，将使该作业无法运行。</li><li>当大量作业要求运行时，由于内存不足以容纳所有作业，只能使<strong>少数作业先运行</strong>，导致多道程序度的下降。</li></ul></li><li><p>驻留性：</p><ul><li>作业被装入内存后，就一直驻留在内存中，其任何部分都<strong>不会被换出</strong>，直至结束。</li><li>运行中的进程会因等待 I/O 而被阻塞，可能处于长期等待状态，应当被换出而没有换出。</li></ul></li></ul><blockquote><p>核心问题是许多在程序运行中<strong>不用或暂时不用的程序</strong>（数据）占据了大量的内存空间，而一些需要运行的作业又无法装入运行，浪费了宝贵的内存资源。</p></blockquote></li><li><p>关键的局部性原理：</p><ul><li>时间局部性：<ul><li>程序中的某条指令一旦执行，不久后该指令可能再次执行。</li><li>某数据被访问过，不久后该数据可能再次被访问。</li><li>产生时间局部性的典型原因是程序中存在着大量的<strong>循环</strong>操作。</li></ul></li><li>空间局部性：<ul><li>一旦程序访问了某个存储单元，在不久后，其<strong>附近的存储单元</strong>也将被访问。</li><li>即程序在一段时间内所访问的地址，可能集中在一定的范围之内，因为指令通常是顺序存放、顺序执行的，数据也一般是以<strong>向量、数组、表</strong>等形式<strong>簇聚存储</strong>的。</li></ul></li><li>虚拟内存技术利用局部性原理实现高速缓存。</li></ul></li><li><p>虚拟存储器定义：</p><ul><li><p>基于局部性原理，在程序装入时，将程序的<strong>一部分装入内存</strong>，而将其余部分留在<strong>外存</strong>，就可启动程序执行（部分装入）。</p></li><li><p>在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分<strong>调入内存</strong>，然后继续执行程序（按需调页）。</p></li><li><p>操作系统将内存中暂时不使用的内容<strong>换出</strong>到外存上，从而腾出空间存放将要调入内存的信息（换入换出 or 置换）。</p></li><li><p>这样，系统好像为用户提供了一个比<strong>实际内存大</strong>得多的存储器，但这个存储器<strong>本身并不存在</strong>，因为称为<strong>虚拟存储器</strong>。</p></li><li><p>虚拟存储器的大小由计算机的<strong>地址结构</strong>决定，并不是内存和外存的简单相加。</p><blockquote><p>虚存的容量要满足以下两个条件:</p><ul><li>虚存的<strong>实际容量</strong> $\leq$ <strong>内存</strong>容量和<strong>外存</strong>容量之和，这是<strong>硬件的硬性条件</strong>规定的。若虚存的实际容量超过了这个容量，则没有相应的空间来供虚存使用。</li><li>虚存的<strong>最大容量</strong> $\leq$ 计算机的<strong>地址位数</strong>能容纳的最大容量。假设地址是 $32$ 位的，按字节编址，一个地址代表 $1 \mathrm{~B}$ 存储空间，则虚存的最大容量 $\leqslant 4 \mathrm{~GB}\left(2^{32} \mathrm{~B}\right)$。这是因为若虚存的最大容量超过 $4 \mathrm{~GB}$，则 $32$ 位的地址，超过限制的空间没有意义。</li></ul><div align="center"><img src=" /img/blog/os-note-images/image-20211214113424964.png"></div></blockquote></li></ul></li></ul><h4 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h4><ul><li><p>请求分页方式概念：</p><ul><li>请求分页系统建立在<strong>基本分页系统</strong>基础之上，为了支持虚拟存储器功能而增加了<strong>请求调页功能和页面置换</strong>功能。</li><li>需要一定容量的<strong>内存及外存</strong>的计算机系统，还需要有<strong>页表机制</strong>、<strong>缺页中断机构</strong>和<strong>地址变换机构</strong>等硬件支持。</li></ul></li><li><p>页表机制：</p><ul><li>请求分页系统在一个作业运行之前，<strong>不要求一次性全部</strong>调入内存，因此在作业的运行过程中，可能出现要访问的页面<strong>不在内存</strong>中（但是在页表中）的情况。</li><li>为了支持换入换出功能，要修改页表项的结构，新增一些字段：</li></ul><div align="center"><img src=" /img/blog/os-note-images/image-20211205124215996.png"></div></li><li><p>缺页中断机构：</p><ul><li>在请求分页系统中，每当所要访问的页面不在内存中时，便产生一个<strong>缺页中断</strong>，请求操作系统将所缺的页从磁盘调入内存。</li><li>此时应将缺页的进程<strong>阻塞</strong>（调页完成<strong>唤醒</strong>），若内存中有空闲块，则分配一个块，将要调入的页装入该块，并修改页表中的相应<strong>页表项</strong>。</li><li>若此时内存中没有空闲块，则要<strong>淘汰某页</strong>（若被淘汰页在内存期间被修改过，则要将其写回外存）。</li><li>缺页中断作为中断，同样要经历诸如保护 CPU 环境、分析中断原因、转入缺页中断处理程序、恢复 CPU 环境等几个步骤。</li><li>但与一般的中断相比，它有以下两个明显的区别：<ul><li>在<strong>指令执行期间</strong>而非一条指令执行完后产生和处理中断信号，属于<strong>内中断</strong>，<a href="#中断">内外中断的概念在这</a>。</li><li><strong>一条指令</strong>在执行期间，可能产生<strong>多次缺页中断</strong>。</li></ul></li></ul></li><li><p>地址变换机构：</p><div align="center"><img src=" /img/blog/os-note-images/image-20211205131752959.png"></div></li></ul><h4 id="页面置换（淘汰）算法"><a href="#页面置换（淘汰）算法" class="headerlink" title="页面置换（淘汰）算法"></a>页面置换（淘汰）算法</h4><ul><li>但内存已无空闲空间时，就需要从内存中调出一页程序或数据，送入磁盘的对换区（生磁盘，没有文件系统）。</li><li>虚拟内存技术调换页面时需要访问<strong>外存</strong>，会导致平均访存时间增加，若使用了不合适的置换算法，则会大大降低系统性能。</li><li>Belady 异常：<ul><li>内存分配的物理块数增大而页故障数<strong>不减反增</strong>的异常现象。</li><li>基于队列实现的置换算法可能发生 Belady 异常，而基于堆栈实现的置换算法不会发生 Belady 异常。</li></ul></li><li>算法表格如下：</li></ul><div align="center"><img src=" /img/blog/os-note-images/table1.png"></div><h4 id="其他相关概念"><a href="#其他相关概念" class="headerlink" title="其他相关概念"></a>其他相关概念</h4><ul><li><p>驻留集定义：</p><ul><li><p>在进程准备执行时，操作系统要决定给特定的进程分配几个页框。</p></li><li><p>给一个进程分配的<strong>物理页框的集合</strong>就是这个进程的<strong>驻留集</strong>。</p></li><li><p>需要考虑以下几点：</p><ul><li><p>分配给一个进程的存储量越小，任何时候驻留在主存中的进程数就越多，从而可以提高处理机的时间利用效率。</p></li><li><p>同时，若一个进程在主存中的页数过少，则尽管有局部性原理，<strong>页错误率</strong>仍然会相对较高。</p><blockquote><p>页错误率 PFF = 页错误/指令执行条数</p></blockquote></li></ul></li></ul></li><li><p>页面分配 + 页面置换策略：</p><ul><li><p><strong>固定</strong>分配<strong>局部置换</strong>：</p><ul><li><p>它为每个进程分配一定数目的物理块，在整个运行期间都<strong>不改变</strong>。</p></li><li><p>若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后调入需要的页面。</p><blockquote><p>缺点是难以确定应为每个进程分配的物理块数目：</p><ul><li>太少会频繁出现<strong>缺页中断</strong></li><li>太多又会使 CPU 和其他<strong>资源利用率</strong>下降</li></ul></blockquote></li></ul></li><li><p><strong>可变</strong>分配<strong>全局置换</strong>：</p><ul><li><p>这是最<strong>易于实现</strong>的物理块分配和置换策略，它为系统中的每个进程分配<strong>一定数目</strong>的物理块，操作系统自身也保持一个空闲物理块队列。</p></li><li><p>当某进程发生缺页时，系统从<strong>空闲物理块队列</strong>（或其他进程物理块）中取出一个物理块分配给该进程，并将欲调入的页装入其中。</p></li><li><p>这种方法比固定分配局部置换更加<strong>灵活</strong>，可以动态增加进程的物理块，吞吐量大。</p><blockquote><p>缺点是它会<strong>盲目地给进程增加物理块</strong>，进程不能控制它自己的缺页错误率，从而导致系统多道程序的<strong>并发能力</strong>下降。</p></blockquote></li></ul></li><li><p><strong>可变</strong>分配<strong>局部</strong>置换：</p><ul><li><p>它为每个进程分配一定数目的物理块，当某个进程发生缺页时，只允许从该进程在内存的页面中选出一页换出，因此<strong>不会影响其他进程的运行</strong>。</p></li><li><p>若进程在运行中<strong>频繁地缺页</strong>，则系统再为该进程<strong>分配</strong>若干物理块，直至该进程缺页率趋于适当程度。</p></li><li><p>若进程运行中的缺页率特别低，则可适当<strong>减少</strong>分配给该进程的物理块。</p><blockquote><p>优点是可以<strong>动态</strong>增加进程物理块的数量，还能动态减少进程物理块的数量，在保证进程<strong>不会过多地调页</strong>的同时，也保持了系统的<strong>多道程序并发能力</strong>。</p><p>缺点是需要更复杂的实现，也需要更大的开销，但对比频繁地换入/换出所浪费的计算机资源，这种牺牲是值得的。</p></blockquote></li></ul></li><li><p><strong>没有</strong>固定分配 + 全局置换策略，因为对各个进程固定分配时，页数是不会变换的。</p></li></ul></li><li><p>调页策略：</p><blockquote><p>来自《王道》，一般会同时使用这两种策略</p></blockquote><ul><li>预调页策略：<ul><li>根据<strong>局部性原理</strong>，一次调入若干相邻的页可能会比一次调入一页更高效。</li><li>但若调入的一批页面中大多数都未被访问，则又是低效的。</li><li>因此，需要采用以<strong>预测</strong>为基础的预调页策略，将预计在不久之后便会被访问的页面预先调入内存。</li></ul></li><li>请求调页策略：<ul><li>进程在运行中需要访问的页面不在内存而提出请求，由系统将所需页面调入内存。</li><li>这种策略调入的页一定会被访问，且这种策略比较易于实现，因此在目前的虚拟存储器中大多采用此策略。</li><li>它的缺点是每次<strong>只调入一页</strong>，调入/调出页面数多时会花费过多的 I/O 开销。</li></ul></li></ul></li><li><p>抖动（颠簸）：</p><ul><li><p>在页面置换过程中，一种最糟糕的情形是，刚换出的页面马上又要换入主存，刚换入的页面马上又要换出主存，这种频繁的页面调度行为称为<strong>抖动或颠簸</strong>。</p></li><li><p>若一个进程在换页上用的时间多于执行时间，则这个进程就在颠簸。</p></li><li><p>频繁发生缺页中断（抖动）的主要原因：</p><ul><li>某个进程<strong>频繁访问的页面数目</strong>高于<strong>可用的物理页帧数目</strong>（驻留集）。</li><li>虚拟内存技术在内存中保留多个进程以提高系统效率。在稳定状态，几乎主存的所有空间都被进程块占据，处理机和操作系统可以直接访问到尽可能多的进程。</li><li>但如果管理不当，那么处理机的<strong>大部分时间</strong>都将用于调入调出页面，而不是执行进程的指令，因此会大大降低系统效率。</li><li><strong>所有</strong>页面替换策略都可能导致抖动。</li></ul><blockquote><p>因此引入「工作集」的概念，确定进程所需的帧数，防止抖动</p></blockquote></li></ul></li><li><p>工作集定义：</p><ul><li><p>工作集是指在<strong>某段时间间隔</strong>内，进程要访问的页面集合。它可以反映了进程在接下来的一段时间内<strong>很有可能会频繁访问</strong>的页面集合</p></li><li><p>基于<strong>局部性原理</strong>，可以用<strong>最近访问过的页面</strong>来确定工作集。</p></li><li><p>工作集 $W$ 可由时间 $t$ 和工作集窗口大小 $\Delta$ 来确定。</p><blockquote><p>例如，某进程对页面的访问次序如下：</p><div align="center"><img src=" /img/blog/os-note-images/image-20211205202735623.png"></div><p>假设系统为该进程设定的工作集窗口大小 $\Delta$ 为 $5$。在 $t_{1}$ 时刻，进程的工作集为 $\{2,3,5\}$。在 $t_{2}$ 时刻，进程的工作集为 $\{1,2,3,4\}$。</p></blockquote></li><li><p>对于局部性好的程序，<strong>工作集大小</strong>一般会比<strong>工作集窗口</strong> $\Delta$ 小很多。</p></li><li><p>抖动问题的工作集视角：</p><p>​    若分配给进程的物理块小于<strong>工作集大小</strong>，则该进程就很有可能频繁缺页导致抖动。</p></li><li><p>一般来说分配给进程的物理块数（即驻留集大小）要大于工作集大小。</p></li><li><p>工作集模型的原理：</p><ul><li>让操作系统<strong>跟踪每个进程的工作集</strong>，并为进程分配<strong>大于</strong>其工作集的物理块。</li><li>落在<strong>工作集内</strong>的页面需要调入<strong>驻留集</strong>中，而落在<strong>工作集外</strong>的页面可从驻留集中<strong>换出</strong>。</li><li>若还有空闲物理块，则可以<strong>再调一个进程</strong>到内存以增加多道程序数。</li><li>若所有进程的<strong>工作集之和</strong>超过了<strong>可用物理块</strong>数，则操作系统会<strong>暂停</strong>一个进程，将其<strong>页面调出</strong>并将其物理块分配给其他进程，防止出现抖动现象。</li></ul></li></ul></li></ul><h4 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h4><ul><li>Core i7 地址翻译的概况图：</li></ul><div align="center"><img src=" /img/blog/os-note-images/4.png"></div><ul><li><p>无 TLB 的地址翻译（命中）流程：</p><ol><li><p>处理器生成一个虚拟地址，并把它传送给 MMU。MMU 生成 <strong>PTE 地址</strong>（页表基址 + 虚拟页号），并从高速缓存/主存请求得到它。</p><blockquote><p>内存管理单元 Memory Management Unit，MMU 是 CPU 芯片上的专用硬件，负责地址翻译。</p></blockquote></li><li><p>高速缓存/主存向 MMU 返回 PTE。</p></li><li><p>MMU 构造<strong>物理地址</strong>，并把它传送给高速缓存/主存。</p></li><li><p>高速缓存/主存返回所请求的数据字给处理器。</p><blockquote><p>需要访问两次（及以上）高速缓存/主存。</p></blockquote></li></ol><div align="center"><img src=" /img/blog/os-note-images/image-20211206130519133.png"></div></li><li><p>TLB 的结构：</p><ul><li><p>在虚拟页号上的划分：</p><div align="center"><img src=" /img/blog/os-note-images/image-20211206125414501.png"></div></li><li><p>翻译流程（TLB 命中情况）：</p><ol><li><p>CPU 产生一个虚拟地址。</p></li><li><p>MMU 从 TLB 中取出相应的 PTE。</p></li><li><p>MMU 将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存/主存。</p></li><li><p>高速缓存/主存将所请求的数据字返回给 CPU。</p><blockquote><p>只需访问一次高速缓存/主存，即使在多级页表中也是如此，因为 TLB 存放的是最后一级页表的页表项。</p></blockquote><div align="center"><img src=" /img/blog/os-note-images/image-20211206130105103.png"></div></li></ol></li><li><p>当 TLB 不命中时，MMU 必须从高速缓存/主存中取出相应的 PTE。新取出的 PTE 存放在 TLB 中，可能会覆盖一个已经存在的条目。</p><blockquote><p>如果 TLB 不命中且缺页，<strong>新换入</strong>的页对应页表项会放入 <strong>TLB</strong> 中，所以缺页时还是只需要访问<strong>两次</strong>内存（第一次发现缺页，第二次用查 TLB 得到的页号访问内存）</p></blockquote></li></ul></li><li><p>高速缓存的三种组织方式：</p><blockquote><p>设物理地址位 $m$ 位。</p></blockquote><ul><li>直接映射（直相联）：</li></ul></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">标记 $t=m-s-b$ 位</th><th style="text-align:center">组索引 $s$ 位</th><th style="text-align:center">块内偏移 $b$ 位</th></tr></thead><tbody><tr><td style="text-align:center"></td></tr></tbody></table></div><p>  先通过组索引，找到高速缓存对应的组，每组只有一行（路），匹配它的标记，相等则命中。</p><ul><li>$g$ 路组相联：</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">标记 $t+g$ 位</th><th style="text-align:center">组索引 $s-g$ 位</th><th style="text-align:center">块内偏移 $b$ 位</th></tr></thead><tbody><tr><td style="text-align:center"></td></tr></tbody></table></div><p>  先通过组索引，找到高速缓存对应的组，每组有 $g$ 行（路），匹配 $g$ 个标记，相等则命中。</p><blockquote><p>用中间位作组索引的原因：</p><div align="center"><img src=" /img/blog/os-note-images/image-20211206133823597.png"></div><p>因为<strong>相邻</strong>的内存块（<strong>低位不同而高位相同</strong>）如果可以放在高速缓存<strong>不同的组</strong>，就不容易发生替换，即尽可能同时放入高速缓存。</p></blockquote><ul><li>全相联：</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">标记 $m-b$ 位</th><th style="text-align:center">块内偏移 $b$ 位</th></tr></thead><tbody><tr><td style="text-align:center"></td></tr></tbody></table></div><p>  匹配高速缓存<strong>所有标记</strong>，相等则命中。</p><h4 id="Linux-虚拟内存系统"><a href="#Linux-虚拟内存系统" class="headerlink" title="Linux 虚拟内存系统"></a>Linux 虚拟内存系统</h4><blockquote><p>整理自 PPT 和 CSAPP，《王道》没有，不知道会不会考</p></blockquote><ul><li><p>Linux 为<strong>每个进程</strong>维护了一个单独的虚拟地址空间，如下图。</p><div align="center"><img src=" /img/blog/os-note-images/image-20211206191650681.png"></div></li><li><p>内核虚拟内存包含内核中的代码和数据结构，其中某些区域被映射到<strong>所有进程共享</strong>的物理页面。</p></li><li><p>内核为系统中的每个进程维护一个单独的<strong>任务结构</strong>（源代码中的 <code>task_struct</code>），如下图。</p><div align="center"><img src=" /img/blog/os-note-images/image-20211206192040636.png"></div></li><li><p>任务结构中的元素包含或者指向<strong>内核运行该进程</strong>所需要的所有信息（例如PID、指向用户栈的指针、可执行目标文件的名字以及程序计数器）。</p></li><li><p>任务结构中的一个条目指向 <code>mm_Struct</code>，它描述了虚拟内存的当前状态。其中含有两个关键字段 <code>pgd</code> 和 <code>mmap</code>：</p><ul><li><p><code>pgd</code> 指向顶级页表（<strong>页全局目录</strong>）的基址，当内核运行这个进程时，就将 <code>pgd</code> 存放在 CR3 控制寄存器中。</p><blockquote><p><strong>区域</strong>定义：</p><ul><li>Linux 将<strong>虚拟内存</strong>组织成一些<strong>区域</strong>（或段）的集合。</li><li>一个区域就是已经存在着的（已分配的）虚拟内存的<strong>连续片</strong>，这些页是以某种方式相关联的。</li><li>例如，代码段、数据段、堆、共享库段，以及用户栈都是不同的区域。</li></ul></blockquote></li><li><p><code>mmap</code> 指向一个 <code>vm_area_structs</code>（区域结构）的链表，其中每个 <code>vm_area_structs</code> 都描述了当前<strong>虚拟地址空间</strong>的一个<strong>区域</strong>：</p><ul><li><p><code>vm_prot</code>：</p><p>​    描述这个区域内所有页的<strong>读写许可</strong>权限。</p></li><li><p><code>vm_flags</code>：</p><p>​    描述这个区域内的页面是与其他进程<strong>共享</strong>的还是这个进程<strong>私有</strong>的。</p></li></ul></li></ul></li><li><p>假设 MMU 在试图翻译某个虚拟地址 A 时，触发了一个缺页。这个异常导致控制转移到内核的缺页处理程序，处理程序随后就执行下面的步骤：</p><ol><li><p>判断虚拟地址 A 是否合法（越界）的，换句话说，A 是否在该进程的某个<strong>区域结构定义的区域</strong>内：</p><ul><li>缺页处理程序搜索区域结构的链表，把 A 和每个区域结构中的 vm_start 和 vm_end 做比较。</li><li>如果这个指令是不合法的，那么缺页处理程序就触发一个<strong>段错误</strong>，从而终止这个进程。</li></ul><blockquote><p>因为一个进程可以创建任意数量的新虚拟内存区域，所以顺序搜索区域结构的链表花销可能会很大。</p><p>因此在实际中，Linux 使用某些数据结构科技，例如在链表中构建了一棵树，并在这棵树上进行查找。</p></blockquote></li><li><p>判断试图进行的内存访问是否<strong>合法</strong>，即进程是否有读、写或者执行这个区域内页面的权限：</p><ul><li><p>例如，这个缺页是不是由一条试图对这个代码段里的<strong>只读页面进行写操作</strong>的存储指令造成的。</p></li><li><p>若不合法，缺页处理程序会触发一个保护异常，从而终止这个进程。</p></li></ul></li><li><p>其他情况正常换入页面，更新页表。</p></li></ol></li></ul><h4 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h4><ul><li><p>内存映射定义：</p><p>​    Linux 通过将一个<strong>虚拟内存区域</strong>与一个<strong>磁盘上的对象</strong>关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射。</p></li><li><p>映射对象：</p><ul><li>文件系统（磁盘）中的普通文件：<ul><li><strong>一个区域</strong>可以映射到一个<strong>普通磁盘文件</strong>的<strong>连续部分</strong>，例如一个可执行目标文件。</li><li>文件区被分成<strong>页大小的片</strong>，每一片包含一个<strong>虚拟页面</strong>的初始内容。</li><li>因为按需进行<strong>页面调度</strong>，所以这些虚拟页面没有实际交换进入物理<strong>内存</strong>，直到 CPU <strong>第一次引用</strong>到页面（即发射一个虚拟地址，落在地址空间这个页面的范围之内）。</li><li>如果区域比文件区要大，那么就用零来填充这个区域的剩下部分。</li></ul></li><li>匿名文件：<ul><li>一个区域也可以映射到一个<strong>匿名文件</strong>，匿名文件是由<strong>内核</strong>创建的，包含的全是<strong>二进制零</strong>。</li><li>CPU 第一次引用这样一个区域内的虚拟页面时，内核就在物理内存中找到一个<strong>合适的牺牲页面</strong>，如果该页面被<strong>修改</strong>过，就将这个页面换出来，用二进制零<strong>覆盖牺牲页面并更新页表</strong>，将这个页面标记为是驻留在内存中的。</li><li>注意在<strong>磁盘和内存</strong>之间并没有实际的数据传送。因为这个原因，<strong>映射到匿名文件</strong>的区域中的页面有时也叫做<strong>请求二进制零的页</strong>。</li></ul></li></ul></li><li><p>交换文件：</p><ul><li>无论在哪种情况中，一旦一个虚拟页面被<strong>初始化</strong>了，它就在一个由<strong>内核</strong>维护的专门的<strong>交换文件</strong>（交换空间或交换区域）之间换来换去。</li><li>交换空间<strong>限制</strong>着当前运行着的<strong>进程</strong>能够<strong>分配的虚拟页面</strong>的总数。</li></ul></li><li><p>共享对象和私有对象：</p><ul><li><p>一个对象可以被映射到虚拟内存的一个区域，要么作为<strong>共享对象</strong>，要么作为<strong>私有对象</strong>。</p></li><li><p>如果一个进程将一个<strong>共享对象</strong>映射到它的<strong>虚拟地址空间</strong>的一个区域内，那么这个进程对这个区域的任何<strong>写操作</strong>，对于那些也把这个共享对象映射到它们虚拟内存的其他进程而言，也是可见的。而且，这些变化也会反映在磁盘上的<strong>原始对象</strong>中。</p></li><li><p>而对一个映射到<strong>私有对象</strong>的区域做的改变，对于其他进程来说是<strong>不可见</strong>的，并且进程对这个区域所做的任何写操作都不会反映在<strong>磁盘上的对象中</strong>。</p></li><li><p>一个映射到<strong>共享对象</strong>的虚拟内存区域叫做<strong>共享区域</strong>，反之称为私有区域。</p><blockquote><p>假设进程 $1$ 将一个<strong>共享对象</strong>映射到它的虚拟内存的一个区域中，如图所示。现在假设进程 $2$ 将同一个共享对象映射到它的地址空间（并<strong>不一定</strong>要和进程 $1$ 在<strong>相同的虚拟地址</strong>处）。</p><div align="center"><img src=" /img/blog/os-note-images/image-20211206204751788.png"></div></blockquote></li></ul></li><li><p>写时复制：</p><ul><li><p><strong>私有对象</strong>使用一种叫做写时复制的巧妙技术被映射到虚拟内存中。</p></li><li><p>一个私有对象开始生命周期的方式基本上<strong>与共享对象的一样</strong>，在物理内存中<strong>只保存</strong>有私有对象的<strong>一份副本</strong>。</p></li><li><p>如图两个进程将一个<strong>私有对象</strong>映射到它们虚拟内存的不同区域，但是共享这个对象同一个物理副本。</p></li><li><p>对于每个映射私有对象的进程，<strong>相应私有区域的页表条目都被标记为只读</strong>，并且区域结构被标记为<strong>私有的写时复制</strong>。</p></li><li><p>只要没有进程试图<strong>写</strong>它自己的<strong>私有区域</strong>，它们就可以继续共享物理内存中对象的一个<strong>单独副本</strong>。</p></li><li><p>然而，只要有一个进程试图写私有区域内的某个页面，那么这个写操作就会触发一个<strong>保护故障</strong>：</p><ul><li>故障处理程序注意到保护异常是由于进程试图<strong>写私有的写时复制区域</strong>中的一个页面而引起的，它就会在<strong>物理内存</strong>中创建这个页面的一个<strong>新副本</strong>，更新<strong>页表条目</strong>指向这个<strong>新的副本</strong>，然后恢复这个页面的<strong>可写权限</strong>。</li><li>当故障处理程序返回时，CPU <strong>重新执行这个写操作</strong>，现在在新创建的页面上这个<strong>写操作</strong>就可以<strong>正常执行</strong>了。</li></ul><blockquote><p>通过延迟私有对象中的副本直到最后可能的时刻，写时复制最充分地使用了稀有的物理内存。</p></blockquote><div align="center"><img src=" /img/blog/os-note-images/image-20211206210446323.png"></div></li></ul></li><li><p>内存映射的四种类型：</p><blockquote><p>PPT 写有但没找到出处，看看就得了。</p><p>因为映射对象分为有普通文件和匿名文件，这两种映射又有私有映射和共享映射之分，所以可创建 $4$ 种类型的映射。</p></blockquote><ul><li><p>普通文件的共享映射：</p><p>​    多个进程映射到同一个文件，内存修改会被写回到后备文件。用于不同进程间共享内存，以及大文件读写。</p></li><li><p>普通文件的私有映射：</p><p>​    多个进程映射到同一个文件，采用<strong>写时拷贝</strong>的方式，一般用在加载共享代码库以及数据段，节省内存。</p></li><li><p>匿名文件的共享映射：</p><p>​    <strong>内核创建</strong>一个初始都是 $0$ 的物理内存区域，然后<strong>父子进程</strong>使用同一个映射，用于关联进程共享内存。</p></li><li><p>匿名文件的私有映射：</p><p>​    <strong>内核创建</strong>一个初始都是 $0$ 的物理内存区域，用作进程的私有内存分配，如 <code>malloc()</code> 底层分配大块内存。</p></li></ul></li><li><p>分析 <code>fork()</code> 函数：</p><ul><li>当 <code>fork()</code> 函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的 PID。</li><li>为了给这个新进程创建虚拟内存，它创建了当前进程的 <code>mm_struct</code>、区域结构和页表的原样副本。</li><li>它将两个进程中的每个页面都标记为<strong>只读</strong>，并将两个进程中的每个区域结构都标记为<strong>私有的写时复制</strong>。</li><li>当 <code>fork()</code> 在新进程中返回时，新进程现在的虚拟内存刚好和调用 <code>fork()</code> 时存在的虚拟内存相同。</li><li>当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，这样就为每个进程保持了私有地址空间的抽象概念。</li></ul></li><li><p>分析函数 <code>execve("a.out", NULL, NULL);</code>：</p><ul><li><p>意义:</p><p>​    <code>execve()</code> 函数在<strong>当前进程</strong>中加载并运行包含在可执行目标文件 <code>a.out</code> 中的程序，用 <code>a.out</code> 程序有效地替代了当前程序。</p></li><li><p>加载并运行 <code>a.out</code> 需要以下几个步骤：</p><ul><li><p>删除已存在的<strong>用户区域</strong>：</p><p>​    删除当前进程虚拟地址的用户部分中的已存在的区域结构。</p></li><li><p>映射私有区域：</p><ul><li>为新程序的代码、数据、<code>.bss</code> 和栈区域创建新的区域结构。</li><li>所有这些新的区域都是<strong>私有的写时复制</strong>的。</li><li>代码和数据区域被映射为 <code>a.out</code> 文件中的 <code>.text</code> 和 <code>.data</code> 区。</li><li><code>.bss</code> 区域是请求二进制零的，映射到<strong>匿名文件</strong>，其大小包含在 <code>a.out</code> 中。</li><li>栈和堆区域也是请求<strong>二进制零</strong>的，初始长度为零。</li></ul></li><li><p>映射共享区域：</p><p>​    如果 <code>a.out</code> 程序与共享对象（或目标）链接，比如标准 C 库 <code>libc.so</code>，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。</p><div align="center"><img src=" /img/blog/os-note-images/image-20211206214228820.png"></div></li><li><p>设置程序计数器（PC）：</p><ul><li><code>execve()</code> 做的最后一件事情就是设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。</li><li>下一次调度这个进程时，它将从这个入口点开始执行。Linux 将根据需要换入代码和数据页面。</li></ul></li></ul></li></ul></li></ul><h2 id="I-O-管理和存储"><a href="#I-O-管理和存储" class="headerlink" title="I/O 管理和存储"></a>I/O 管理和存储</h2><blockquote><p>基本来自《王道》和 PPT</p></blockquote><h3 id="四种-I-O-控制方式"><a href="#四种-I-O-控制方式" class="headerlink" title="四种 I/O 控制方式"></a>四种 I/O 控制方式</h3><blockquote><p>典中典，计组学过前三个，第四个要特别注意<span class="">⚛</span></p></blockquote><ul><li><p>程序直接控制方式：</p><ul><li><p>当某进程需要输入/输出数据时，由 CPU 向设备控制器发出一条 I/O 指令启动设备工作（对于输出操作，则 CPU 还要向数据寄存器中存放输出数据）。</p></li><li><p>在设备输入/输出数据期间，CPU <strong>不断地循环</strong>进行<strong>查询</strong>设备<strong>状态寄存器</strong>的值（检查 I/O 工作是否完成）。</p></li><li><p>若完成，对输入操作来说CPU则从数据寄存器中取出数据，然后进行下一次的输入/输出数据或结束。</p><blockquote><p>由于 CPU 的高速性和 I/O 设备的低速性，致使 CPU 的绝大部分时间都处于等待 I/O 设备的循环测试中，造成了 CPU 资源的极大浪费。</p></blockquote></li></ul></li><li><p>中断驱动方式：</p><p>​    思想是允许 I/O 设备<strong>主动打断 CPU</strong> 的运行并请求服务，从而 CPU 不用等待，使得其向 I/O 控制器发送读命令后可以继续做其他有用的工作。</p><div align="center"><img src=" /img/blog/os-note-images/image-20211206221411112.png"></div><blockquote><p>虽然 CPU 不用等待设备读完，但是数据中的每个字在<strong>磁盘缓存与 I/O 控制器</strong>之间的传输都必须经过 CPU。</p><p>因此可以设计有一定处理能力的外围设备，使得这部分工作由它来完成。</p></blockquote></li><li><p>DMA 直接存取方式：</p><ul><li><p>DMA 方式特点：</p><ul><li>基本单位是数据块。</li><li>数据在<strong>设备与内存</strong>之间传输，不经手 CPU。</li><li>仅在传送一个或多个数据块的<strong>开始和结束</strong>时，才需 CPU 干预，整块数据的传送是在 DMA 控制器的控制下完成的。</li></ul></li><li><p>流程：</p><ol><li><p>当一个进程要求设备输入数据时，CPU 对 DMA 进行初始化工作，设置各寄存器：</p><ul><li><p>内存地址寄存器：</p><p>​    存放数据的内存起始地址</p></li><li><p>传送字节数寄存器：</p><p>​    要输入数据的字节数</p></li><li><p>控制状态寄存器：</p><p>​    控制字（中断允许、DMA 启动位 $=1$）</p></li><li><p>启动位被置 $1$，</p><p>​    则启动 DMA 控制器开始进行数据传输。</p></li></ul></li><li><p>该进程放弃 CPU，进入<strong>阻塞</strong>等待状态，等待第一批数据输入完成。进程调度程序调度其他进程运行。</p></li><li><p>由 DMA 控制器控制整个数据的传输：</p><ul><li>当输入设备将一个数据送入 DMA 控制器的<strong>数据缓冲寄存器</strong>后，DMA 控制器<strong>立即取代 CPU</strong>，接管<strong>数据地址总线</strong>的控制权（CPU 工作周期挪用），将数据送至相应的<strong>内存单元</strong>。</li><li>DMA 控制器中的传输字节数寄存器计数减 $1$。</li><li>恢复 CPU 对数据地址总线的控制权。</li><li>循环直到数据传输完毕。</li></ul></li><li><p>当一批数据输入完成，DMA 控制器向 CPU 发出中断信号，请求中断运行进程并转向执行中断处理程序。</p></li><li><p>中断程序首先保存被中断进程的现场，唤醒等待输入数据的那个进程，使其变成<strong>就绪状态</strong>，恢复现场，<strong>返回被中断的进程继续执行</strong>。</p></li><li><p>当<strong>进程调度</strong>程序调度到要求输入数据的那个进程时，该进程就到指定的内存地址中读取数据进行处理。</p></li></ol><blockquote><p>DMA 控制方式与中断驱动方式的主要区别：</p><ul><li>中断驱动方式在<strong>每个数据需要传输时</strong>中断 CPU，而 DMA 控制方式则是在所要求传送的一批数据全部传送结束时才中断 CPU</li><li>中断驱动方式数据传送是在中断处理时由 CPU 控制完成的，而 DMA 控制方式则是在 DMA 控制器的控制下完成的。</li></ul></blockquote></li></ul></li><li><p>通道控制方式：</p><ul><li><p>I/O 通道是指专门负责输入/输出的<strong>处理机</strong>，是 DMA 方式的发展，是一种硬件技术，进一步减少了 CPU 的干预。</p></li><li><p>实现 CPU、通道和 I/O 设备三者的并行操作，从而更有效地提高整个系统的资源利用率。</p></li><li><p>CPU 要完成一组相关的读（或写）操作及有关控制时，只需向 I/O 通道发送一条 I/O 指令，以给出其所要执行的<strong>通道程序的首地址</strong>和要访问的 I/O 设备，通道接到该指令后，执行<strong>通道程序</strong>便可完成 CPU 指定的 I/O 任务，数据传送结束时向 CPU 发中断请求。</p></li><li><p>通道、设备控制器和设备三者之间的控制关系：</p><p>​    <strong>通道</strong>控制<strong>设备控制器</strong>，设备控制器控制<strong>设备</strong>工作</p></li><li><p>I/O 通道与一般处理机的区别：</p><p>​    通道指令的类型单一，没有自己的内存，通道所执行的<strong>通道程序</strong>是放在主机的<strong>内存</strong>中的，也就是说通道与 CPU 共享内存。</p><blockquote><p><strong>I/O 通道与 DMA 方式的区别</strong>：</p><ul><li>DMA 方式需要 CPU 来控制传输的数据块大小、传输的内存位置，而通道方式中这些信息是由通道控制的。</li><li>每个 DMA 控制器对应一台设备与内存传递数据，而<strong>一个通道</strong>可以控制<strong>多台设备</strong>与内存的数据交换。</li><li>DMA 方式以存储器为核心，中断控制方式以 CPU 为核心。因此 DMA 方式能与 CPU 并行工作。</li><li>DMA 方式传输批量的数据，中断控制方式的传输则以字节为单位。</li></ul></blockquote></li></ul><blockquote><p>  模仿《王道》对 $4$ 种 I/O 控制方式的形象总结：</p><p>  我 $\to$ CPU</p><p>  三食堂商户 $\to$ 外设</p><p>  食物 $\to$ 数据</p><p>  假设只有读操作，即取餐。</p><ul><li><p>程序直接控制：</p><p>​    商户<strong>没有渠道通知</strong>我已做好食物，我必须一直站在商户前，等食物做好，这就浪费了我不少的时间<span class="">😠</span>。</p></li><li><p>中断驱动方式：</p><p>​    三食堂冒菜有<strong>通知设备</strong>告诉我可以去取餐了，每当一个食物做好时（假设我买了很多碗食物），设备震动提醒我去拿，与程序直接控制能省去我不少麻烦，但<strong>每做好一个食物就让我去取一次</strong>，仍然比较浪费我的时间<span class="">😕</span></p></li><li><p>DMA 方式：</p><p>​    我花钱雇一位<strong>单线助理</strong>，并向助理<strong>交代好食物所在位置，放在哪里</strong>等信息，把通知设备给了助理，助理负责把食物取回来并放在我希望的位置，取完所有食物后，助理就要给我报告一次（大大节省了我的时间:happy:）。</p></li><li><p>通道方式：</p><p>​    助理拥有更高的<strong>自主权</strong>，与 DMA 方式相比，他可以决定把食物存放在哪里，怎么取食物，而不需要我操心。我有可能在多个商户下了单，一位DMA 类的助理只能负责在<strong>一个商户</strong>取餐，但通道类助理却可以去<strong>多个商户</strong>取餐<span class="">😁</span>。</p></li></ul></blockquote></li></ul><h3 id="缓冲技术"><a href="#缓冲技术" class="headerlink" title="缓冲技术"></a>缓冲技术</h3><ul><li><p>使用缓冲区的目的：</p><ul><li>缓和 CPU 与 I/O 设备间<strong>速度不匹配</strong>的矛盾。</li><li>减少对 CPU 的<strong>中断频率</strong>，放宽对 CPU 中断响应时间的限制。</li><li>解决基本数据单元大小（即数据粒度）不匹配的问题。</li><li>提高 CPU 与 I/O 设备之间的<strong>并行性</strong>。</li></ul></li><li><p>缓冲技术的实现方法：</p><ul><li><p><strong>硬件</strong>缓冲：</p><p>​    利用<strong>专门的硬件寄存器</strong>作为缓冲区，一般由外设自带的专用寄存器构成。例如 Printer、CD-ROM 等，成本较高。</p></li><li><p><strong>软件</strong>缓冲：</p><p>​    借助<strong>操作系统</strong>的管理，在<strong>内存</strong>中专门开辟若干单元作为<strong>缓冲区</strong>。</p></li></ul><blockquote><p>下面部分是《王道》的内容，PPT 内容较少，笔者不是很理解其中的过程，看看知道大概意思就好。</p></blockquote></li><li><p>缓冲区特点：</p><ul><li>当缓冲区的数据<strong>非空</strong>时，不能往缓冲区<strong>冲入数据</strong>，只能从缓冲区把数据<strong>传出</strong>。</li><li>当缓冲区为<strong>空</strong>时，可以往缓冲区<strong>冲入数据</strong>，但必须把缓冲区<strong>充满</strong>后，才能从缓冲区把数据传出。</li></ul></li><li><p>缓冲技术：</p><ul><li><p>单缓冲：</p><ul><li>在<strong>设备和 CPU</strong>之间设置一个缓冲区。</li><li>设备和 CPU 交换数据时，先把被<strong>交换数据</strong>写入<strong>缓冲区</strong>，然后需要数据的设备或处理机从缓冲区取走数据。</li><li>外设与 CPU 对缓冲区的操作是<strong>串行</strong>的，不能对缓冲区同时读写。</li></ul></li><li><p>双缓冲：</p><ul><li><p>根据单缓冲的特点，CPU 在传送时间内处于空闲状态，由此引入双缓冲。</p></li><li><p>I/O 设备输入数据时<strong>先装填到缓冲区 $1$</strong>，在缓冲区 $1$ <strong>填满后</strong>才开始装填缓冲区 $2$。</p></li><li><p>与此同时 CPU 可以从缓冲区 $1$ 中取出数据放入用户进程处理，当缓冲区 $1$ 中的数据处理完后，若缓冲区 $2$ 已<strong>填满</strong>，则 CPU 又从缓冲区 $2$ 中取出数据放入用户进程处理，而 I/O 设备又可以装填缓冲区 $1$。</p><blockquote><p>必须等缓冲区 $2$ <strong>充满</strong>才能让 CPU 从缓冲区 $2$ 取出数据。</p></blockquote></li><li><p>双缓冲机制提高了处理机和输入设备的并行操作的程度，可以同时读写。</p></li></ul><blockquote><ul><li><p>对于字符设备，若采用行输入方式：</p><ul><li>双缓冲可使用户在输入第一行后，在 CPU <strong>执行第一行</strong>中的命令的同时，用户可<strong>继续向第二缓冲区</strong>输入下一行数据。</li><li>单缓冲情况下则必须<strong>等待一行数据</strong>被 CPU 提取完毕才可输入下一行的数据。</li></ul></li><li><p>若两台机器之间通信仅配置了单缓冲，则它们在任意时刻都只能实现<strong>单方向</strong>的数据传输。</p></li><li><p>为了实现双向数据传输，必须在两台机器中都设置<strong>两个缓冲区</strong>，一个用作<strong>发送缓冲区</strong>，另一个用作<strong>接收缓冲区</strong>。</p><div align="center"><img src=" /img/blog/os-note-images/image-20211207111349709.png"></div></li></ul></blockquote></li><li><p>循环缓冲：</p><ul><li>包含多个大小相等的缓冲区，每个缓冲区中有一个<strong>链接指针</strong>指向下一个缓冲区，多个缓冲区构成一个环形链表。</li><li>循环缓冲用于输入/输出时，还需要有两个指针 <code>in</code> 和 <code>out</code>（PPT 的 <code>Empty</code> 和 <code>Full</code>）：<ul><li>对输入而言，<code>in</code> 指针指向可以输入数据的第一个<strong>空缓冲区</strong>；</li><li>对输出而言，<code>out</code> 指针指向可以提取数据的第一个<strong>满缓冲区</strong></li></ul></li><li>当 <code>Full = Empty</code> 时，要么全为空缓冲区，要么全为满缓冲区。</li></ul></li><li><p>缓冲池：</p><ul><li><p>由多个系统公用的缓冲区组成，所有进程均可以共享，由系统管理程序统一管理，负责分配、回收工作。</p></li><li><p>缓冲区按其使用状况可以形成 $3$ 个队列：</p><ul><li><strong>空缓冲</strong>队列</li><li><strong>装满输入数据</strong>的缓冲队列（输入队列）</li><li><strong>装满输出数据</strong>的缓冲队列（输出队列）。</li></ul></li><li><p>具有 $4$ 种缓冲区：</p><ul><li>用于收容输入数据的工作缓冲区</li><li>用于提取输入数据的工作缓冲区</li><li>用于收容输出数据的工作缓冲区</li><li>用于提取输出数据的工作缓冲区</li></ul></li><li><p>输入流程：</p><ul><li>当<strong>输入进程</strong>需要<strong>去输入数据</strong>时，便从<strong>空缓冲队列</strong>的队首摘下一个空缓冲区，把它作为收容输入工作缓冲区，然后把输入数据输入其中，装满后再将它挂到<strong>输入队列队尾</strong>。</li><li>当<strong>计算进程</strong>需要<strong>输入的数据</strong>时，便从<strong>输入队列</strong>的队首取得一个缓冲区作为提取输入工作缓冲区，计算进程从中提取数据，数据用完后再将它挂到<strong>空缓冲队列尾</strong>。</li></ul></li><li><p>输出流程：</p><ul><li>当<strong>计算进程</strong>需要<strong>去输出数据</strong>时，便从<strong>空缓冲队列</strong>的队首取得一个空缓冲区，作为收容输出工作缓冲区，当其中装满输出数据后，再将它挂到<strong>输出队列队尾</strong>。</li><li>当要输出时，<strong>输出进程</strong>从<strong>输出队列</strong>的队首中取得一个装满输出数据的缓冲区，作为提取输出工作缓冲区，当数据提取完后，再将它挂到<strong>空缓冲队列的队尾</strong>。</li></ul><blockquote><p>总结：</p><ul><li><p>输入：</p><p>​    输入进程 $\to$ 空缓冲队列队首 $\to$ 输入队列队尾 $\to$ 计算进程 $\to$ 输入队列队首 $\to$ 空缓冲队列队尾</p></li><li><p>输出：</p><p>​    计算进程 $\to$ 空缓冲队列队首 $\to$ 输出队列队尾 $\to$ 输出进程 $\to$ 输出队列队首 $\to$ 空缓冲队列队尾</p></li></ul></blockquote></li></ul></li></ul></li><li><p>PPT 上的补充：</p><ul><li>Linux 系统为了提高读写磁盘的效率，会先将数据放在一块 buffer 中。</li><li>在<strong>写磁盘</strong>时并不是立即将数据<strong>写到磁盘</strong>中，而是先写入这块 buffer 中。</li><li>如果 buffer 未写到磁盘，重启系统后，就可能造成数据丢失。</li><li><code>sync</code> 命令用来 flush 文件系统 buffer，这样数据才会真正的写到磁盘中，并且 buffer 才能够释放出来。</li><li><code>sync</code> 命令会强制将数据写入磁盘中，并释放该数据对应的 buffer，所以常常会在<strong>写磁盘后</strong>输入 <code>sync</code> 命令来将数据真正的写入磁盘。</li><li>如果不去手动的输入 <code>sync</code> 命令来真正的去写磁盘，Linux 系统也会有两种写磁盘的时机：<ul><li>kflush 内核线程周期性的去写磁盘。</li><li>buffer 已满不得不写。</li></ul></li></ul></li></ul><h3 id="SPOOLing-技术（假脱机技术）"><a href="#SPOOLing-技术（假脱机技术）" class="headerlink" title="SPOOLing 技术（假脱机技术）"></a>SPOOLing 技术（假脱机技术）</h3><ul><li><p>全称 Simultaneous Peripheral Operation On Line <strong>外部设备同时联机操作</strong>，又称假脱机操作。</p></li><li><p>思想和目的：</p><ul><li><p>以<strong>空间换时间</strong></p></li><li><p>将<strong>独占设备</strong>改造成<strong>共享设备</strong>，是一种虚拟设备技术</p></li><li><p>缓和 CPU 的高速性与 I/O 设备低速性之间的<strong>矛盾</strong>，将低速 I/O 设备上的数据传送到<strong>高速磁盘</strong>。</p><blockquote><p>磁盘是一种高速设备，在与内存交换数据的速度上优于打印机、键盘、鼠标等中低速设备。</p></blockquote></li></ul></li><li><p>输入井和输出井：</p><ul><li><p>输入井和输出井是指在<strong>磁盘</strong>上开辟出的两个存储区域。</p></li><li><p><strong>输入井</strong>模拟脱机输入时的磁盘，用于收容 <strong>I/O 设备</strong>输入的数据。</p></li><li><p><strong>输出井</strong>模拟脱机输出时的磁盘，用于收容<strong>用户程序</strong>的输出数据。</p><blockquote><p>PPT 上写的「输出井用于收容 I/O 设备的输出数据」，输入/输出如果是对设备来说的，这种说法可以接受。</p><p>但是一般输入/输出都是对计算机说的，例如鼠标作为输入设备，打印机作为输出设备。</p></blockquote></li></ul></li><li><p>输入缓冲区和输出缓冲区：</p><ul><li>输入缓冲区和输出缓冲区是在<strong>内存</strong>中开辟的两个缓冲区。</li><li><strong>输入</strong>缓冲区用于<strong>暂存由输入设备</strong>送来的数据，以后再传送到<strong>输入井</strong>。</li><li><strong>输出</strong>缓冲区用于<strong>暂存从输出井</strong>送来的数据，以后再传送到<strong>输出设备</strong>。</li></ul></li><li><p>输入进程和输出进程：</p><ul><li><p>输入流程：</p><ul><li><strong>输入进程</strong>模拟脱机输入时的外围控制机，将用户要求的数据从输入机通过<strong>输入缓冲区</strong>再送到<strong>输入井</strong>。</li><li>当 CPU 需要<strong>输入的数据</strong>时，直接将数据从<strong>输入井</strong>读入内存。</li></ul></li><li><p>输出流程：</p><ul><li><p><strong>输出进程</strong>模拟脱机输出时的外围控制机，把用户要求输出的数据先从<strong>内存</strong>送到<strong>输出井</strong>。</p></li><li><p>待输出设备空闲时，再将输出井中的数据经过<strong>输出缓冲区</strong>送到<strong>输出设备</strong>。</p><blockquote><p>如输出设备是打印机，则把要打印的数据送输出井，CPU 不用等待打印机取完数据再做其他事情。</p><p>并且向磁盘输出数据的速度比向打印机输出数据的速度快。</p></blockquote></li></ul></li></ul></li><li><p>独占设备变共享设备的实现过程：</p><p>​    截获向某独享设备输出的数据，暂时保存到<strong>内存缓冲区或磁盘文件</strong>中，并进行<strong>排队</strong>，之后逐个输出到外设上。</p><blockquote><p>SPOOLing 技术实现了<strong>虚拟设备</strong>功能。</p><p>多个进程同时使用一独享设备，而对每一进程而言，都认为自己独占这一设备，从而实现了设备的<strong>虚拟分配</strong>，该设备是<strong>逻辑</strong>上的设备。</p></blockquote></li></ul><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><blockquote><p>概念较多且杂<span class="">👨🏭</span>，整理自 PPT 和《王道》，参考了一些网上资料</p></blockquote><h4 id="磁盘概念"><a href="#磁盘概念" class="headerlink" title="磁盘概念"></a>磁盘概念</h4><p>在读/写操作期间，磁头固定，磁盘在下面高速旋转。</p><ul><li><p>磁盘盘面上的数据存储在一组同心圆中，称为磁道。每个磁道与磁头一样宽，一个盘面有上千个磁道。</p></li><li><p>磁道又划分为几百个扇区，每个扇区固定存储大小（通常为 $512\rm~B$），一个扇区也称为一个盘块。</p></li><li><p>由于扇区按固定圆心角度划分（<strong>不同半径的磁道扇区数相同</strong>），所以密度从最外道向里道增加，磁盘的存储能力受限于最内道的最大记录密度。</p></li><li><p><strong>扇区</strong>就是磁盘可寻址的最小存储单位，磁盘地址用「柱面号 盘面号 扇区号（或块号）」表示。</p></li><li><p>物理盘以<strong>扇区</strong>为单位进行编址，它是<strong>硬盘读写的基本单位</strong>。</p></li><li><p>在磁盘上进行一次读写操作花费的时间由寻道时间、延迟时间和传输时间决定：</p><ul><li><p>寻道时间是将磁头移动到指定磁道所需要的时间，</p></li><li><p>旋转时间是磁头定位到某一磁道的扇区（块号）所需要的时间，</p></li><li><p>传输时间是从磁盘读出或向磁盘写入数据所经历的时间。</p><blockquote><p>一般来说，寻道时间因为要移动磁臂，所以占用时间最长。</p><div align="center"><img src=" /img/blog/os-note-images/image-20211214211950929.png"></div></blockquote></li></ul></li></ul><h4 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h4><blockquote><p>应该必考</p></blockquote><ul><li><p>First Come First Severed，FCFS 先来先服务磁盘调度：</p><ul><li>按请求磁道的先后顺序</li><li>保证公平性，效率不高</li></ul></li><li><p>Shortest-Seek-Time First，SSTF 最短寻道时间优先磁盘调度：</p><ul><li>运用贪心思想，先访问与当前磁头所在磁道距离最近的磁道，以便使<strong>每次的寻找时间最短</strong>。</li><li>性能好，存在<strong>饥饿</strong>问题，有些远磁道总是不能被访问。</li></ul></li><li><p>SCAN 扫描/电梯算法磁盘调度：</p><ul><li><p>在磁头<strong>当前移动方向</strong>上选择与当前磁头所在磁道距离最近的请求作为下一次服务的对象。</p></li><li><p>实际上就是在<strong>最短寻找时间优先算法</strong>的基础上规定了磁头运动的方向，SCAN = SSTF + 中途不回折，<strong>一直移动到 $0$ 或最大磁道才回头</strong>。</p></li><li><p>不存在饥饿，但是会导致<strong>延迟不均</strong>，不利于远离磁头一端的访问请求。</p><div align="center"><img src=" /img/blog/os-note-images/image-20211207141045588.png"></div></li></ul></li><li><p>C-SCAN 循环扫描/电梯算法磁盘调度：</p><ul><li><p>在 SCAN 的基础上规定磁头<strong>只在一个方向上提供服务</strong>，<strong>回返时</strong>直接快速移动至另一端而<strong>不服务任何请求</strong>，下图就是只在向外的方向服务。</p></li><li><p><strong>两端请求</strong>都能很快处理，解决 SCAN 算法对两端磁道请求的不公平的问题。</p><div align="center"><img src=" /img/blog/os-note-images/image-20211207141105692.png"></div></li></ul></li><li><p>C-LOOK 磁盘调度：</p><ul><li><p>C-SCAN 基础上，磁头移动只需要到达<strong>最远端的一个请求</strong>即可返回，<strong>不需要</strong>到达磁盘<strong>端点</strong>。</p></li><li><p>更加合理，综合了以上的优点。</p><div align="center"><img src=" /img/blog/os-note-images/image-20211207141800618.png"></div></li></ul></li></ul><h4 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h4><ul><li><p>磁盘初始化：</p><ul><li>一个新的磁盘只是一个含有磁性记录材料的空白盘。</li><li>在磁盘能存储数据之前，它必须<strong>分成扇区</strong>以便磁盘控制器能进行读和写操作，这个过程称为低级格式化（<strong>物理格式化</strong>）。</li><li>低级格式化使每个扇区的数据结构通常由头、数据区域（通常为 $512\rm~B$ 大小）和尾部组成，头部和尾部包含了一些磁盘控制器所使用的信息。</li><li>为了使用磁盘存储<strong>文件</strong>，操作系统还需要将自己的数据结构记录在磁盘上：<ul><li>第一步将磁盘分为由一个或多个柱面组成的<strong>分区</strong>（即我们熟悉的 C 盘、D 盘等形式的分区）。</li><li>第二步对物理分区进行<strong>逻辑格式化</strong>（创建文件系统），操作系统将初始的<strong>文件系统</strong>数据结构存储到磁盘上，这些数据结构包括空闲和已分配的空间及一个初始为空的目录。</li></ul></li></ul></li><li><p>扇区编号：</p><blockquote><p>与 PPT 的计算不同，一般题目会给出从 $0$ 还是 $1$ 开编址</p></blockquote><ul><li><p>$\rm CHS$ 模式：</p><ul><li>采用 3D 参数：<ul><li>磁柱面数（Cylinders）</li><li>磁头数（Heads），即盘面数</li><li>扇区数（Sectors per track）</li></ul></li><li>这里扇区其实是从 $1$ 开始编址的（出于某些历史原因），盘面和柱面则是从 $0$ 开始，即第一个扇区编号为 $(0,0,1)$。</li></ul></li><li><p>$\rm LBA$ 编号：</p><ul><li><p>是逻辑 $\rm CHS$ 寻址的简单换算，变为线性寻址。</p></li><li><p>假设当前 $\rm CHS$ 编号为 $(c,h,s)$ 公式为 $\mathrm{LBA}=c\times \mathrm{H}\times \mathrm{S}+h\times \mathrm{S} + (s-1)$</p><blockquote><p>$\rm S$ 为一个磁道所含扇区数，$\rm H$ 为一个柱面所含盘面数</p></blockquote></li><li><p><a href="https://en.wikipedia.org/wiki/Logical_block_addressing">维基百科为证</a>：</p><div align="center"><img src=" /img/blog/os-note-images/image-20211207151622177.png"></div></li></ul></li></ul></li><li><p>磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取<strong>一定扇区长度</strong>的数据放入内存。</p><blockquote><p>这样做的理论依据是<strong>局部性原理</strong>：</p><p>​    当一个数据被用到时，其附近的数据也通常会马上被使用。</p></blockquote></li></ul><h4 id="磁盘布局"><a href="#磁盘布局" class="headerlink" title="磁盘布局"></a>磁盘布局</h4><ul><li><p>物理盘以扇区为单位进行编址，它是<strong>硬盘读写</strong>的<strong>基本单位</strong>。</p></li><li><p>一块<strong>硬盘</strong>从逻辑上可以理解为连续的<strong>一维扇区</strong>序列。</p></li><li><p>整个硬盘的第 $1$ 个扇区存储着<strong>主引导记录</strong>（MBR）：</p><ul><li>引导可执行代码</li><li>硬盘基本分区表，最多包含 $4$ 个<strong>基本分区</strong>位置信息</li></ul><blockquote><ul><li>计算机启动时需要运行一个初始化程序（<strong>自举程序</strong>），它初始化 CPU、寄存器、设备控制器和内存等，接着启动操作系统。</li><li>为此，该自举程序应找到磁盘上的操作系统内核，装入内存，并转到起始地址，从而开始操作系统的运行。</li><li>自举程序通常保存在 ROM 中，为了避免改变自举代码而需要改变 ROM 硬件的问题，因此只在 ROM 中保留<strong>很小的自举装入程序</strong>，将完整功能的自举程序保存在磁盘的<strong>启动块</strong>（启动块位于磁盘的 MBR 中）上</li></ul></blockquote></li><li><p>除了第 $1$ 个扇区之外，其余扇区可以划分为至多 $4$ 个基本分区。</p></li><li><p>每个分区的<strong>第 $1$ 个扇区</strong>预留，可以作为<strong>引导扇区</strong>。</p></li><li><p>每个分区除第 $1$ 个扇区外的其他部分还可以看做一个<strong>硬盘</strong>（同样具有类似「主引导记录」的<strong>可扩展分区引导记录</strong>），继续递归分区</p></li><li><p>可扩展分区：</p><p>​    可以继续划分成「分区」的硬盘分区，其划分可以无限制进行，直到硬盘划分完成为止。</p></li><li><p>可扩展<strong>分区引导记录</strong>：</p><p>​    可扩展分区中第 $2$ 个扇区中的内容（第 $1$ 个为引导扇区）。</p></li><li><p>引导分区：</p><p>​    标记有<strong>可引导标记</strong>的硬盘分区，这种分区有引导扇区和引导文件。</p></li></ul><h4 id="SSD-固态硬盘"><a href="#SSD-固态硬盘" class="headerlink" title="SSD 固态硬盘"></a>SSD 固态硬盘</h4><blockquote><p>来自 PPT，有的班没讲，可以跳过</p></blockquote><ul><li><p>由 NAND FLASH 作为<strong>存储介质</strong>，特点有：</p><ul><li><strong>顺序</strong>访问比随机访问快</li><li>随机<strong>写</strong>较慢（擦除块需要较长的时间，修改一页需要将块中所有页<strong>复制</strong>到新的块中）</li></ul></li><li><p>与机械硬盘对比：</p><ul><li><p>优点：</p><p>​    没有移动部件，读写更快、能耗更低、更结实。</p></li><li><p>缺点：</p><ul><li><p>会磨损</p></li><li><p>只能把存储单元从 $1$ 变为 $0$，导致写数据无法直接覆盖，即不能在已有数据的存储单元上直接修改。</p><blockquote><ul><li><p>对于<strong>机械硬盘</strong>来说，就像是写<strong>铅笔字</strong>，可以说是<strong>无限次的写入次数</strong></p></li><li><p>对于<strong>固态硬盘</strong>来说，就像是写<strong>钢笔字</strong>，固态硬盘中需要把有效数据抄到草稿纸（缓存）上，将原先的一整页撕掉（标记为无效），然后再把新的数据和草稿上的有效数据放回去（空的新页）。</p></li></ul></blockquote></li></ul></li></ul></li><li><p>FTL，Flash Translation Layer 闪存翻译层模块：</p><ul><li><p>SSD 内部软件的一个主要模块，用于兼容运行在<strong>机械硬盘上的文件系统</strong>。</p></li><li><p>FTL 要实现作为中间层，对外提供的是块接口的功能。作为主机端，所看到的 SSD 是一个和机械硬盘一样的<strong>块设备</strong>。</p></li><li><p>FTL 从主机文件系统接收块级请求，经过 FTL 的处理，产生 flash 的各种控制命令。</p></li><li><p>由三部分组成：</p><ul><li><p>地址映射：</p><p>​    对于文件系统而言，它所看到的存储空间是一个线性的连续空间，对 SSD 的请求是<strong>逻辑扇区号</strong>，FTL 要转换成 NAND FLASH 中的<strong>物理页号</strong>。</p></li><li><p>损耗平衡：</p><ul><li><p>Flash 中每个块都有一定的擦写次数限制。故不能让某一个块被写次数较多，而其他块被写的次数较少，即尽量平均。</p></li><li><p><strong>动态</strong>损耗平衡：</p><p>​    在请求到达时，选取擦除次数较少的块作为请求的物理地址。</p></li><li><p><strong>静态</strong>损耗平衡：</p><ul><li>在运行一段时间后，有些块存放的数据一直没有更新（<strong>冷数据</strong>），而有些块的数据经常性的更新（<strong>热数据</strong>）。</li><li>那些存放冷数据的块的擦除次数远小于存放热数据的块。</li><li>将<strong>冷数据</strong>从原块取出，<strong>存放</strong>在擦除次数过多的块；原来存放冷数据的块被释放出来，接受热数据的擦写。</li></ul></li></ul></li><li><p>垃圾回收：</p><ul><li>SSD 在使用过程中，对文件持续反复的修改，块中会产生大量失效页，需要把有效的数据从块上搬走，然后擦除该块用来接收新的数据。</li><li>垃圾回收需要考虑到冷热数据、磨损平衡和读写延迟。</li><li>热数据会被经常更新，在垃圾回收流程中应该避免回收热数据。</li><li>如果垃圾回收流程控制不好，会造成读写延迟，时而流畅，时而卡顿。</li></ul></li></ul></li></ul></li></ul><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><blockquote><p>整理自《王道》和 PPT，杂乱无章，体现在《王道》的题目基本和 PPT 不相干，笔记也不太好做<span class="">🤕</span></p><p>文件系统的定义：</p><ul><li><p>操作系统中负责管理和存储文件信息的软件机构称为文件管理系统，简称文件系统。</p></li><li><p>文件系统由三部分组成：</p><p>​    与文件管理有关的软件、被管理文件及实施文件管理所需的数据结构。</p></li></ul></blockquote><h3 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h3><blockquote><p>逻辑结构是用户组织数据的结构形式，物理结构是操作系统组织物理存储块的结构形式</p></blockquote><ul><li><p>物理盘块连续分配：</p><ul><li><p>连续分配要求<strong>每个文件</strong>在磁盘上占有<strong>一组连续的块</strong>，需要记录起始盘块和所占盘块个数。</p></li><li><p>连续的磁盘地址定义了磁盘上的一个线性排序，使访问磁盘时需要的<strong>寻道数和寻道时间</strong>最小。</p></li><li><p>优点：</p><p>​    简单快速，支持顺序访问和直接访问。</p></li><li><p>缺点：</p><ul><li>类似<strong>内存管理</strong>的<strong>连续分配方式</strong>中的<strong>动态分区分配</strong>。</li><li>文件长度不宜<strong>动态增加</strong>，因为一个文件<strong>末尾后的盘块</strong>可能已分配给其他文件，一旦需要增加，就需要<strong>大量移动盘块。</strong></li><li>反复增删文件产生大量<strong>外部碎片</strong>。</li></ul></li></ul></li><li><p>链式（链接）分配：</p><ul><li><p>采取离散分配的方式，<strong>消除了外部碎片</strong>，因此显著提高了磁盘空间的利用率。</p></li><li><p>无须事先知道文件的大小，可<strong>动态增长</strong>，对文件的<strong>增、删、改</strong>也非常方便。</p></li><li><p>分类：</p><ul><li><p>隐式链接：</p><ul><li>每个文件对应一个磁盘块的<strong>链表</strong>。</li><li>磁盘块分布在磁盘的任何地方，除最后一个盘块外，每个盘块都有指向<strong>下一个盘块的指针</strong>，这些指针对用户是透明的。</li><li><strong>目录</strong>包括文件<strong>第一块的指针</strong>和<strong>最后一块的指针</strong>（用于追加文件）。</li><li>缺点：<ul><li>无法<strong>直接访问</strong>盘块，只能通过指针顺序访问文件。</li><li>盘块<strong>指针</strong>会消耗一定的存储<strong>空间</strong>。</li><li><strong>稳定性不高</strong>，系统在运行过程中由于软件或硬件错误导致链表中的指针丢失或损坏，会导致文件数据的丢失。</li></ul></li></ul></li><li><p>显式链接：</p><ul><li><p>把用于链接文件各物理块的指针，从每个物理块的块末尾中提取出来，<strong>显式</strong>地存放在内存的一张<strong>链接表</strong>中。</p></li><li><p>该表在整个磁盘中仅设置一张，称为<strong>文件分配表</strong>（File AllocationTable，FAT）</p></li><li><p>每个<strong>表项</strong>中存放对应块的<strong>下一块链接指针</strong>，即下一个盘块号。</p></li><li><p>文件的第一个盘块号记录在<strong>目录</strong>中，后续的盘块可通过查 FAT 找到。</p></li><li><p>FAT 表在系统启动时就会被读入内存，因此查找 FAT 的过程是在<strong>内存</strong>中进行的，因此不仅显著地提高了<strong>检索速度</strong>，而且明显减少了<strong>访问磁盘</strong>的次数。</p><blockquote><p><span class="">🔔</span> </p><p>​    据说显式链接是可以实现随机访问的，因为要随机读一个文件的一个块，先在内存中读 FAT 找块所在位置，不用按照隐式链接一样多次读磁盘，只需读一次磁盘就行。但是 PPT 没有讲这部分内容，所以遇到题目链式分配默认指隐式链接。</p></blockquote></li></ul></li></ul></li></ul></li><li><p>索引分配：</p><ul><li><p>每个文件都有其<strong>索引块</strong>，这是一个磁盘块地址的数组，由<strong>文件的所有的盘块号</strong>构成。</p></li><li><p>连续和链式分配的有效折衷，支持<strong>直接（随机）访问</strong>，没有<strong>外部碎片</strong>。</p></li><li><p>缺点是由于索引块的分配，增加了系统存储空间的开销。</p></li><li><p>采用多种方式解决问题：</p><ul><li><p>链接方案：</p><p>​    一个索引块通常为一个磁盘块，因此它本身能直接读写。为了处理大文件，可以将多个索引块链接起来。</p></li><li><p>多级索引：</p><p>​    多级索引使第一层索引块指向第二层的索引块，第二层索引块再指向文件块，以此类推更高级的索引。</p></li><li><p><strong>混合索引</strong>：</p><p>​    将多种索引分配方式相结合的分配方式。例如，系统既采用直接地址，又采用单级索引分配方式或两级索引分配方式。</p><blockquote><p><span class="">💃</span> 作业有出，必考，下面是《王道》中一个使用混合索引的例子：</p><div align="center"><img src=" /img/blog/os-note-images/image-20211207214656200.png"></div><ul><li>直接地址：<ul><li>为了提高对文件的检索速度，在索引结点中可设置 $10$ 个直接地址项，这里每项中所存放的是该文件数据所在盘块的盘块号。</li><li>假如每个盘块的大小为 $4\rm~KB$，当文件不大于 $40\rm~KB$ 时，便可直接从索引结点中读出该文件的全部盘块号。</li></ul></li><li>一次间接地址：<ul><li>对于大、中型文件，只采用直接地址并不现实。可再利用索引结点中的地址项来提供一次间接地址。</li><li>一次间址块也就是<strong>索引块</strong>，系统将分配给文件的多个盘块号记入其中。</li><li>在一次间址块中可存放 $1024$ 个盘块号，因而允许文件长达 $1024\times4\rm~KB=4\rm~MB$。</li></ul></li><li>多次间接地址：<ul><li>当文件长度大于 $\rm 4~MB + 40~KB$ （一次间接地址与 $10$ 个直接地址项)时，系统还须采用二次间接地址分配方式。</li><li>系统此时在二次间接地址块中记入所有一次间接地址块的盘号。</li><li>在采用二次间接地址方式时，文件的最大长度可达 $4\rm~GB$。</li><li>同理，三次间接地址允许的文件最大长度可达 $4\rm~TB$。</li></ul></li></ul></blockquote></li></ul></li></ul><div align="center"><img src=" /img/blog/os-note-images/image-20211207211730809.png"></div></li></ul><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><ul><li><p>在<strong>检索</strong>目录文件的过程中，只用到了<strong>文件名</strong>，仅当找到<strong>与查找文件名匹配</strong>的<strong>目录项</strong>时，才需要从该目录项中读出该文件的物理地址。</p></li><li><p>也就是说，在检索目录时，文件的<strong>其他描述信息</strong>不会用到，也<strong>不需要</strong>调入内存。</p></li><li><p>有的系统（如 UNIX，以及实验要用的 Ext2）采用了<strong>文件名和文件描述信息</strong>分离的方法，文件描述信息单独形成一个称为<strong>索引结点</strong>的数据结构，简称 i 结点。在文件目录中的每个<strong>目录项</strong>仅由文件名和<strong>指向该文件所对应的 i 结点的指针</strong>构成。</p><div align="center"><img src=" /img/blog/os-note-images/image-20211207213405548.png"></div></li></ul><h3 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h3><ul><li><p>文件系统作用：</p><ul><li>PPT 中的描述：<ul><li>将盘块转换成文件集，方便用户访问。</li><li>类比将 CPU 资源和地址空间封装成进程。</li></ul></li><li>《王道》中的描述：<ul><li>对于<strong>用户</strong>而言，文件系统最主要的功能是实现对<strong>文件的基本操作</strong>，让用户可以<strong>按名存储和查找文件</strong>，组织成合适的结构，并应当具有基本的文件共享和文件保护功能。</li><li>对于<strong>操作系统</strong>本身而言，文件系统还需要管理<strong>与磁盘的信息交换</strong>，完成文件<strong>逻辑结构和物理结构</strong>上的变换，组织文件在磁盘上的存放，采取好的<strong>文件排放顺序</strong>和<strong>磁盘调度方法</strong>以提升整个系统的性能。</li></ul></li></ul></li><li><p>文件系统的数据结构：</p><ul><li><p>文件控制块（FCB）：</p><ul><li>存放控制文件需要的各种信息的数据结构，以实现「按名存取」。FCB 的有序集合称为<strong>文件目录</strong>，一个 FCB 就是一个文件<strong>目录项</strong>。</li><li>FCB 主要包含以下信息：<ul><li>基本信息，如文件名、文件的物理位置、文件的逻辑结构、文件的物理结构等。</li><li>存取控制信息，如文件存取权限等。</li><li>使用信息，如文件建立时间、修改时间等。</li></ul></li><li>UFS（UNIX 文件系统）称之为<strong>索引结点</strong>（inode）。</li></ul></li><li><p>引导控制块：</p><p>​    包括从该卷引导<strong>操作系统</strong>的信息（可为空，没有操作系统），通常为卷的第一块，UFS 称之为<strong>引导块</strong>。</p></li><li><p>卷控制块：</p><p>​    包括卷（或分区）的详细信息，如分区的块数、块的大小、空闲块的数量和指针、空闲 FCB 的数量和指针。UFS称之为<strong>超级块</strong>。</p></li><li><p>每个文件系统的目录结构：</p><p>​    用来组织文件，UFS 中包含文件名和相关的索引结点。</p></li></ul></li><li><p>分区空闲盘块的管理方法：</p><ul><li><p><strong>空闲位图</strong>（位向量）：</p><p>​    每一位对应一个盘块是否被占用，但可能很大，放不进内存。</p></li><li><p><strong>空闲链表</strong>：</p><p>​    空闲块链接成链表。分配<strong>一个（或少量的）</strong>空闲盘块速度很快，虽然分配多个块很慢，但一般每次申请都只需一个或几个空闲块。</p></li></ul></li><li><p>磁盘缓存：</p><p>​    在内存中缓存磁盘上的少部分盘块，下图来自 PPT，实在不知道咋总结了<span class="">😥</span>。</p><div align="center"><img src=" /img/blog/os-note-images/image-20211207220806012.png"></div></li></ul><h3 id="文件系统的保护"><a href="#文件系统的保护" class="headerlink" title="文件系统的保护"></a>文件系统的保护</h3><ul><li><p>文件用来存放用户的信息，用户应该能控制对文件的访问，如只允许读。这些读/写/执行（r/w/x）权限放在文件头。</p></li><li><p>RAID 冗余保护：</p><ul><li><p>从外部看：</p><p>​    RAID 像一个磁盘。</p></li><li><p>在内部：</p><p>​    RAID 由多个磁盘、内存（包括易失性和非易失性）以及一个或多个处理器来管理系统。</p></li><li><p>性能：</p><p>​    可以并行使用多个磁盘，大大加快 I/O 时间。</p></li><li><p>RAID $1$：</p><p>​    直接磁盘镜像。</p><blockquote><p>数据分散：</p><p>​    在多个磁盘上分散数据（也叫数据条带），存取数据时，并行读取多个磁盘，大大提高传输率。</p><ul><li><p>位级分散：</p><p>​    在多个磁盘上分散<strong>每个字节的各个位</strong>，如有 $4$ 个磁盘，每个字节的 $i$ 和 $4+i$ 位，分散在第 $i$ 个磁盘上。</p></li><li><p>块级分散：</p><p>​    <strong>一个文件的块</strong>可分散在多个磁盘上，对于 $n$ 个磁盘，一个文件的块 $i$，可以存在磁盘 $(i \% n) +1$ 上。</p></li></ul></blockquote></li><li><p>RAID $0$：</p><p>​    采用数据条带（数据分散）技术，增加传输效率，但没有任何校验信息。</p></li><li><p>RAID $2$ 和 RAID $3$：</p><ul><li>都是将数据分散（条块化）分布于不同的硬盘上，采用<strong>位级分散</strong>。</li><li>RAID $2$ 采用<strong>汉明码</strong>检验和纠错，需要额外的多个硬盘进行存储。</li><li>RAID $3$ 使用专用校验盘（一个）存<strong>奇偶校验值</strong>。</li></ul></li><li><p>RAID $4$：</p><ul><li>原理同 RAID $3$，只是采用的是<strong>块级分散</strong>。</li><li>对于每次写操作，都需要重新计算奇偶变化，因此 RAID $4$ 要执行<strong>四次磁盘</strong> I/O：<ul><li>两次读取（读目标磁盘块，读奇偶校验块）</li><li>两次写入（写目标磁盘块，写奇偶校验块）</li></ul></li><li>数据盘可以并行读写，但奇偶检验盘只有一个，<strong>不能并行</strong>操作，导致<strong>对不同盘的写</strong>受到检验盘的瓶颈限制。</li></ul></li><li><p>RAID $5$：</p><ul><li>采用<strong>块级分散</strong>，校验块分布在多个盘上，<strong>消除</strong>校验盘瓶颈。</li><li>写操作可以同时发生在完全不同的磁盘上，而 RAID $4$ 不行。</li><li>一块盘掉线的情况下，RAID $5$ 照常工作。</li></ul></li></ul></li></ul><h3 id="EXT2-文件系统"><a href="#EXT2-文件系统" class="headerlink" title="EXT2 文件系统"></a>EXT2 文件系统</h3><div align="center"><img src=" /img/blog/os-note-images/3790176-4ece675e15d09e8e.jpeg"></div><ul><li>整个硬盘的第 $1$ 个扇区存储着<strong>主引导记录</strong>（MBR），其余扇区被划分到 $4$ 个基本分区。</li><li>分区中第一个扇区为<strong>引导扇区</strong>（Boot Sector），引导扇区的大小是确定的，用来存储磁盘分区信息和启动信息，任何文件系统都不能使用引导扇区，引导扇区之后才是 EXT2 文件系统的开始。</li><li>除了引导扇区之外，EXT2 磁盘分区被顺序划分为若干个<strong>磁盘块组</strong>（Block Group），并且从 $0$ 开始编号。</li><li>每个块组按照相同的方式组织，每个块组包含等量的物理块（即块组<strong>大小是相同</strong>的；物理分区最后一个块组可能小些），在块组的<strong>数据块</strong>中存储文件或目录。</li><li>磁盘<strong>块组</strong>中的磁盘块按顺序被组织成：<ul><li>一个用作<strong>超级块</strong>（Super Block）的磁盘块：<ul><li>存放了文件系统超级块的一个拷贝，多个块组中的超级块形成<strong>冗余</strong>。</li><li>在某个或少数几个超级块被破坏时，可用于<strong>恢复</strong>被破坏的超级块信息。</li><li>系统运行期间，把超级块复制到系统缓冲区内，只需把<strong>块组 $0$ 的超级块</strong>读入<strong>内存</strong>，其它块组的超级块做为<strong>备份</strong>。</li></ul></li><li>多个记录<strong>块组描述符</strong>（GDT）的磁盘块：<ul><li>块组描述符用来描述一个<strong>磁盘块组</strong>的相关信息，整个分区<strong>分成多少个块组</strong>就对应有多少个<strong>块组描述符</strong>。</li><li>存放于超级块所在块的下一个块中。</li><li>保存在这个块组的 inode 表起始位置，数据块起始位置，空闲的 inode 和数据块个数等信息。</li><li>类似超级块有多份拷贝。</li></ul></li><li>一个记录数据块位图的磁盘块</li><li>一个记录索引结点位图的磁盘块</li><li>多个用作索引结点表的磁盘块（采用<strong>混合索引</strong>）</li><li>多个用作数据块的磁盘块</li></ul></li><li>存储在磁盘上的文件与用户所「看到」的文件有所不同：<ul><li>用户感觉，文件在逻辑上是连续的</li><li>在磁盘上，存储文件数据的磁盘块可能分散在磁盘各处</li></ul></li></ul><h3 id="Windows-的-FAT-文件系统实现"><a href="#Windows-的-FAT-文件系统实现" class="headerlink" title="Windows 的 FAT 文件系统实现"></a>Windows 的 FAT 文件系统实现</h3><ul><li>FAT 卷结构示意图：</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">引导区</th><th style="text-align:center">文件分配表 FAT $1$</th><th style="text-align:center">文件分配表 FAT $2$</th><th style="text-align:center">根目录</th><th style="text-align:center">其他目录和文件</th></tr></thead><tbody><tr><td style="text-align:center"></td></tr></tbody></table></div><p>  维基百科图：</p>  <div align="center"><img src=" /img/blog/os-note-images/image-20211208111917437.png"></div><blockquote><p>下面无情复制 PPT，未知是否会考到 <span class="">🖍</span></p></blockquote><ul><li><p>引导区：</p><div align="center"><img src=" /img/blog/os-note-images/image-20211208112159457.png"></div></li><li><p>文件分配表 FAT $1$：</p><ul><li><p>功能：</p><p>​    记录和描述整个卷使用情况。</p></li><li><p>FAT 文件系统格式信息：</p><ul><li>FAT $12$/FAT $16$/FAT $32$</li><li>数字越大，FAT 卷容量与簇大小的越大</li></ul></li><li><p>卷上<strong>每一簇</strong>对应 FAT 中<strong>一项</strong>，记录<strong>该簇使用情况</strong>，包含簇地址号和使用标志信息，使用标志信息 ＝ $0$，则该簇空闲未用</p></li><li><p>每个目录/文件的文件分配链（簇链）：</p><p>​    <strong>链尾（结束）标志信息</strong>为 $\rm0xFFF/0xFFFF/0xFFFFFFFF$</p></li></ul></li><li><p>文件分配表 FAT $2$：</p><ul><li>是 FAT $1$ 的镜像<strong>备份</strong>。</li><li>因为文件分配表对卷非常重要，它的内容破坏会导致部分文件无法访问，甚至导致整卷瘫痪。</li></ul></li><li><p>后面两个非常恶心，就不做笔记了 <span class="">🙅</span>，直接进入<strong>文件访问过程</strong>：</p><div align="center"><img src=" /img/blog/os-note-images/image-20211208115014073.png"></div><p>目的：</p><p>​    读出文件 <code>\aa\bb\ccc.dat</code>的内容：</p><blockquote><p>查找 <code>aa</code> 过程用<font color="#549c05">绿色</font>框线标出，查找 <code>bb</code> 用<font color="#0f4fad">蓝色</font>框线标出，查找 <code>ccc.dat</code> 用<font color="#c1cc03">黄色</font>框线标出。</p></blockquote><ol><li>「根目录」不用通过 FAT 表找到，应该是可以知道其簇位置的。然后查簇中的目录项，找到含目录名 = <code>aa</code> 的目录项。</li><li><code>aa</code> 目录项中查出该<strong>目录文件</strong>的<strong>首簇号</strong> = $2$。</li><li>查 FAT $1$ 中以第 $2$ 簇为头的文件分配<strong>簇链</strong>（$2\to6$），检索簇号为 $2$ 和 $6$ 的簇内容，找出含目录名 = <code>bb</code> 的目录项。</li><li>从 <code>bb</code> 目录项中查出该目录文件的首簇号 = $7$。</li><li>查 FAT $1$ 中以第 $7$ 簇为头的文件分配簇链（只有 $7$），检索簇号为 $7$ 的簇内容，找出含文件名 = <code>ccc.dat</code> 的目录项。</li><li>从 <code>ccc.dat</code> 目录项中查出该文件的首簇号 = $4$。</li><li>查 FAT $1$ 中以第 $4$ 簇为头的文件分配簇链（$4\to8\to5$），读出簇号为 $4$，$8$ 和 $5$ 的簇内容，即得到了文件 <code>ccc.dat</code> 的内容。</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hitsz</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
