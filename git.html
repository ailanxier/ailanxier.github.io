<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png"><link rel="icon" href="/img/avatar.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="Zeyu Dong"><meta name="keywords" content=""><meta name="description" content="这是 Git 学习笔记，记录了一些值得记录的 Git 魔法（废话），便于灵活查找 Git 知识，不需要再百度搜索用法。"><meta property="og:type" content="article"><meta property="og:title" content="Git 学习笔记"><meta property="og:url" content="https://ailanxier.top/git"><meta property="og:site_name" content="Ailanxier"><meta property="og:description" content="这是 Git 学习笔记，记录了一些值得记录的 Git 魔法（废话），便于灵活查找 Git 知识，不需要再百度搜索用法。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://ailanxier.top/img/home/git.jpg"><meta property="article:published_time" content="2022-01-18T12:56:09.140Z"><meta property="article:modified_time" content="2022-01-28T09:22:36.000Z"><meta property="article:author" content="Zeyu Dong"><meta property="article:tag" content="Git"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://ailanxier.top/img/home/git.jpg"><title>Git 学习笔记 - Ailanxier</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"ailanxier.top",root:"/",version:"1.9.0",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"§"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!1,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"Vnw3P6XfzGV1nFXBCmueJQuN-gzGzoHsz",app_key:"ximSsc1aMmHfi7SNO8jMNm9F",server_url:"https://vnw3p6xf.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml"};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.0.0"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Ailanxier</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/bg/post.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="Git 学习笔记"></span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> Zeyu Dong </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-01-18 20:56" pubdate>2022年1月18日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 21k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i>175 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar category-bar" style="margin-right:-1rem"><div class="category-list"><div class="category row nomargin-x"><a class="category-item list-group-item category-item-action col-10 col-md-11 col-xm-11" title="科技笔记" id="heading-d1017ef05bc094a24cdc93120e875df3" role="tab" data-toggle="collapse" href="#collapse-d1017ef05bc094a24cdc93120e875df3" aria-expanded="true">科技笔记 <span class="list-group-count">(1)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-d1017ef05bc094a24cdc93120e875df3" role="tabpanel" aria-labelledby="heading-d1017ef05bc094a24cdc93120e875df3"><div class="category-post-list"><a href="/git" title="Git 学习笔记" class="list-group-item list-group-item-action active"><span class="category-post">Git 学习笔记</span></a></div></div></div></div></aside></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">Git 学习笔记</h1><p class="note note-info">本文最后更新于：2022年1月28日 下午</p><div class="markdown-body"><div class="note note-success"><p>资料主要来自：</p><ol><li><a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2">ProGit 2nd Edition (2014) 中文版</a></li><li><a target="_blank" rel="noopener" href="https://git-scm.com/docs">Git Reference</a></li><li><a target="_blank" rel="noopener" href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Branching 中文网站</a></li></ol><p>基于目前普遍使用的 Git 最新版本，记录了一些较为有用的 Git 科技。</p><p>推荐到 <a target="_blank" rel="noopener" href="https://github.com/ailanxier/ailanxier.github.io/releases/tag/git">Github 仓库</a> 下载该博客的 PDF 版本查看。</p></div><h2 id="Git-基本信息"><a href="#Git-基本信息" class="headerlink" title="Git 基本信息"></a>Git 基本信息</h2><h3 id="Git-特性"><a href="#Git-特性" class="headerlink" title="Git 特性"></a>Git 特性</h3><ul><li><p>Git 和其它版本控制系统的主要差别在于对待数据的方法：</p><ul><li><p>其他系统：</p><p>​ 存储每个文件与初始版本的差异，如图：</p><div align="center"><img src="../img/blog/git-note-images/delta.png" srcset="/img/loading.gif" lazyload></div></li><li><p>Git：</p><p>​ 存储项目随时间改变的<strong>快照</strong>，把数据看作是对小型文件系统的一组快照。每次 commit 或保存项目状态时，Git 对当时的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改，Git <strong>不再重新存储</strong>该文件，而是只保留一个链接指向之前存储的文件。Git 对待数据更像是一个<strong>快照流</strong>：</p><div align="center"><img src="../img/blog/git-note-images/snapshots.png" srcset="/img/loading.gif" lazyload></div></li></ul></li><li><p>Git 保护文件完整性：</p><ul><li>Git 中所有数据在存储前都计算<strong>校验和</strong>，不能在不改变校验和的情况下修改文件。</li><li>计算校验和的机制叫做 <strong>SHA-1 散列</strong>（hash，哈希），由 40 个十六进制字符组成。</li><li>Git 以校验和来引用文件，而不是文件名。</li></ul></li><li><p>Git 一般只增加数据，难以清除数据库中数据，使得 Git 操作一般都是<strong>可逆的</strong></p></li></ul><h3 id="「三棵树」-🌳"><a href="#「三棵树」-🌳" class="headerlink" title="「三棵树」 🌳"></a>「三棵树」 🌳</h3><p>Git 项目的三个工作区域（文件的集合）：</p><ul><li><strong>Git 仓库</strong>，.git directory，保存项目的元数据和对象数据库的地方。</li><li><strong>暂存区域</strong>，或 Index，或 Staging Area，保存了<strong>下次将提交的文件列表信息</strong>，一般在 Git 仓库目录中。有时候也被称作「索引」，不过一般还是叫暂存区域。</li><li><strong>工作目录</strong>，Working Directory(Tree)，对项目的<strong>某个版本</strong>独立提取出来的内容，放在磁盘上可以使用或修改</li></ul><h3 id="Git-基础操作"><a href="#Git-基础操作" class="headerlink" title="Git 基础操作"></a>Git 基础操作</h3><ul><li><p><code>git config</code>：</p><ul><li><p>用于设置控制 Git 外观和行为的配置变量，它们存储在三个不同的位置：</p><ul><li><p><code>/etc/gitconfig</code> 文件:</p><p>使用 <code>--system</code> 选项读写该文件，包含系统上每一个用户及他们仓库的通用配置。</p></li><li><p><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code> 文件：</p><p>使用 <code>--global</code> 选项读写该文件，只针对当前用户，一般 Windows 设置此处。</p></li><li><p>当前使用仓库的 Git 目录中的 config 文件（就是 <code>.git/config</code>）：</p><p>针对该仓库。</p><div class="note note-info"><p>每一个级别覆盖上一级别的配置。</p></div></li></ul></li><li><p>用户信息：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git config --global user.name <span class="hljs-string">"用户名"</span></span><br><span class="hljs-meta">  $</span><span class="bash"> git config --global user.email 邮箱</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>Git 操作别名 <code>alias</code>：</p><ul><li><p>相当于 <code>define</code>，不用输入复杂的操作命令，只需要输入它的别名</p></li><li><p>以 <code>git log</code> 的显示优化为例子，可以以 Git 图形象展示分支和提交情况，并涂上颜色 <span>🖍</span></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit --date=relative<br></code></pre></td></tr></tbody></table></figure></li><li><p>对这一操作起别名 <code>showlog</code>，截取 <code>git</code> 之后的部分：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global alias.showlog "log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit --date=relative"<br></code></pre></td></tr></tbody></table></figure></li></ul></li><li><p>设置编辑器：</p><p>​ 默认编辑器为 Vim，入门不太友好，如果配置有 VSCode 或其他编辑器，可以修改默认编辑器：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git config --global core.editor <span class="hljs-string">"code --wait"</span></span><br></code></pre></td></tr></tbody></table></figure></li><li><p><code>git config --list</code> 命令来列出所有 Git 配置</p></li></ul></li><li><p>获取<strong>帮助文档</strong>的三种方式：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">help</span> &lt;verb&gt;</span><br><span class="hljs-meta">$</span><span class="bash"> git &lt;verb&gt; --<span class="hljs-built_in">help</span></span><br><span class="hljs-meta">$</span><span class="bash"> man git-&lt;verb&gt;</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>获取 Git 仓库</p><ul><li><code>git init</code> 创建 <code>.git</code> 的子目录，含有初始化的 Git 仓库中所有的必须文件，此时三棵树只有工作目录，其他两棵树都为空，后续可以添加远程仓库。</li><li><code>git clone</code> 克隆现有的仓库。</li></ul></li><li><p><strong>忽略文件</strong>：</p><ul><li><p>对于不希望 Git 加入版本控制的文件，可以通过 <code>.gitignore</code> 文件，列出要忽略的文件模式，一行一个规则（所有空行或者以 <code>＃</code> 开头的行都会被 Git 忽略）。</p></li><li><p>经典格式：</p><ul><li><p>按文件名忽略单个文件：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 忽略当前文件夹下的 a 文件：</span><br>a<br><span class="hljs-comment"># 忽略所有子目录下的 a 文件</span><br>*/a<br></code></pre></td></tr></tbody></table></figure></li><li><p>按后缀忽略文件：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 忽略所有的 .a 文件</span><br>*.a<br><span class="hljs-comment"># 用 ! 否定忽略 test.a 文件, 即使前面忽略了所有的 .a 文件</span><br>!test.a<br><span class="hljs-comment"># 忽略 /b/test.a,不能忽略 /b/b/test.a</span><br>b/*.a<br><span class="hljs-comment"># 忽略 b 目录及其子目录下所有的 .a 文件</span><br>b/**/*.a<br></code></pre></td></tr></tbody></table></figure></li><li><p>忽略文件夹：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 忽略根目录下的 a 文件夹，以下等价</span><br>a/<br>/a/<br>/a/*<br><span class="hljs-comment"># 忽略 a 文件夹, 不管是根目录下的 /a/, 还是子目录下的 /child/a/</span><br>a/*<br></code></pre></td></tr></tbody></table></figure></li><li><p>否定的格式和忽略格式一样，只需要加 <code>!</code></p></li><li><p>glob 模式规则（简化版正则表达式规则）：</p><ul><li><p>以星号 <code>*</code> 通配任意个字符</p></li><li><p>以问号 <code>?</code> 通配单个字符</p></li><li><p>以方括号 <code>[]</code> 包含单个字符的匹配列表：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 忽略 debug0.log、debugA.log 等</span><br>debug[a-zA-Z0-<span class="hljs-number">9</span>].log      <br> <span class="hljs-comment"># 仅忽略 debug0.log、debug1.log</span><br>debug[01].log       	 <br><span class="hljs-comment"># 不忽略 debug0.log、debug1.log</span><br>debug[!01].log     		  <br></code></pre></td></tr></tbody></table></figure></li></ul></li></ul></li><li><p>要注意的细节：</p><ul><li><p><code>gitignore</code> 是从上到下一行一行匹配，<strong>后面的会覆盖前面</strong>的。</p></li><li><p>默认编码是 GBK，所以<strong>不能识别中文</strong>。</p></li><li><p>对于已经加入版本控制的文件，不能仅通过修改 <code>.gitignore</code> 来取消跟踪，还要使用：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git update-index --assume-unchanged 文件路径</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>一般对于各种语言和项目有 <code>.gitignore</code> 模板</p></li></ul></li></ul></li></ul><h2 id="Git-本地操作"><a href="#Git-本地操作" class="headerlink" title="Git 本地操作"></a>Git 本地操作</h2><h3 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h3><ul><li><p><strong>工作目录</strong>下的每一个文件处于三种状态之一：</p><ul><li><p><strong>已跟踪</strong>，指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于<strong>未修改 Unmodified，已修改 Modified 或已放入暂存区状态 Staged</strong>。</p><blockquote><p>初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。</p></blockquote></li><li><p><strong>已忽略</strong>，在提交前已经被 <code>.gitignore</code> 规则忽略。</p></li><li><p><strong>未忽略且未跟踪</strong>，不是以上两种状态的文件</p></li><li><p>状态转换：</p><div align="center"><img src="../img/blog/git-note-images/status.png" srcset="/img/loading.gif" lazyload></div></li></ul></li><li><p><code>git status</code> 查看文件状态：</p><ul><li><p>会显示了<strong>当前所在分支</strong>，以及这个分支同远程服务器上对应的分支是否偏离</p></li><li><p>输出格式：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">Changes to be committed:<br><span class="hljs-comment"># 已添加到暂存区的状态，包含 modified, new file, renamed, deleted</span><br><br>Changes <span class="hljs-keyword">not</span> staged <span class="hljs-keyword">for</span> commit:<br><span class="hljs-comment"># 工作目录的状态，未添加到暂存区，包含 modified, deleted</span><br>	<br>Untracked files:<br><span class="hljs-comment"># 未忽略且未跟踪的新文件</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>使用 <code>-s</code> 选项让输出更简洁：</p><ul><li><p>例子输出：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git status -s</span><br>M  README<br>MM Rakefile<br>A  lib/git.rb<br>?? LICENSE.txt<br></code></pre></td></tr></tbody></table></figure></li><li><p>状态分为<strong>两列</strong>，<strong>左列</strong>为上述所谓的<strong>暂存区状态</strong>，<strong>右列</strong>为<strong>工作目录状态</strong>。</p></li><li><p><code>M</code> 表示文件被修改过，<strong>左边</strong>的 <code>M</code> 表示该文件被修改了<strong>并放入了暂存区</strong>，<strong>右边</strong>的 <code>M</code> 表示该文件被修改了但是还<strong>没放入暂存区</strong>。同时具有两列状态的还有 <code>D</code>，表示一个<strong>已跟踪文件被删除</strong>。</p><blockquote><p>上面 <code>Rakefile</code> 文件可能经历了<strong>两次修改</strong>，第一次修改后，加入到了暂存区中，有了左边的 <code>M</code>，之后再进行第二次修改，未加入到暂存区，此时就会得到右边的 <code>M</code>。若再将该文件放入暂存区，则只会输出左边的 <code>M</code>。</p></blockquote></li><li><p><code>A</code> 表示文件新添加到暂存区中，之前可能处于为未跟踪状态，只会出现在<strong>左边</strong>。同样只会出现在左边的还有<strong>更名</strong>操作产生的状态 <code>R</code>。</p></li><li><p><code>??</code> 表示未忽略且未跟踪的新文件。</p></li></ul></li><li><p>当 <code>git status</code> 输出 <code>working tree clean</code> 时，或 <code>-s</code> 选项无输出时，表示当前没有修改，三棵树保持一致。许多命令都要求在 <code>working tree clean</code>，以防丢失修改。</p></li></ul></li></ul><h3 id="Git-个人开发操作"><a href="#Git-个人开发操作" class="headerlink" title="Git 个人开发操作"></a>Git 个人开发操作</h3><ul><li><p>查看文件差异：</p><ul><li><p>直接上图：</p><div align="center"><img src="../img/blog/git-note-images/diff.png" srcset="/img/loading.gif" lazyload></div></li><li><p><code>git diff</code> 本身只显示<strong>尚未暂存的改动</strong>，而不是自上次提交以来所做的所有改动。所以暂存了所有更新过的文件后，运行 git diff 会什么也不输出。</p></li></ul></li><li><p><code>git add</code> 添加进暂存区：</p><ul><li>在新版本的 Git 中，<code>git add .</code> 和 <code>git add -A</code> 操作效果一致，都是将未跟踪、已跟踪被修改，已跟踪被删除的文件添加到暂存区。</li><li><code>git add -u</code> <strong>不会将未跟踪</strong>文件添加到暂存区，<code>u</code> 即 <code>update</code>，顾名思义就是只有<strong>已被跟踪</strong>的文件被更新（删除或被修改）才会添加到暂存区。</li></ul></li><li><p><code>git rm</code> 删除：</p><ul><li><p>清除不小心添加到暂存区的文件，不想让 Git 去跟踪。如果已经提交了，需要用之前说的方式删除：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git update-index --assume-unchanged 文件路径</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>不带选项时，是<strong>同时删除</strong>暂存区和工作目录下的文件，并且该文件的状态变为<strong>左边</strong>的 <code>D</code>，即删除这一动作也会被提交。</p></li><li><p><code>--cache</code> 选项，<strong>只删除暂存区</strong>的文件，不删除工作目录的文件，比如一些中间过程文件。文件状态会同时出现在暂存区和工作目录：</p><ul><li><p>在暂存区中显示<strong>左边</strong>的 <code>D</code></p></li><li><p>在工作目录中显示<strong>未跟踪</strong>的 <code>??</code></p></li><li><p>当使用简洁输出状态的时，会产生以下奇妙输出：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git rm --cache d</span><br><span class="hljs-meta">$</span><span class="bash"> git status -s</span><br>D  d<br>?? d<br></code></pre></td></tr></tbody></table></figure></li></ul></li><li><p>可以使用 glob 模式规则选择删除文件</p></li></ul></li><li><p><code>git mv</code> <strong>移动或更名</strong>文件：</p><ul><li>格式：<code>git mv a b</code>，<code>b</code> 可以是另一个文件名，也可以是一个具体的文件路径。</li><li>工作目录和暂存区的文件都会被移动</li><li>Git 会意识到这是一次改名，文件的状态会变成 <code>renamed</code> 或<strong>左边</strong>的 <code>R</code>。</li></ul></li><li><p><code>git commit</code> 提交更新：</p><ul><li><code>-a</code> 选项，跳过使用暂存区，直接把已修改或者已删除的文件添加提交，但是对于<strong>未跟踪的新文件</strong>不会添加，一般只用在修改少量文件的提交。</li><li><code>--amend</code> 选项，尽量在未推送到远程时使用（除非只有自己用），可以<strong>替换</strong>掉当前 <code>HEAD</code> 指向的提交（校验和改变），用于补充一些修改，保持 Git 记录工整。如果不使用 <code>-m</code> 编写新的提交信息，则会使用旧的提交信息。</li></ul></li></ul><h3 id="后悔药：撤销操作-💊"><a href="#后悔药：撤销操作-💊" class="headerlink" title="后悔药：撤销操作 💊"></a>后悔药：撤销操作 💊</h3><ul><li><p><strong>强烈建议使用</strong>的 <code>git restore</code>：</p><ul><li><p>新版本的撤销命令，分担了原来 <code>git checkout</code> 和 <code>git reset</code> 的大量任务，通常格式为：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git restore [-s &lt;tree-ish&gt;] [--staged] [--worktree] 文件路径</span><br></code></pre></td></tr></tbody></table></figure></li><li><p><code>[]</code> 表示这一选项或参数可有可无。不带任何选项时，则会默认从<strong>暂存区</strong>还原工作目录下的文件。</p></li><li><p><code>-s &lt;tree&gt;</code> 选项，从 <code>&lt;tree-ish&gt;</code> 对应的提交还原文件，可以是 <code>HEAD</code>，分支名，或是提交的校验和前几位。</p></li><li><p><code>--staged</code> 选项，从 <strong><code>HEAD</code></strong> 或者在设置 <code>-s &lt;tree-ish&gt;</code> 后，从 <code>&lt;tree-ish&gt;</code> 还原文件，只会改变<strong>暂存区</strong>。</p></li><li><p><code>--worktree</code> 选项，一般和 <code>--staged</code> 一起用（因为没有 <code>--staged</code> 时就是会还原工作目录的），表示<strong>同时改变暂存区和工作目录</strong>。</p></li><li><p>通过灵活使用上述选项，改变文件状态，基本上满足工作需求</p></li></ul></li><li><p><code>git reset</code> 重置：</p><ul><li><p>当重置目标是文件时，<code>reset</code> 改变的是<strong>暂存区</strong>的对应文件，格式为：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git reset [&lt;tree-ish&gt;] [--] 文件路径</span><br></code></pre></td></tr></tbody></table></figure><p>加 <code>--</code> 会比较好一点，因为如果不幸有个分支名与路径名相同，那么 <code>reset</code> 是不能判断的（报错 <code>ambiguous argument</code>），所以要用 <code>--</code> 指定。</p><blockquote><p>重置文件后，会发现文件的状态变成了 <code>MM</code>，即<strong>暂存区</strong>的文件与 <code>HEAD</code> 和工作目录的文件都不同。这命令其实等价于：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git restore [-s &lt;tree-ish&gt;] --staged 文件路径</span><br></code></pre></td></tr></tbody></table></figure></blockquote></li><li><p>其余情况，会移动 <strong><code>HEAD</code> 指向的分支</strong> 到某一提交。格式为：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git reset [&lt;mode&gt;] [&lt;commit&gt;]</span><br></code></pre></td></tr></tbody></table></figure><p>此时有三种模式 mode：</p><ul><li><code>--soft</code>：只是将 <code>HEAD</code> 及其指向的分支移动到 <code>commit</code>，<strong>不会改变</strong>暂存区和工作目录。</li><li><code>--mixed</code>：不指定 mode 时的<strong>默认</strong>模式，将会改变暂存区与 <code>commit</code> 一致，其余同 <code>--soft</code>，不改变工作目录。</li><li><code>--hard</code>：较为<strong>危险</strong>的选项，将工作目录的<strong>修改全部丢弃</strong>，重置到 <code>commit</code> 一致，其余同 <code>--mixed</code>。</li><li>以上三种模式影响范围递增，形象对比如下：</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">原状态<br>working  index   HEAD   target         <br>   A       B      C       D <br>   <br><span class="hljs-meta">$</span><span class="bash"> git reset mode target</span>   <br>  mode	    working    index    HEAD   <br>--soft         A         B        D<br>--mixed        A         D        D<br>--hard         D         D        D<br></code></pre></td></tr></tbody></table></figure><blockquote><p>可以使用 <code>--soft</code> 模式实现所谓「<strong>压缩提交</strong>」的效果：</p><p>假设当前提交历史为 <code>a → b → c</code>，当不想保留 <code>b</code> 提交时，可以在 <code>c</code> 时使用 <code>--soft</code> 的 <code>reset</code>，使 <code>HEAD</code> 和其分支指向 <code>a</code>，同时因为暂存区不变，再提交一次即可，最终历史为：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">a -&gt; b -&gt; c<br>└--&gt; d (HEAD)<br></code></pre></td></tr></tbody></table></figure></blockquote></li></ul></li><li><p>万能的 <code>git checkout</code>：</p><ul><li><p>如果要移动 <code>HEAD</code>，格式为：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 切换到指定分支</span><br>$ git checkout [-q] [-f] [-m] [&lt;branch&gt;]<br><br><span class="hljs-comment"># 切换到 start_point，并在其上建立新分支</span><br>$ git checkout [[-b|-B] &lt;new_branch&gt;] [&lt;start_point&gt;]<br></code></pre></td></tr></tbody></table></figure><ul><li>不同于 <code>reset</code>，<code>checkout</code> <strong>仅会</strong>移动 <code>HEAD</code>，不会移动分支。这使得 <code>HEAD</code> 可能进入 <code>detach</code> <strong>分离</strong>状态，即 <code>HEAD</code> 指向了某个<strong>具体的提交记录</strong>而不是分支名，可以通过新建分支解决。</li><li><code>-B</code> 是强制建立分支，即使同名分支已存在，这会使得原同名分支移动到 <code>start_point</code>。</li><li>切换分支时尽量保持 <code>working tree clean</code>，即三棵树保持一致，否则可能会丢失修改。</li></ul></li><li><p>如果要撤销文件修改，格式为：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git checkout [&lt;tree-ish&gt;] [--] 文件路径</span><br></code></pre></td></tr></tbody></table></figure><p>这会同时修改<strong>暂存区和工作目录</strong>的对应文件，使得与 <code>tree-ish</code> 一致，这会使得修改丢失，属于<strong>危险操作</strong>。</p></li></ul></li></ul><h3 id="Git-标签-🔖"><a href="#Git-标签-🔖" class="headerlink" title="Git 标签 🔖"></a>Git 标签 🔖</h3><ul><li><p>分支很容易被人为移动，并且当有新的提交时，它也会移动，大部分分支还只是<strong>临时</strong>的。所以需要一个永远指向某个<strong>提交记录</strong>的标识，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性。这就需要打<strong>标签</strong>。</p></li><li><p>标签不会随着新的提交而移动，它就像是提交树上的一个锚点，标识了某个特定的位置。</p></li><li><p>列出已有标签：</p><p>​ 以<strong>字母顺序</strong>列出标签</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git tag</span><br>v1.0<br>v1.1<br></code></pre></td></tr></tbody></table></figure></li><li><p>轻量标签（lightweight）：</p><ul><li><p>只是某个特定提交的引用，没有注释，只有一个标签号</p></li><li><p>格式：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 没有指定 commit 会默认在当前 HEAD 指向提交上打上标签</span></span><br><span class="hljs-meta">$</span><span class="bash"> git tag &lt;tagname&gt; [&lt;commit&gt;]</span><br></code></pre></td></tr></tbody></table></figure></li></ul></li><li><p>附注标签（annotated）：</p><ul><li>是存储在 Git 数据库中的一个<strong>完整对象</strong>，可以被校验的，包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard（GPG）签名与验证。</li><li>在运行 tag 命令时<strong>指定 -a 选项</strong>，并使用 <code>-m</code> 选项指定了一条将会存储在标签中的<strong>信息</strong>。</li></ul></li><li><p>显示标签对应信息：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git show v1.0</span><br>tag v1.0<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">############################################### 附注标签才有的信息</span></span><br>Tagger: ailanxier &lt;ailanxier@ailanxier.cc&gt;<br>Date:   Sat May 3 20:19:12 2014 -0700<br><br>tag information<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">############################################### 附注标签才有的信息</span></span><br>commit ca82a6dff817ec66f44342007202690a93763949<br>Author: ailanxier &lt;ailanxier@ailanxier.com&gt;<br>Date:   Mon Mar 17 21:52:11 2008 -0700<br><br>    commit information<br></code></pre></td></tr></tbody></table></figure></li><li><p>推送标签到远程：</p><p>​ <strong>默认</strong>情况下，<code>git push</code> 命令并不会传送标签到远程仓库服务器上。在创建完标签后必须<strong>显式</strong>地推送标签到共享服务器上，就像共享远程分支一样。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git push origin &lt;tagname&gt;</span><br><span class="hljs-meta">$</span><span class="bash"> git push origin --tags</span><br></code></pre></td></tr></tbody></table></figure><p>​ 通常使用带有 <code>--tags</code> 选项的 <code>git push</code> 命令，会把<strong>所有不在远程仓库上的标签</strong>全部推送，不会区分轻量标签和附注标签。</p></li><li><p>删除标签：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git tag -d &lt;tagname&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>​ 这<strong>只会删除本地标签</strong>，如果已经推送到远程仓库了，此时删除标签是一件对别人不太友好的事，可以使用如下命令删除远程仓库的标签：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git push origin -d &lt;tagname&gt;</span><br></code></pre></td></tr></tbody></table></figure></li></ul><div class="note note-warning"><p>在已经推送标签后，最好不要使用 <code>-f</code> 选项强制替换已有标签，也不要删除标签。</p></div><ul><li><p>可以根据标签名，使用 <code>git checkout</code> 切换到标签所在的提交，但是此时通常会处于<strong>分离 <code>HEAD</code> 状态</strong>，即新的修改提交不能被分支记录，要索引到这一提交只能通过校验和。所以如果要进行更改，比如修复旧版本中的错误，那么通常需要创建一个新分支，可以使用切换并新建分支的命令：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git checkout -b      bugFix_v2.0.0     v2.0.0</span><br></code></pre></td></tr></tbody></table></figure></li></ul><h2 id="Git-分支"><a href="#Git-分支" class="headerlink" title="Git 分支"></a>Git 分支</h2><h3 id="分支简单操作"><a href="#分支简单操作" class="headerlink" title="分支简单操作"></a>分支简单操作</h3><ul><li><p>新建分支：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git branch &lt;branchname&gt; [&lt;start-point&gt;]</span><br></code></pre></td></tr></tbody></table></figure><p>如果不指定 <code>&lt;start_point&gt;</code> 则在 <code>HEAD</code> 指向的提交对象上创建一个指针，即为分支，同时在 <code>.git\refs\heads</code> 上新建一个名为 <code>branchname</code> 的文件，这个文件只含有 40 位校验和。所以创建分支是很轻量的一个操作。该命令<strong>不会切换分支</strong>。</p><div class="note note-info"><p><code>HEAD</code> 是一个特殊的指针，告诉 Git 当前在哪个分支上，且只会指向<strong>本地分支</strong>。当使用 <code>git checkout</code> 到一个远程分支时，会处于 <code>HEAD</code> 分离状态。</p></div></li><li><p>删除分支：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git branch [-d | -D] &lt;branchname&gt;</span><br></code></pre></td></tr></tbody></table></figure><p><code>-d</code> 不能删除未合并的分支，<code>-D</code> 可以强制删除这种分支。</p></li><li><p>查看分支：</p><ul><li><p>不带选项和参数的 <code>git branch</code> 命令：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git branch</span><br>* dev   <br>  mynew <br>  new   <br></code></pre></td></tr></tbody></table></figure><p>显示所有本地分支，<code>*</code> 的分支为 <code>HEAD</code> 指向的分支。</p></li><li><p><code>-v</code> 选项：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git branch -v</span><br>* dev   e31e199 [ahead 9] Merge<br>  mynew 6a1cba4 test merge branch<br>  new   6a1cba4 test merge branch<br></code></pre></td></tr></tbody></table></figure><p>显示更详细的信息，如分支指向的提交记录<strong>校验和</strong>，与远程分支的<strong>差异</strong>，提交记录的<strong>描述信息</strong>。</p></li><li><p><code>-vv</code> 选项：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git branch -vv</span><br>* dev   e31e199 [o/dev: ahead 9] Merge<br>  mynew 6a1cba4 [o/new] test merge branch<br>  new   6a1cba4 [o/new] test merge branch<br></code></pre></td></tr></tbody></table></figure><p>显示<strong>跟踪的远程分支</strong>，用的较多。</p></li><li><p><code>-a</code> 选项：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git branch -a</span><br>* dev<br>  mynew<br>  new<br>  remotes/o/dev<br>  remotes/o/new<br></code></pre></td></tr></tbody></table></figure><p>列出所有分支，包括远程分支。</p></li><li><p><code>--merged</code> 和 <code>--no-merged</code> 选项：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git branch [--merged | --no-merged] [&lt;branchname&gt;]</span><br></code></pre></td></tr></tbody></table></figure><p>显示已（未）合并到<strong>当前分支</strong> 或 <code>&lt;branchname&gt;</code>（在有该参数的情况下）的分支。一般已合并的分支，如果其为临时分支，<strong>可以删除</strong>。</p></li></ul></li><li><p><code>git branch -f</code>：</p><p>这可以当做一个新建分支命令，也可以<strong>移动现有分支到指定位置</strong>，格式为：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git branch -f &lt;branchname&gt; [&lt;start-point&gt;]</span><br></code></pre></td></tr></tbody></table></figure></li></ul><h3 id="Git-merge-🏳️‍🌈"><a href="#Git-merge-🏳️‍🌈" class="headerlink" title="Git merge 🏳️‍🌈"></a>Git merge 🏳️‍🌈</h3><ul><li><p>通常使用的格式：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git merge [--squash] [--no-commit] [&lt;commit&gt;]<br></code></pre></td></tr></tbody></table></figure><p>假设分支情况如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">   A---B---C topic<br> /<br>D---E---F---G *master<br></code></pre></td></tr></tbody></table></figure><p>在 <code>master</code> 分支合并 <code>topic</code> 分支，即执行 <code>git merge topic</code> 后，分支情况如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">   A----B----C topic<br> /             \<br>D---E---F---G---H *master<br></code></pre></td></tr></tbody></table></figure><p>会得到一个合并的提交，它有<strong>两个父提交</strong>。</p></li><li><p>解决冲突：</p><ul><li><p>合并时，如果两个分支修改了同一个文件，可能会出现冲突，Git 不能智能合并，只能手动解决冲突，提示如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">CONFLICT (content): Merge conflict in d1.txt<br>Automatic merge failed; fix conflicts and then commit the result.<br></code></pre></td></tr></tbody></table></figure><p>Git 会暂停下来，等待手动解决合并产生的冲突。在合并冲突后的任意时刻使用 <code>git status</code> 命令来查看那些因<strong>包含合并冲突而处于未合并</strong>（unmerged）状态的文件：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch dev<br>You have unmerged paths.<br>  (fix conflicts and run "git commit")<br>  (use "git merge --abort" to abort the merge)<br><br>Unmerged paths:<br>  (use "git add &lt;file&gt;..." to mark resolution)<br>        both modified:   d1.txt<br><br>no changes added to commit (use "git add" and/or "git commit -a")<br></code></pre></td></tr></tbody></table></figure></li><li><p>Git 会在有冲突的文件中加入<strong>标准的冲突解决标记</strong>，他们会包含一些<strong>特殊区段</strong>，格式如下：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>now_change<br>=======<br>new_change<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; new<br></code></pre></td></tr></tbody></table></figure><p>这表示 <code>HEAD</code> 所指示的版本（在运行 <code>merge</code> 命令之前已经切换到这个分支）在这个区段的上半部分（<code>======</code> 之上），而 <code>new</code> 分支所指示的版本在 <code>======</code> 之下。 为了解决冲突，你必须选择使用由<code>======</code> 分割的两部分中的一个，或者也可以自行合并这些内容。</p><blockquote><p>可以使用 VSCode 打开冲突文件，会有特殊的高亮和提示解决冲突，非常友好。</p></blockquote></li><li><p>在解决了所有文件里的冲突之后，对每个文件使用 <code>git add</code> 命令来将其标记为<strong>冲突已解决</strong>。此时可以使用 <code>git commit</code> 来生成合并提交，完成合并操作。</p></li></ul></li><li><p>快进 <code>Fast-forward</code> 现象：</p><ul><li>当试图合并两个分支时， 如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进，因为这种情况下的合并操作没有需要解决的分歧，所以也叫 <code>Fast-forward</code>。</li><li>例如在 <code>dev</code> 分支成功合并 <code>new</code> 后，若切换回 <code>new</code> 分支再合并 <code>dev</code>，则只会将 <code>new</code> 分支移动到 <code>dev</code> 分支，Git 显示此时发生了 <code>Fast-forward</code>。</li></ul></li><li><p><code>--squash</code> 选项：</p><p>接受被合并的分支上的所有工作，并将其压缩至一个变更集，产生一个<strong>不是合并提交</strong>的提交记录。它<strong>只有一个父提交</strong>，但却引入另一个分支的所有改动，可以在记录一个新提交前做更多的改动。</p><div class="note note-info"><p>即好像合并了，但是没完全合并，只是把<strong>另一个分支的变动</strong>拿过来合并到工作目录中而已，另一个分支不会发生任何变化。</p></div></li><li><p><code>--no-commit</code> 选项：</p><p>即将完成合并前，<strong>强制停下</strong>（否则会直接生成合并提交记录），允许用户进行修改和暂存，最后<strong>手动提交</strong>来结束合并。可以和 <code>--squash</code> 同时使用。</p></li><li><p><code>git merge --abort</code> 结束合并命令：</p><p>当合并因为 <code>--no-commit</code> 或者冲突停下时，可以使用此命令结束合并，恢复到 Git 没执行合并命令之前的状态。</p></li></ul><h3 id="Git-rebase-♐"><a href="#Git-rebase-♐" class="headerlink" title="Git rebase ♐"></a>Git rebase ♐</h3><ul><li><p>常用格式：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git rebase [-i] [--onto &lt;newbase&gt;] [&lt;branch&gt;]</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>演示过程：</p><p>假设分支情况如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">      A---B---C *topic<br>     /<br>D---E---F---G master<br></code></pre></td></tr></tbody></table></figure><p>在 <code>topic</code> 分支处执行 <code>git rebase master</code>，或者在其他任何地方执行 <code>git rebase master topic</code>，会得到一样的结果：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">              A'--B'--C' *topic<br>             /<br>D---E---F---G master<br></code></pre></td></tr></tbody></table></figure><div class="note note-info"><p><code>git rebase master topic</code> 其实会先切换到 <code>topic</code> 分支，再执行 <code>git rebase master</code>。</p></div></li><li><p>上例中 <code>rebase</code> 原理：</p><ul><li>先找到这两个分支（即当前分支 <code>topic</code>、变基操作的目标基底分支 <code>master</code>） 的<strong>最近共同祖先</strong> <code>E</code></li><li>对比当前分支相对于该祖先的历次提交，提取相应的<strong>修改</strong>并存为临时文件，将当前分支指向目标基底 <code>G</code></li><li>最后以临时文件的修改按顺序应用于 <code>G</code> 上，就好像他们是在 <code>G</code> 后完成的修改，他们的校验和会发生改变，所以在图中用带 <code>'</code> 的字母表示。</li><li>原来的提交仍然存在，但是只能通过提交的<strong>校验和</strong>访问，可以<strong>使用 <code>git reflog</code> 查看</strong> <code>HEAD</code> 移动的历史记录，找到已经不在历史中的提交校验和。</li></ul></li><li><p>这样做的好处：</p><ul><li>确保在向远程分支推送时能保持<strong>提交历史的整洁</strong>。</li><li>例如向某个其他人维护的项目贡献代码时，先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到<strong>远程分支</strong>上，然后再向主项目提交修改。</li><li>这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并（<code>Fast-forward</code>）便可。</li></ul></li><li><p>注意一种特殊情况：</p><ul><li><p>当<strong>目标基底分支</strong>已经包含了<strong>当前分支</strong>所做的<strong>相同修改</strong>（整个提交做的修改<strong>完全相同</strong>，可能是修复了同样的 bug），类似：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">      A---B---C *topic<br>     /<br>D---E---A'---F master<br></code></pre></td></tr></tbody></table></figure><p><code>A</code> 和 <code>A'</code> 所做的修改相同</p></li><li><p>此时运行变基命令，会得到：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">               B'--C' *topic<br>              /<br>D---E---A'---G master<br></code></pre></td></tr></tbody></table></figure><p><code>A</code> 的提交被跳过了，Git 认为 <code>G</code> 已经包含了 <code>A</code> 中的修改，就不会再重新做一次了。</p></li></ul></li><li><p><code>--onto</code> 选项：</p><ul><li><p>个人认为比较危险，容易<strong>丢失修改和新文件</strong>，需要对分支的改变非常熟悉才建议使用。</p></li><li><p>假设当前分支情况如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">o---o---o---o---o  master<br>         \<br>          o---o---o---o---o  next<br>                           \<br>                            o---o---o  topic<br></code></pre></td></tr></tbody></table></figure><p><code>topic</code> 分支依赖实现了某种功能的 <code>next</code> 分支，此时 <code>master</code> 分支的功能逐渐完善，已经可以让 <code>topic</code> 分支基于更稳定的 <code>master</code> 分支了，此时仅想保留 <code>topic</code> 分支中的修改，不需要 <code>next</code> 分支中的修改，则可以使用：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git rebase --onto master next topic</span><br>o---o---o---o---o  master<br>        |        \<br>        |         o'--o'--o'  topic<br>         \<br>          o---o---o---o---o  next<br></code></pre></td></tr></tbody></table></figure><div class="note note-warning"><p>如果 <code>next</code> 分支中有新文件，且 <code>topic</code> 分支中没有对新文件进行修改，则变基后<strong>新文件将消失</strong>。</p><p>同理如果 <code>topic</code> 中没有对 <code>next</code> 修改过的文件进行修改，变基后修改会消失。</p></div></li><li><p>该选项可以用来去掉一段<strong>连续的提交</strong>，但是不太推荐，还是用 <code>-i</code> 选项的 <code>rebase</code> 比较好，也能达到同样的效果，但是更安全。</p></li></ul></li><li><p><strong>非常推荐的交互式变基</strong> <code>-i</code> 选项：</p><ul><li><p>Git 会打开一个文件（如果是 VSCode 打开会有图形操作界面，如下图）并列出将要被复制到目标分支的备选<strong>提交记录</strong>，以及它们的哈希值和<strong>提交说明</strong>，有助于理解这个提交进行了哪些更改。</p><div align="center"><img src="../img/blog/git-note-images/vscode-rebase.png" srcset="/img/loading.gif" lazyload></div></li><li><p>可以根据意愿调整提交记录：</p><ul><li>调整提交记录的<strong>顺序</strong>（VSCode 通过鼠标拖放来完成）</li><li>删除不想要的提交</li><li>合并提交，有多种合并方式。</li><li>修改提交说明</li></ul></li><li><p><strong>具体选项</strong>如下：</p><ul><li><code>p, pick &lt;commit&gt; = use commit</code> 完整保留提交。</li><li><code>r, reword &lt;commit&gt; = use commit, but edit the commit message</code> 同 <code>p</code>，只是会打开编辑器修改<strong>提交说明</strong>。</li><li><code>e, edit &lt;commit&gt; = use commit, but stop for amending</code> 同 <code>p</code>，同时等待手动 <code>git commit --amend</code>，修改到满意了就会运行 <code>git rebase --continue</code> 继续变基下一个提交。</li><li><code>s, squash &lt;commit&gt; = use commit, but meld into previous commit</code> 合并提交到自己的夫提交，会打开文本编辑器修改<strong>提交说明</strong>。这个选项用的比较多。</li><li><code>f, fixup &lt;commit&gt; = like "squash" but keep only the previous commit's log message</code> 同 <code>s</code>，但是舍弃这次提交的提交说明，其实和 <code>s</code> 的区别就在于它不会打开编辑器。</li><li><code>d, drop remove commit</code> 舍弃提交。</li></ul></li></ul></li><li><p>变基是一个提交一个提交进行处理的。如果中间发生冲突也需要一个一个处理，此时 Git 会停下变基，用户可以打开<strong>冲突文件</strong>进行修改，修改完后用 <strong><code>git add .</code></strong> 添加所有的冲突文件，然后用 <strong><code>git rebase --continue</code></strong> 继续进行变基。</p><div class="note note-info"><p>Git 全程有命令提示，过程很友好。</p><p>如果想终止变基，在 Git 停下阶段使用 <code>git rebase --abort</code> 恢复到变基前状态。</p></div></li><li><p>多次 <code>rebase</code> 实例：</p><ul><li><p>来自 <a target="_blank" rel="noopener" href="https://git-scm.com/docs">Git Reference</a> 的 <code>level advanced1</code> 关卡。</p><div class="note note-info"><p>这个网站很好玩，通过关卡学习 Git 分支常用操作，不涉及暂存区，有命令条数的要求（不严格）。</p><p>一些常用命令：</p><ul><li><code>levels</code> 重新选择关卡</li><li><code>reset</code> 将分支恢复关卡开始前原状</li><li><code>show solution</code> 显示答案，建议不管有没有过关都显示一次答案</li></ul><p>它还提供了「沙盒」功能，可以提供用户使用各种具有破坏性的 Git 命令。</p></div></li><li><p>原分支情况：</p><div align="center"><img src="../img/blog/git-note-images/rebase1.png" srcset="/img/loading.gif" lazyload></div></li><li><p>目标分支情况：</p><div align="center"><img src="../img/blog/git-note-images/rebase2.png" srcset="/img/loading.gif" lazyload></div></li><li><p>执行过程：</p><ol><li><code>git rebase main bugFix</code>，得到 <code>C3'</code>。</li><li><code>git rebase bugFix side</code>，得到 <code>C4',C5',C6'</code>。</li><li><code>git rebase side another</code>，仅得到 <code>C7'</code>，这里其实对应之前说的特殊情况，<code>C4,C5</code> 和 <code>C4',C5'</code> 所作的修改是一样的，所以 <code>rebase</code> 不会将它们再放到这条提交线上。</li><li><code>git rebase another main</code>，利用快进 <code>Fast-forward</code>，使 <code>main</code> 分支更新到最新版本。</li></ol></li></ul></li></ul><h3 id="Merge-vs-Rebase"><a href="#Merge-vs-Rebase" class="headerlink" title="Merge vs. Rebase"></a>Merge vs. Rebase</h3><ul><li><p>关于使用 <code>merge</code> 和 <code>rebase</code> 的争论一直存在，甚至有人说无脑用 <code>rebase</code> 就行，笔者认为还是看情况用比较好。</p></li><li><p><code>merge</code> 保留了所有提交记录，但是分支错杂，记录树非常乱；<code>rebase</code> 可以任意修改提交记录，记录树很整洁。</p></li><li><p>有一种观点认为，仓库的提交历史即是记录实际发生过什么。它是针对历史的文档，本身就有价值，不能乱改。 从这个角度看来，改变提交历史是一种亵渎，你使用「谎言」掩盖了实际发生过的事情。如果由合并产生的提交历史是一团糟怎么办？既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。</p></li><li><p>另一种观点则正好相反，他们认为提交历史是项目过程中发生的事。 没人会出版一本书的第一版草稿，软件维护手册也是需要反复修订才能方便使用。 持这一观点的人会使用 <code>rebase</code> 及 <code>filter-branch</code> 等工具来编写故事，怎么方便后来的读者就怎么写。</p></li><li><p>书上推荐的原则：</p><p>只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从<strong>不对已推送至别处的提交执行变基</strong>操作。</p><div class="note note-warning"><p>这一原则极其重要，否则合作者可能会使用到已被变基放弃的旧提交，产生非常混乱的结果</p></div></li></ul><h2 id="Git-远程协作"><a href="#Git-远程协作" class="headerlink" title="Git 远程协作"></a>Git 远程协作</h2><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><ul><li><p>显示远程仓库的 URL：</p><p>​ 显示需要读写远程仓库的<strong>简写</strong>与其对应的 URL。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git remote -v</span><br>origin  git@github.com:ailanxier/Test.git (fetch)<br>origin  git@github.com:ailanxier/Test.git (push)<br></code></pre></td></tr></tbody></table></figure></li><li><p>添加远程仓库：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git remote add &lt;shortname&gt; &lt;url&gt;</span><br></code></pre></td></tr></tbody></table></figure></li></ul><p>​ 之后可以用字符串 <code>shortname</code> 来代替整个 URL。</p><ul><li><p><strong>联网</strong>查看远程仓库的详细信息 🧙‍♂️：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">$ git remote show origin<br>* remote origin<br>  URL: https://github.com/my-org/project<br>  Fetch URL: https://github.com/my-org/project<br>  Push  URL: https://github.com/my-org/project<br>  HEAD branch: master<br>  Remote branches:<br>    master            tracked<br>    dev-branch        tracked<br>    issue             new (<span class="hljs-built_in">next</span> fetch will store <span class="hljs-keyword">in</span> remotes/origin)<br>  Local branches configured <span class="hljs-keyword">for</span> <span class="hljs-string">'git pull'</span>:<br>    dev-branch merges <span class="hljs-keyword">with</span> remote dev-branch<br>    master     merges <span class="hljs-keyword">with</span> remote master<br>  Local refs configured <span class="hljs-keyword">for</span> <span class="hljs-string">'git push'</span>:<br>    dev-branch        pushes to dev-branch             (up to date)<br>    master            pushes to master                 (up to date)<br></code></pre></td></tr></tbody></table></figure><p>​ 同样会列出远程仓库的 URL 与<strong>跟踪分支</strong>的信息，在特定的分支上执行 <code>git push</code> 会自动地推送到哪一个远程分支，哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了，还有执行 <code>git pull</code> 时哪些分支会自动合并</p></li><li><p>移除远程仓库：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git remote rm &lt;shortname&gt;</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>重命名远程仓库：</p><p>​ 将远程仓库 <code>a</code> 重命名为 <code>b</code>。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git remote rename a b</span><br></code></pre></td></tr></tbody></table></figure></li></ul><h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><ul><li><p>远程分支的<strong>命名格式</strong>为 <code>&lt;remote name&gt;/&lt;branch name&gt;</code>，<code>&lt;remote name&gt;</code> 常见如 <code>origin</code>，<code>&lt;branch name&gt;</code> 常见如 <code>master</code>。</p><div class="note note-info"><p><code>origin</code> 和 <code>master</code> 并<strong>无特殊含义</strong>，即不是关键词，可以改成任意名字。</p><p><code>master</code> 是运行 <code>git init</code> 时默认的起始分支名字，原因仅仅是它的广泛使用，<code>origin</code> 是当你运行 <code>git clone</code> 时默认的远程仓库名字。</p></div></li><li><p>拉取到本地的远程分支，只能通过 <code>git fetch</code>，<code>git pull</code> 和 <code>git push</code> 移动，当 <code>HEAD</code> 切换到远程分支时通常会处于 <code>HEAD</code> 分离状态。</p></li><li><p>本地<strong>跟踪分支</strong>（<strong>上游分支</strong>）：</p><ul><li><p>跟踪分支是与远程分支有直接关系的本地分支。</p></li><li><p>如果在一个<strong>跟踪分支</strong>上输入 <code>git fetch</code>，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。</p><div class="note note-warning"><p>在一个跟踪分支输入 <code>git push</code>，如果和远程分支<strong>不同名</strong>，不能自动识别出要推送到哪个分支。</p></div></li><li><p><strong>新建</strong>跟踪分支的命令：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git checkout -t &lt;remote&gt;/&lt;branch&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>新建一个名为 <code>branch</code> 的分支，跟踪远程分支 <code>&lt;remote&gt;/&lt;branch&gt;</code>。</p><p>如果想<strong>自定义</strong>分支名字，可以使用：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git checkout -b &lt;branchname&gt; &lt;remote&gt;/&lt;branch&gt;</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>为<strong>当前本地分支</strong>设置（修改）上游分支：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git branch -u &lt;remote&gt;/&lt;branch&gt;</span><br></code></pre></td></tr></tbody></table></figure><div class="note note-info"><p>上游快捷方式：</p><p>当设置好跟踪分支后，可以通过简写 <code>@{u}</code> 来引用它的上游分支。</p><p>例如在 <code>master</code> 分支时并且它正在跟踪 <code>origin/master</code> 时，可以使用 <code>git merge @{u}</code> 来取代 <code>git merge origin/master</code>。</p></div></li><li><p>可以使用 <code>git branch -vv</code> 查看本地分支及其跟踪分支，属于<strong>离线操作</strong>，即没有联网。</p></li></ul></li></ul><h3 id="Fetch-Pull-Push-👨🏻‍💻"><a href="#Fetch-Pull-Push-👨🏻‍💻" class="headerlink" title="Fetch,Pull,Push 👨🏻‍💻"></a>Fetch,Pull,Push 👨🏻‍💻</h3><ul><li><p><code>git fetch</code>：</p><ul><li><p>一般格式：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git fetch [&lt;remote&gt;] [&lt;branchname&gt;]</span><br></code></pre></td></tr></tbody></table></figure><p>从远程仓库 <code>&lt;remote&gt;</code> 上抓取本地没有的数据时，它并<strong>不会修改工作目录</strong>中的内容，只会修改远程分支。</p></li><li><p>不指定 <code>remote</code> 和 <code>&lt;branchname&gt;</code>：</p><p>默认从 <code>origin</code> 远程仓库获取数据更新<strong>本地所有分支</strong>。如果一个分支<strong>已经设置了跟踪分支</strong>，则<strong>该分支</strong>从那个跟踪分支所在仓库获取数据。</p></li><li><p>指定 <code>branchname</code>：</p><p>仅更新指定远程分支。</p></li><li><p><code>git fetch --all</code>：</p><p>从<strong>所有远程仓库</strong>下载本地没有的数据。</p></li></ul></li><li><p><code>git pull</code>：</p><ul><li><p>可以理解为 <code>git fetch</code> + <code>git merge</code> 的缩写：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git pull origin foo</span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">############################# 等价于下面两条命令</span></span><br><span class="hljs-meta">$</span><span class="bash"> git fetch origin foo</span><br><span class="hljs-meta">$</span><span class="bash"> git merge origin/foo</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>需要注意最终 <code>merge</code> 的位置，无论执行 <code>git pull</code> 前处于哪个分支，这个命令都会合并到<strong>这个分支</strong>上，这个分支<strong>可能并不跟踪远程分支</strong> <code>foo</code>。所以笔者更推荐<code>git fetch</code> 后手动 <code>git merge</code>。</p></li><li><p><code>git pull</code> 例子：</p><ul><li><p>原分支情况：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">      A---B---C master on origin<br>     /<br>D---E---F---G *master<br>	⬆<br>	origin/master in your repository<br></code></pre></td></tr></tbody></table></figure></li><li><p>运行 <code>git pull</code> 后，分支情况：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">      A---B---C origin/master<br>     /         \<br>D---E---F---G---H *master<br></code></pre></td></tr></tbody></table></figure></li></ul></li><li><p>使用 <code>--rebase</code> 选项：</p><p>不适用 <code>merge</code> 策略，转而执行 <code>git fetch</code> + <code>git rebase</code>。</p></li></ul></li><li><p><code>git push</code>：</p><ul><li><p>一般格式：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git push &lt;remote&gt; &lt;branch&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>推送本地 <code>branch</code> 的变更到远程仓库 <code>remote</code>，同时<strong>本地的远程分支</strong>会移动到 <code>branch</code> 的位置。</p></li><li><p>神奇的 <code>&lt;refspec&gt;</code> 格式：</p><ul><li>使用 <code>git push origin a</code> 时，Git 自动将 <code>a</code> 分支名字展开为<code>refs/heads/a:refs/heads/a</code>， 那意味着「推送本地的 <code>a</code> 分支来更新远程仓库上的 <code>a</code> 分支」。</li><li>这种带冒号的 <code>&lt;src&gt;:&lt;dst&gt;</code> 格式为 <code>&lt;refspec&gt;</code> 格式，<code>&lt;src&gt;</code> 可以是某个具体的提交的校验和，只要是 Git 能识别的都可以起效。</li><li>这意味着上述语句等价于 <code>git push origin a:a</code>，所以我们完全可以使用 <code>git push origin b:a</code>，即使分支 <code>b</code> 和 <code>origin/a</code> 毫无关联，但是一般不会这样做。</li><li>如果 <code>&lt;dst&gt;</code> 不存在，Git 甚至会在远程仓库新建一个名为 <code>dst</code> 的远程分支。</li><li><strong>如果 <code>&lt;src&gt;</code> 为空</strong>，即使用 <code>git push origin :a</code>，会<strong>删除</strong>远程仓库中的 <code>origin/a</code> 分支</li><li><code>git push</code> 和 <code>git fetch</code> 也可以使用这样的格式，但是觉得用处不大就不提了 👻</li></ul></li><li><p><code>--all</code> 选项：</p><p><code>git push</code> 默认是只推送当前分支，该选项会推送所有分支。</p></li></ul></li></ul><h2 id="Git-杂项"><a href="#Git-杂项" class="headerlink" title="Git 杂项"></a>Git 杂项</h2><h3 id="相对引用"><a href="#相对引用" class="headerlink" title="相对引用"></a>相对引用</h3><ul><li>在 <code>^</code> 后面添加一个数字来指明<strong>哪一个</strong>父提交：<ul><li>通常用于合并提交节点，如果<strong>只有一个父节点</strong>，那么 <code>^</code> 就表示它的父节点。</li><li>对于合并提交节点：<ul><li><strong>第一父提交</strong> <code>^1</code> 是<strong>合并时所在分支</strong></li><li>第二父提交 <code>^2</code> 是所合并的分支</li></ul></li></ul></li><li>另一种相对引用是使用 <code>~</code>，同样是指向<strong>第一父提交</strong>，因此 <code>HEAD~</code> 和 <code>HEAD^</code> 是等价的。而区别在于你在后面加数字的时候，例如 <code>HEAD~2</code> 代表「第一父提交的第一父提交」。下图可以更清晰地反映区别：</li></ul><div align="center"><img src="../img/blog/git-note-images/relative.png" srcset="/img/loading.gif" lazyload></div><ul><li><code>^</code> 和 <code>~</code> 前可以是<strong>提交校验和</strong>，<strong>分支名</strong>和 <code>HEAD</code> 等。</li></ul><h3 id="交互式暂存"><a href="#交互式暂存" class="headerlink" title="交互式暂存"></a>交互式暂存</h3><ul><li><p>使用 <code>git add -i</code>，发现 Git 新世界。</p></li><li><p>Git 将会进入一个交互式终端模式，显示类似下面的东西：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git add -i</span><br>		staged 			unstaged 		path<br>	1: 	unchanged 		+0/-1 			TODO<br>	2: 	unchanged 		+1/-1 			index.html<br>	3: 	unchanged 		+5/-1 			lib/simplegit.rb<br>	<br>*** Commands ***<br>	1: [s]tatus  2: [u]pdate  3: [r]evert  4: [a]dd untracked<br>	5: [p]atch   6: [d]iff    7: [q]uit    8: [h]elp<br>What now&gt;<br></code></pre></td></tr></tbody></table></figure><p>首先显示 <code>HEAD</code> 和暂存区有差异的文件，将<strong>暂存的修改</strong>列在<strong>左侧</strong> <code>staged</code>，<strong>未暂存的修改</strong>列在<strong>右侧</strong> <code>unstaged</code>。</p><p>同时会进入循环命令状态，直到输入 <code>7</code> 或 <code>q</code> 退出（8 个命令都可以输入<strong>首字母</strong>或数字生效）。</p></li><li><p><code>1 status</code>：</p><ul><li>显示 <code>HEAD</code> 和暂存区有差异的文件，和第一次显示时一样，且是<strong>实时</strong>的，如果你在 <code>git add -i</code> 之后做了修改可以通过 <code>status</code> 得知。</li><li><code>staged</code> 的 <code>unchanged</code> 表示 <code>HEAD</code> 和暂存区的该文件相同，即还<strong>未暂存</strong>该文件。</li><li><code>unstaged</code> 的 <code>nothing</code> 表示暂存区和工作目录的该文件相同，即<strong>已暂存</strong>该文件的全部修改。</li><li>注意，这里不会显示<strong>未跟踪的新文件</strong>。</li></ul></li><li><p><code>2 update</code>：</p><ul><li><p>它会问你想要暂存哪个文件，如果没有要暂存的文件（<strong>全部已暂存</strong>或<strong>未修改</strong>或<strong>未跟踪</strong>），则会直接退出，回到循环，否则显示：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">What now&gt; u<br>		staged 			unstaged 		path<br>	1: 	unchanged 		+0/-1 			TODO<br>	2: 	unchanged 		+1/-1 			index.html<br>	3: 	unchanged 		+5/-1 			lib/simplegit.rb<br><span class="hljs-meta">Update&gt;</span><span class="bash">&gt;</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>如果要暂存 <code>TODO</code> 和 <code>index.html</code> 文件，可以输入数字或<strong>区间</strong>（本例中等价于输入 <code>1-2</code>），用<strong>空格或逗号</strong>隔开：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">Update&gt;</span><span class="bash">&gt; 1,2</span><br>		staged 			unstaged 		path<br>   *1: 	unchanged 		+0/-1 			TODO<br>   *2: 	unchanged 		+1/-1 			index.html<br>	3: 	unchanged 		+5/-1 			lib/simplegit.rb<br><span class="hljs-meta">Update&gt;</span><span class="bash">&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>每个文件前面的 <code>*</code> 意味着<strong>选中</strong>的文件将会被暂存。</p></li><li><p>如果要取消选中的 <code>TODO</code> 和 <code>index.html</code> ，使用 <code>-1 -2</code> 即可。</p></li><li><p>如果在 <code>Update&gt;&gt;</code> 提示符后不输入任何东西并直接<strong>按回车</strong>，Git 将会暂存选择的文件。</p></li></ul></li><li><p><code>3 revert</code>：</p><ul><li>显示已经<strong>暂存的文件</strong>，操作方式和 <code>2 update</code> 相同，选中并 <code>revert</code> 表示将<strong>暂存区的该文件</strong>恢复到 <code>HEAD</code> 状态，相当于 <code>git restore --staged 文件路径</code>。</li><li>对于加入暂存区的新文件，该操作会将该文件重新变为 <code>untracked</code> 状态。</li></ul></li><li><p><code>4 add untracked</code>：</p><p>显示未跟踪的新文件，操作方式同上，操作相当于 <code>git add 未跟踪文件</code>。</p></li><li><p><code>5 patch</code>：</p><p>高端操作，只暂存<strong>某个文件</strong>的部分修改，看起来挺复杂的，先不记了 🦥</p></li><li><p><code>6 diff</code>：</p><p>显示已暂存的文件，操作方式同上，操作相当于 <code>git diff --cached</code>，比较的是 <code>HEAD</code> 和暂存区文件的差异。</p></li><li><p><code>7 quit</code>：润🏃🏻</p></li></ul><div class="note note-success"><p>当你在修改了大量文件后，希望这些改动能拆分为若干提交而不是混杂在一起成为一个提交时，交互式暂存会非常有用。</p></div><h3 id="Git-stash-💾"><a href="#Git-stash-💾" class="headerlink" title="Git stash 💾"></a>Git stash 💾</h3><ul><li><p>应用背景：</p><p>当你在项目的一部分上已经工作一段时间后，所有东西都进入了混乱的状态，而这时你想要切换到另一个分支做别的事。问题是，Git 可能不允许在已修改的工作目录执行<strong>切换分支</strong>命令，你不想仅仅因为这些不成熟的修改创建一次提交。 针对这个问题的答案是使用 <code>git stash</code> 命令。</p></li><li><p><code>stash</code> 会处理工作目录的脏的状态（即<strong>跟踪文件的修改</strong>与<strong>暂存区的改动</strong>），然后将<strong>未完成的修改</strong>保存到一个栈上，而你可以在任何时候重新应用这些改动（甚至在<strong>不同的分支</strong>上）。</p></li><li><p>执行 <code>git stash</code> 或 <code>git stash push</code>（在不带选项和参数的情况下两者等价），将<strong>工作目录和暂存区</strong>的修改贮藏到栈顶，同时将这两棵树还原到 <code>HEAD</code> 状态。</p></li><li><p><code>git stash -m "描述"</code>，给这个贮藏记录像提交记录一样写描述文字</p></li><li><p><code>git stash -k</code>，在贮藏<strong>工作目录和暂存区</strong>的修改的同时，只还原工作目录到 <code>HEAD</code> 状态，保持暂存区修改不变。</p></li><li><p><code>git stash -u</code>，默认情况下，<code>git stash</code> 只会贮藏<strong>已修改和暂存的已跟踪</strong>文件。如果指定 <code>-u</code> 选项，Git 也会贮藏任何<strong>未跟踪</strong>文件。甚至对于<strong>已忽略</strong>的文件，使用 <code>-a</code> 选项也可以贮藏。</p></li><li><p><code>git stash list</code> 查看贮藏栈中的情况：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">stash@{0}: on master: using git stash -m message<br>stash@{1}: WIP on master: c264051 Revert "added file_size"<br>stash@{2}: WIP on master: 21d80a5 added number to log<br></code></pre></td></tr></tbody></table></figure><p>栈顶为 <code>stash@{0}</code>，它使用了 <code>-m</code> 选项的贮藏命令。</p><p>可以用 <code>stash@{n}</code> 来指代任意贮藏记录，在命令格式中使用 <code>&lt;stash&gt;</code> 表示。</p></li><li><p><code>git stash show [&lt;stash&gt;]</code>：</p><p>显示某条贮藏记录的 <code>diff</code> 差异，不带 <code>&lt;stash&gt;</code> 参数时默认显示栈顶贮藏记录。</p></li><li><p><code>git stash pop [--index] [&lt;stash&gt;]</code>：</p><ul><li>删除栈顶或 <code>&lt;stash&gt;</code> 的贮藏记录，同时应用在当前<strong>工作目录</strong>。</li><li>如果产生<strong>冲突</strong>，则需要在解决冲突后，使用 <code>git add .</code> 并 <code>git commit</code> 解决冲突状态。注意这种情况 Git <strong>不会自动删除</strong>栈中对应贮藏记录。可以使用 <code>drop</code> 删除（后面有讲）。</li><li>使用 <code>--index</code> 选项，会将贮藏记录的修改应用到当前<strong>暂存区</strong>。</li></ul></li><li><p><code>git stash apply [--index] [&lt;stash&gt;]</code>：</p><p>除了<strong>不删除</strong>贮藏记录外，功能完全相同，用得较多。</p></li><li><p><code>git stash drop [&lt;stash&gt;]</code>：</p><p>删除栈顶或 <code>&lt;stash&gt;</code> 的贮藏记录。</p></li><li><p><code>git stash clear</code>：</p><p>删除所有贮藏记录。</p></li><li><p><code>git stash branch &lt;branchname&gt; [&lt;stash&gt;]</code>：</p><ul><li>对于一些会对当前节点<strong>发生冲突</strong>的贮藏记录，可以通过在<strong>贮藏记录原本的提交节点</strong>新建一个分支，应用贮藏的所有修改，进行测试处理。</li><li>因为是在本来的节点上新建分支，所以是<strong>不会发生冲突</strong>的（本来就在这个节点基础上做的修改）。</li><li>该命令会删除栈顶或 <code>&lt;stash&gt;</code> 的贮藏记录，并同时对<strong>暂存区和工作目录</strong>产生影响。</li></ul></li></ul><h3 id="Git-clean-🧹"><a href="#Git-clean-🧹" class="headerlink" title="Git clean 🧹"></a>Git clean 🧹</h3><ul><li><p>常用格式：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git clean [-d] [-x | -X] -i [--] [文件路径]</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>命令可以用于清理不在版本控制范围内的文件，即<strong>未跟踪</strong>的文件，但不清理<strong>已忽略</strong>的文件。</p></li><li><p>命令默认只清理 <code>.git</code> 所知文件夹下的文件，<strong>不清理未跟踪文件夹</strong>下的文件。</p></li><li><p>如果指定了<strong>文件路径</strong>，那么 <code>-d</code> 和 <code>-x | -X</code> 都不生效。</p></li><li><p><code>-d</code> 选项：</p><p>递归进入<strong>未跟踪的文件夹</strong>下清理文件。</p></li><li><p><code>-x</code> 选项：</p><p>清理范围包括<strong>已忽略</strong>的文件。</p></li><li><p><code>-X</code> 选项：</p><p>清理范围<strong>只包括已忽略</strong>的文件。</p></li><li><p><code>-i</code> 选项：</p><ul><li><p>推荐使用该命令时都加上 <code>-i</code> 选项，使用交互式清理方式，一目了然要清理哪些文件。</p></li><li><p>显示的交互界面如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git clean -i</span><br>Would remove the following item:<br>  a b c<br>*** Commands ***<br>    1: clean                2: filter by pattern    3: select by numbers<br>    4: ask each             5: quit                 6: help<br></code></pre></td></tr></tbody></table></figure></li><li><p><code>1 clean</code>：</p><p>删除 <code>Would remove the following item:</code> 下的文件，并退出交互模式。</p></li><li><p><code>2 filter by pattern</code>：</p><p>列出当前删除范围内的文件，输入 <code>*.txt</code> 等文件类型进行过滤，过滤的文件<strong>移出</strong>删除范围：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git clean -i</span><br>Would remove the following items:<br>  1/1.md   1/1.txt<br>*** Commands ***<br>    1: clean                2: filter by pattern    3: select by numbers<br>    4: ask each             5: quit                 6: help<br>What now&gt; 2<br>  1/1.md   1/1.txt<br>Input ignore patterns&gt;&gt; *.md<br>  1/1.txt<br>Input ignore patterns&gt;&gt;<br>Would remove the following item:<br>  1/1.txt<br>*** Commands ***<br>    1: clean                2: filter by pattern    3: select by numbers<br>    4: ask each             5: quit                 6: help<br>What now&gt;<br></code></pre></td></tr></tbody></table></figure><p>输入 <code>*.md</code>，不删除 <code>1.md</code> 文件。</p></li><li><p><code>3 select by numbers</code>：</p><p>按顺序列出删除范围内的文件，通过数字进行选择哪些文件要删除：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git clean -i</span><br>Would remove the following items:<br>  1/1.md   1/1.txt<br>*** Commands ***<br>    1: clean                2: filter by pattern    3: select by numbers<br>    4: ask each             5: quit                 6: help<br>What now&gt; 3<br>    1: 1/1.md     2: 1/1.txt<br>Select items to delete&gt;&gt; 2<br>    1: 1/1.md   * 2: 1/1.txt<br>Select items to delete&gt;&gt;<br>Would remove the following item:<br>  1/1.txt<br>*** Commands ***<br>    1: clean                2: filter by pattern    3: select by numbers<br>    4: ask each             5: quit                 6: help<br>What now&gt;<br></code></pre></td></tr></tbody></table></figure></li><li><p><code>4 ask each</code>：</p><p>逐个询问在删除范围内的文件，是否要删除，全部询问后退出交互模式：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git clean -i</span><br>Would remove the following items:<br>  1/1.md   1/1.txt<br>*** Commands ***<br>    1: clean                2: filter by pattern    3: select by numbers<br>    4: ask each             5: quit                 6: help<br>What now&gt; 4<br>Remove 1/1.md [y/N]? n<br>Remove 1/1.txt [y/N]? y<br>Removing 1/1.txt<br></code></pre></td></tr></tbody></table></figure></li></ul></li></ul><h3 id="Git-Cherry-pick-🌸"><a href="#Git-Cherry-pick-🌸" class="headerlink" title="Git Cherry-pick 🌸"></a>Git Cherry-pick 🌸</h3><ul><li><p>命令格式很简单：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git cherry-pick [-n] [-m] 可以多个&lt;commit&gt;</span><br><span class="hljs-meta">$</span><span class="bash"> git cherry-pick (--<span class="hljs-built_in">continue</span> | --skip | --abort | --quit)</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>拣选一个或多个提交的修改到 <code>HEAD</code> 下，例如原分支情况如下：</p><div align="center"><img src="../img/blog/git-note-images/cherry1.png" srcset="/img/loading.gif" lazyload></div><p>​ 执行命令 <code>git cherry-pick C3 C4 C7</code> 后，分支变成：</p><div align="center"><img src="../img/blog/git-note-images/cherry2.png" srcset="/img/loading.gif" lazyload></div></li><li><p>要求执行命令前保持 <code>working tree clean</code>，可能要像 <code>git merge</code> 一样合并冲突，合并后使用 <code>git add</code> 和 <code>git cherry-pick --continue</code> 生成新的提交。</p></li><li><p><code>-n</code> 选项：</p><p>合并后不自动生成提交，并且退出 <code>CHERRY-PICKING</code> 状态，即不能再使用 <code>git cherry-pick [--continue | --skip | --abort | --quit]</code> 等命令，需要手动 <code>git commit</code> 生成提交。</p></li><li><p><code>-m</code> 选项：</p><p>拣选不能选择合并提交的节点，除非使用 <code>-m &lt;parent-number&gt;</code>，<code>&lt;parent-number&gt;</code> 指的是哪个父节点，相当于之前说的相对引用 <code>^&lt;parent-number&gt;</code></p></li><li><p><code>--continue</code> 都很熟悉了；<code>--skip</code> 跳过当前某个 <code>cherry-pick</code> 的提交；<code>--abort</code> 终止整个 <code>cherry-pick</code> 过程并还原到初始状态；<code>--quit</code> 退出 <code>CHERRY-PICKING</code> 状态，可以中途退出拣选过程，不完成整个过程。</p></li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E7%A7%91%E6%8A%80%E7%AC%94%E8%AE%B0/" class="category-chain-item">科技笔记</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Git/">#Git</a></div></div><div class="license-box my-3"><div class="license-title"><div>Git 学习笔记</div><div>https://ailanxier.top/git</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Zeyu Dong</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年1月18日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"></article><article class="post-next col-6"><a href="/Database_System" title="数据库系统笔记"><span class="hidden-mobile">数据库系统笔记</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments("#valine",function(){Fluid.utils.createScript("https://lib.baomitu.com/valine/1.4.16/Valine.min.js",function(){var i=Object.assign({appId:"RPMS8nldJp0JoyyYWovwKE7g-gzGzoHsz",appKey:"XyHCoNwPhJnfnVvl8QA63j3L",path:"window.location.pathname",placeholder:null,avatar:"retro",meta:["nick","mail","link"],requiredFields:[],pageSize:10,lang:"zh-CN",highlight:!1,recordIP:!1,serverURLs:"",emojiCDN:null,emojiMaps:null,enableQQ:!1},{el:"#valine",path:window.location.pathname});new Valine(i),Fluid.utils.waitElementVisible("#valine .vcontent",()=>{var i="#valine .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(i),Fluid.plugins.fancyBox(i)})})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.13.10/mermaid.min.js",function(){mermaid.initialize({theme:"default"})})</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,t=t.getElementById("subtitle");t&&e&&e(t.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-t}),0<o.find(".toc-list-item").length&&o.css("visibility","visible"))})</script><script>!function(){var n,i=CONFIG.code_language.enable&&CONFIG.code_language.default,t=CONFIG.copy_btn;(i||t)&&(n="",n+='<div class="code-widget">',n+="LANG",n+="</div>",jQuery(".markdown-body pre").each(function(){var e,a=jQuery(this);0<a.find("code.mermaid").length||0<a.find("span.line").length||(e="",i&&(e=CONFIG.code_language.default,0<a[0].children.length&&2<=a[0].children[0].classList.length&&a.children().hasClass("hljs")?e=a[0].children[0].classList[1]:a[0].getAttribute("data-language")?e=a[0].getAttribute("data-language"):a.parent().hasClass("sourceCode")&&0<a[0].children.length&&2<=a[0].children[0].classList.length?(e=a[0].children[0].classList[1],a.parent().addClass("code-wrapper")):a.parent().hasClass("markdown-body")&&0===a[0].classList.length&&a.wrap('<div class="code-wrapper"></div>'),e=e.toUpperCase().replace("NONE",CONFIG.code_language.default)),a.append(n.replace("LANG",e).replace('code-widget">',(a=a[0],(0<=Fluid.utils.getBackgroundLightness(a)?"code-widget-light":"code-widget-dark")+(t?' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>':' code-widget">')))),t&&Fluid.utils.createScript("https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js",function(){new window.ClipboardJS(".copy-btn",{target:function(e){for(var a=e.parentNode.childNodes,n=0;n<a.length;n++)if("CODE"===a[n].tagName)return a[n]}}).on("success",function(e){e.clearSelection(),e.trigger.innerHTML=e.trigger.innerHTML.replace("icon-copy","icon-success"),setTimeout(function(){e.trigger.innerHTML=e.trigger.innerHTML.replace("icon-success","icon-copy")},2e3)})}))}))}()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o,n=[];for(o of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))n.push(".markdown-body > "+o.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))})</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script>MathJax={tex:{inlineMath:{"[+]":[["$","$"]]}},loader:{load:["ui/lazy"]},options:{renderActions:{findScript:[10,n=>{document.querySelectorAll('script[type^="math/tex"]').forEach(e=>{var t=!!e.type.match(/; *mode=display/);const a=new n.options.MathItem(e.textContent,n.inputJax[0],t);t=document.createTextNode("");e.parentNode.replaceChild(t,e),a.start={node:t,delim:"",n:0},a.end={node:t,delim:"",n:0},n.math.push(a)})},"",!1],insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(e=>{let t=e.parentNode;"li"===t.nodeName.toLowerCase()&&t.parentNode.classList.add("has-jax")})},"",!1]}}}</script><script src="https://lib.baomitu.com/mathjax/3.2.0/es5/tex-mml-chtml.js"></script><script src="/js/local-search.js"></script><script defer src="/js/leancloud.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ["$","$"], ["\\(","\\)"] ], skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'], processEscapes: true } }); MathJax.Hub.Queue(function() { var all = MathJax.Hub.getAllJax(); for (var i = 0;
    i
    < all.length; ++i) all[i].SourceElement().parentNode.className +=' has-jax' ; });</script><script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg-full.js"></script></body></html>